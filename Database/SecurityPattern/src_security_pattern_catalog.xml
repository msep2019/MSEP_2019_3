<?xml version="1.0" encoding="UTF-8" ?>
<!-- Created from PDF via Acrobat SaveAsXML -->
<!-- Mapping Table version: 28-February-2003 -->
<TaggedPDF-doc>
<?xpacket begin='﻿' id='W5M0MpCehiHzreSzNTczkc9d'?>
<?xpacket begin="﻿" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.6-c016 91.163616, 2018/10/29-16:58:49        ">
   <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
      <rdf:Description rdf:about=""
            xmlns:xmp="http://ns.adobe.com/xap/1.0/"
            xmlns:pdf="http://ns.adobe.com/pdf/1.3/"
            xmlns:dc="http://purl.org/dc/elements/1.1/">
         <xmp:CreateDate>2013-04-28T13:01:30+02:00</xmp:CreateDate>
         <xmp:CreatorTool/>
         <pdf:Producer>wkhtmltopdf</pdf:Producer>
         <dc:format>xml</dc:format>
         <dc:title>
            <rdf:Alt>
               <rdf:li xml:lang="x-default"/>
            </rdf:Alt>
         </dc:title>
      </rdf:Description>
   </rdf:RDF>
</x:xmpmeta>
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                                                                                                    
                           
<?xpacket end="w"?>
<?xpacket end='r'?>
<bookmark-tree>
<bookmark title="Security Pattern Catalog">
<destination structID="LinkTarget_2431"/>
</bookmark>
<bookmark title="Application Firewall">
<destination structID="LinkTarget_2432"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2433"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2433"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2434"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2435"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2436"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2437"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2438"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2439"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2440"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2441"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2442"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2443"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2444"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2445"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Audit Interceptor">
<destination structID="LinkTarget_2446"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2447"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2447"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2448"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2449"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2450"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2451"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2452"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2453"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2454"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2455"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2456"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2457"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2458"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2459"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Authentication Enforcer">
<destination structID="LinkTarget_2460"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2461"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2461"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2462"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2463"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2464"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2465"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2466"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2467"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2468"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2469"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2470"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2471"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2472"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2473"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Authorization Enforcer">
<destination structID="LinkTarget_2474"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2475"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2475"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2476"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2477"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2478"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2479"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2480"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2481"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2482"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2483"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2484"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2485"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2486"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2487"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Checkpointed System">
<destination structID="LinkTarget_2488"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2489"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2489"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2490"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2491"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2492"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2493"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2494"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2495"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2496"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2497"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2498"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2499"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2500"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2501"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Comparator Checked Fault Tolerant System">
<destination structID="LinkTarget_2502"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2503"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2503"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2504"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2505"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2506"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2506"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2507"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2508"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2509"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2510"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2511"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2512"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2513"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2514"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Container Managed Security">
<destination structID="LinkTarget_2515"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2516"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2516"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2517"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2518"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2519"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2520"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2521"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2522"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2523"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2524"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2525"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2526"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2527"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2528"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Controlled Object Factory">
<destination structID="LinkTarget_2529"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2530"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2530"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2531"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2532"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2533"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2534"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2535"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2536"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2537"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2538"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2539"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2540"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2541"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2542"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Controlled Object Monitor">
<destination structID="LinkTarget_2543"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2544"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2544"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2545"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2546"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2547"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2548"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2549"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2550"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2551"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2552"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2553"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2554"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2555"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2556"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Controlled Process Creator">
<destination structID="LinkTarget_2557"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2558"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2558"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2559"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2560"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2561"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2562"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2563"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2564"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2565"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2566"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2567"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2568"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2569"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2570"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Credential Tokenizer">
<destination structID="LinkTarget_2571"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2572"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2572"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2573"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2574"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2575"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2576"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2577"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2578"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2579"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2580"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2581"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2582"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2583"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2584"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Demilitarized Zone">
<destination structID="LinkTarget_2585"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2586"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2586"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2587"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2588"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2589"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2590"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2591"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2592"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2593"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2594"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2595"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2596"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2597"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2598"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Encrypted Storage">
<destination structID="LinkTarget_2599"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2600"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2600"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2601"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2602"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2603"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2604"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2605"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2606"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2607"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2608"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2609"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2610"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2611"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2612"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Firewall">
<destination structID="LinkTarget_2613"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2614"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2614"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2615"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2616"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2617"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2618"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2619"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2620"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2621"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2622"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2623"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2624"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2625"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2626"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Full View with Errors">
<destination structID="LinkTarget_2627"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2628"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2628"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2629"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2630"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2631"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2632"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2633"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2634"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2635"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2636"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2637"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2638"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2639"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2640"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Input Guard">
<destination structID="LinkTarget_2641"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2642"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2642"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2643"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2644"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2645"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2646"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2647"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2648"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2649"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2650"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2651"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2652"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2653"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2654"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Replicated System">
<destination structID="LinkTarget_2655"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2656"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2657"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2658"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2659"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2660"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2661"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2662"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2663"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2664"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2665"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2666"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2667"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2668"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2669"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Reverse Proxy">
<destination structID="LinkTarget_2670"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2671"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2671"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2672"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2673"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2674"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2675"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2676"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2677"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2678"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2679"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2680"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2681"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2682"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2683"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Secure Access Layer">
<destination structID="LinkTarget_2684"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2685"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2685"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2686"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2687"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2688"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2689"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2690"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2691"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2692"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2693"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2694"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2695"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2696"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2697"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Secure Logger">
<destination structID="LinkTarget_2698"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2699"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2699"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2700"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2701"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2702"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2703"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2704"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2705"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2706"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2707"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2708"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2709"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2710"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2711"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Secure Message Router">
<destination structID="LinkTarget_2712"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2713"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2713"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2714"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2715"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2716"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2717"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2718"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2719"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2720"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2721"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2722"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2723"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2724"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2725"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Secure Pipe">
<destination structID="LinkTarget_2726"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2727"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2727"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2728"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2729"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2730"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2731"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2732"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2733"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2734"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2735"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2736"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2737"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2738"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2739"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Secure Service Facade">
<destination structID="LinkTarget_2740"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2741"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2741"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2742"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2743"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2744"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2745"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2746"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2747"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2748"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2749"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2750"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2751"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2752"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2753"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Secure Session Object">
<destination structID="LinkTarget_2754"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2755"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2755"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2756"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2757"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2758"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2759"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2760"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2761"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2762"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2763"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2764"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2765"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2766"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2767"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Security Association">
<destination structID="LinkTarget_2768"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2769"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2769"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2770"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2771"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2772"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2773"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2774"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2775"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2776"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2777"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2778"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2779"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2780"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2781"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Security Context">
<destination structID="LinkTarget_2782"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2783"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2783"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2784"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2785"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2786"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2787"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2787"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2788"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2789"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2790"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2791"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2792"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2793"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2794"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Server Sandbox">
<destination structID="LinkTarget_2795"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2796"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2796"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2797"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2798"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2799"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2800"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2801"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2802"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2803"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2804"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2805"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2806"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2807"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2808"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Session Failover">
<destination structID="LinkTarget_2809"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2810"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2811"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2812"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2813"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2814"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2815"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2816"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2817"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2818"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2819"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2820"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2821"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2822"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2823"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Session">
<destination structID="LinkTarget_2824"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2825"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2825"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2826"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2827"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2828"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2829"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2830"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2831"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2832"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2833"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2834"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2835"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2836"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2837"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Session Timeout">
<destination structID="LinkTarget_2838"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2839"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2840"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2841"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2842"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2843"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2844"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2845"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2846"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2847"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2848"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2849"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2850"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2851"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2852"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Single Access Point">
<destination structID="LinkTarget_2853"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2854"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2855"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2856"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2857"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2858"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2859"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2860"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2861"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2862"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2863"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2864"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2865"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2866"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2867"/>
</bookmark>
</bookmark>
</bookmark>
<bookmark title="Subject Descriptor">
<destination structID="LinkTarget_2868"/>
<bookmark title="Pattern documentation">
<destination structID="LinkTarget_2869"/>
<bookmark title="Quick info">
<destination structID="LinkTarget_2869"/>
</bookmark>
<bookmark title="Problem">
<destination structID="LinkTarget_2870"/>
</bookmark>
<bookmark title="Forces">
<destination structID="LinkTarget_2871"/>
</bookmark>
<bookmark title="Example">
<destination structID="LinkTarget_2872"/>
</bookmark>
<bookmark title="Solution">
<destination structID="LinkTarget_2873"/>
<bookmark title="Structure">
<destination structID="LinkTarget_2874"/>
</bookmark>
<bookmark title="Dynamics">
<destination structID="LinkTarget_2875"/>
</bookmark>
<bookmark title="Participants">
<destination structID="LinkTarget_2876"/>
</bookmark>
<bookmark title="Collaborations">
<destination structID="LinkTarget_2877"/>
</bookmark>
</bookmark>
<bookmark title="Implementation">
<destination structID="LinkTarget_2878"/>
</bookmark>
<bookmark title="Pitfalls">
<destination structID="LinkTarget_2879"/>
</bookmark>
<bookmark title="Consequences">
<destination structID="LinkTarget_2880"/>
</bookmark>
<bookmark title="Known uses">
<destination structID="LinkTarget_2881"/>
</bookmark>
</bookmark>
</bookmark>
</bookmark-tree>

<Part>
<H3 id="LinkTarget_2431">Security Pattern Catalog </H3>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_0.jpg"/>
</Figure>

<Lbl>
<Link>Application </Link>
</Lbl>

<LBody>Firewall </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1.jpg"/>
</Figure>

<Lbl>Audit </Lbl>

<LBody>
<Link>Interceptor </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_2.jpg"/>
</Figure>

<Lbl>
<Link>Authentication </Link>
</Lbl>

<LBody>Enforcer </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_3.jpg"/>
</Figure>

<Lbl>
<Link>Authorization </Link>
</Lbl>

<LBody>Enforcer </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_4.jpg"/>
</Figure>

<Lbl>
<Link>Checkpointed </Link>
</Lbl>

<LBody>System </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_5.jpg"/>
</Figure>

<Lbl>Comparator </Lbl>

<LBody>
<Link>Checked Fault Tolerant System </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_6.jpg"/>
</Figure>

<Lbl>Container </Lbl>

<LBody>
<Link>Managed Security </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_7.jpg"/>
</Figure>

<Lbl>Controlled </Lbl>

<LBody>
<Link>Object Factory </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_8.jpg"/>
</Figure>

<Lbl>Controlled </Lbl>

<LBody>
<Link>Object Monitor </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_9.jpg"/>
</Figure>

<Lbl>Controlled </Lbl>

<LBody>
<Link>Process Creator </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_10.jpg"/>
</Figure>

<Lbl>
<Link>Credential </Link>
</Lbl>

<LBody>Tokenizer </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_11.jpg"/>
</Figure>

<Lbl>
<Link>Demilitarized </Link>
</Lbl>

<LBody>Zone </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_12.jpg"/>
</Figure>

<Lbl>
<Link>Encrypted </Link>
</Lbl>

<LBody>Storage 
<Link>Firewall </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_13.jpg"/>
</Figure>

<Lbl>Full </Lbl>

<LBody>
<Link>View with Errors </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_14.jpg"/>
</Figure>

<Lbl>Input </Lbl>

<LBody>
<Link>Guard </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_15.jpg"/>
</Figure>

<Lbl>
<Link>Limited </Link>
</Lbl>

<LBody>View </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_16.jpg"/>
</Figure>

<Lbl>Load </Lbl>

<LBody>
<Link>Balancer </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_17.jpg"/>
</Figure>

<Lbl>Obfuscated </Lbl>

<LBody>
<Link>Transfer Object </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_18.jpg"/>
</Figure>

<Lbl>
<Link>Output </Link>
</Lbl>

<LBody>Guard </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_19.jpg"/>
</Figure>

<Lbl>
<Link>Replicated </Link>
</Lbl>

<LBody>System </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_20.jpg"/>
</Figure>

<Lbl>
<Link>Reverse </Link>
</Lbl>

<LBody>Proxy </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_21.jpg"/>
</Figure>

<Lbl>Secure </Lbl>

<LBody>
<Link>Access Layer </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_22.jpg"/>
</Figure>

<Lbl>
<Link>Secure </Link>
</Lbl>

<LBody>Logger </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_23.jpg"/>
</Figure>

<Lbl>Secure </Lbl>

<LBody>
<Link>Message Router </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_24.jpg"/>
</Figure>

<Lbl>
<Link>Secure </Link>
</Lbl>

<LBody>Pipe </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_25.jpg"/>
</Figure>

<Lbl>Secure </Lbl>

<LBody>
<Link>Service Facade </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_26.jpg"/>
</Figure>

<Lbl>Secure </Lbl>

<LBody>
<Link>Session Object </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_27.jpg"/>
</Figure>

<Lbl>Security </Lbl>

<LBody>
<Link>Association </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_28.jpg"/>
</Figure>

<Lbl>
<Link>Security </Link>
</Lbl>

<LBody>Context </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_29.jpg"/>
</Figure>

<Lbl>Server </Lbl>

<LBody>
<Link>Sandbox </Link>

<Link>Session </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_30.jpg"/>
</Figure>

<Lbl>
<Link>Session </Link>
</Lbl>

<LBody>Failover </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_31.jpg"/>
</Figure>

<Lbl>
<Link>Session </Link>
</Lbl>

<LBody>Timeout </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_32.jpg"/>
</Figure>

<Lbl>Single </Lbl>

<LBody>
<Link>Access Point </Link>
</LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_33.jpg"/>
</Figure>

<Lbl>Subject </Lbl>

<LBody>
<Link>Descriptor </Link>
</LBody>
</LI>
</L>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_34.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_35.jpg"/>
</Figure>
</Part>

<Part>
<H3 id="LinkTarget_2432">Application Firewall </H3>
<Figure id="LinkTarget_2433">

<ImageData src="images/4-Security Pattern Catalog_img_36.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: To filter calls and responses to/from enterprise applications, based on an institution access control policy. Aliases: Content Firewall </P>
<Figure id="LinkTarget_2434">

<ImageData src="images/4-Security Pattern Catalog_img_37.jpg"/>
Problem</Figure>

<P>Enterprise applications in an organization's internal network are accessed by a broad spectrum of users that may attempt to abuse its resources (leakage, modification or destruction of data). These applications can be numerous, thus implementing access control independently in ad hoc ways and may make the system more complex and thus less secure. </P>

<P>Moreover, traditional network firewalls (application layer firewalls or packet filters), do not make it possible to define high level rules (role-based or individual-based rules)that could make the implementation of business security policies easier and simpler. </P>
<Figure id="LinkTarget_2435">

<ImageData src="images/4-Security Pattern Catalog_img_38.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_39.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>may be many users (subjects)that need to access an application in different ways; the firewall must adapt to this variety. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_40.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>are many ways to filter application inputs, we need to separate the filtering code from the application code. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_41.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>may be numerous applications that may require different levels of security. We need to define appropriate policies for each application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_42.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>business policies are constantly changing and they need to be constantly updated; hence it should be easy to change the firewall filtering configuration. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_43.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>number of users and applications may increase significantly; adding more users or applications should be done transparently and at proper cost. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_44.jpg"/>
</Figure>

<Lbl>Network </Lbl>

<LBody>firewalls cannot understand the semantics of applications and are unable to filter out potentially harmful messages. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2436">

<ImageData src="images/4-Security Pattern Catalog_img_45.jpg"/>
Example</Figure>

<P>Consider a medical record application in a Hospital. One of the services it provides is to allow patients to lookup their personal medical records from home. To ensure that only patients can access this service, the patient must first be authenticated and then she must be identified as a patient. Finally, the application must ensure that only the medical records belonging to the patient are returned (i. e., match the name in the medical record with that of the user). </P>

<P>One way to provide this security is to let application maintain list of all valid patients with their authentication credentials, and implement the code for blocking unauthorized access from within the application level code of the application. This approach has several problems. In the future, if the hospital decides to allow patients to be able to schedule appointments, it will have to repeat the implementation of the access control code for the scheduling application as well. Furthermore, if there are changes in hospital business policies, e. g. they want to allow external primary care physicians access the medical records of their own patients, these applications will have to be rewritten. In this changing scenario, a new access control list for authorized primary care physicians will have to be added to medical record application, and a list of patients will have to be associated with each physician to indicate the patients belonging to a doctor. Such application modifications are time consuming, difficult to manage, expensive and error prone. </P>
<Figure id="LinkTarget_2437">

<ImageData src="images/4-Security Pattern Catalog_img_46.jpg"/>
Solution</Figure>

<P>Interpose a firewall that can analyze incoming requests for application services and check them for authorization. A client can access a service of an application only if a specific policy authorizes it to do so. Policies for each application are centralized within the Application Firewall, and they are accessed through a PolicyAuthorizationPoint. Each application is accessed by a client through a PolicyEnforcementPoint that enforces access control by looking for a matching policy in the PolicyBase. This enforcement may include authenticating the client through its identity data stored in the IdentityBase. </P>
<Figure id="LinkTarget_2438">

<ImageData src="images/4-Security Pattern Catalog_img_47.jpg"/>
Structure</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_48.jpg"/>
</Figure>


<H5>Figure 1: Application firewall class diagram. </H5>

<P>Figure 1 shows the class diagram for the Application Firewall. </P>
<Figure id="LinkTarget_2439">

<ImageData src="images/4-Security Pattern Catalog_img_49.jpg"/>
Dynamics</Figure>

<P>We describe the dynamic aspects of the Application Firewall using sequence diagrams for two use cases: filtering a Client's request with user authentication and adding a new policy. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_50.jpg"/>
</Figure>

<P>Figure 2: Application firewall sequence diagram: filtering a request. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_51.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_51.jpg"/>
</Figure>



<H5>Figure 3: Application firewall sequence diagram: adding a new policy. </H5>
<Figure id="LinkTarget_2440">

<ImageData src="images/4-Security Pattern Catalog_img_52.jpg"/>
Participants</Figure>

<P>Classes Client and Service have the usual meaning. A Client accesses a service provided by an application. The access requests are controlled by authorization rules (denoted here as policies to follow the usual industrial notation), and represented by class Policy. Policies are collected in a policy base (PolicyBase). </P>

<P>The firewall consists of one PolicyAuthorizationPoint which centralizes the definition of the policies and identities throughout the institution, and several PolicyEnforcementPoints, which are intended to actually check the accesses to the applications. The enterprise applications are represented by the class Application that is made up of Services. A service is identified by a serviceId, which is usually and URI or an URL. </P>
<Figure id="LinkTarget_2441">

<ImageData src="images/4-Security Pattern Catalog_img_53.jpg"/>
Collaborations</Figure>

<P>A Client requests access to a service of an application to either input or retrieve information. The access request is made through the PolicyEnforcementPoint, which accesses the PolicyAuthorizationPoint to determines whether to accept or deny the request. Figure 2 corresponds to this basic use case. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_54.jpg"/>
</Figure>
Actors: A Client </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_55.jpg"/>
</Figure>
Precondition: Existing IdentityBase and PolicyBase classes must be in place in the firewall. The IdentityBase contains the data necessary to authenticate a Client. The PolicyBase contains specific policies defined by the organization. Description: </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_56.jpg"/>
</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_57.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>Client requests access to an application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_58.jpg"/>
</Figure>

<Lbl>An </Lbl>

<LBody>Application Firewall, through its PolicyEnforcementPoint, intercepts the request and accesses the PolicyAuthorizationPoint. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_59.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>PolicyAuthorizationPoint authenticates the Client through its IdentityBase. This step may be avoided for each request through the use of a Session class. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_60.jpg"/>
</Figure>

<Lbl>Once </Lbl>

<LBody>the Client is authenticated and identified, the PolicyAuthorizationPoint filters the request according to the PolicyBase. The request is accepted or denied according to the defined policies. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_61.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>the request is accepted, the firewall allows access to the service of the application and the access is logged into the Application Firewall. </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_62.jpg"/>
</Figure>
Alternate Flows: If the Client is not recognized or if no policy allows the specific Client to access the specified service, the firewall rejects the access request to the service. If the user has already been authenticated, the Client may not be authenticated again (Single Sign-On use). </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_63.jpg"/>
</Figure>
Postcondition: The firewall has provided the access of a Client to a service, based on verifying the identity of the Client, and the existence of a matching policy.In the case of adding a new policy: the security administrator intends to add a new policy to the set of policies. Before adding it, the firewall checks whether the new policy to be added does not already exist in the rule set. Figure 3 illustrates this use case. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_64.jpg"/>
</Figure>
Actors: Administrator. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_65.jpg"/>
</Figure>
Precondition: The administrator must have authorization to add rules. Description: </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_66.jpg"/>
</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_67.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>administrator initiates the addition of a new rule. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_68.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>the rule does not already exist in the rule set then it is added. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_69.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>firewall acknowledges the addition of the new rule. </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_70.jpg"/>
</Figure>
Alternate Flow: The rule is not added because it already exists in the rule set. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_71.jpg"/>
</Figure>
Postcondition: A new rule is added to the rule set of the firewall. </P>
<Figure id="LinkTarget_2442">

<ImageData src="images/4-Security Pattern Catalog_img_72.jpg"/>
Implementation</Figure>

<P>To implement the Application Firewall, the following tasks need to be done: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_73.jpg"/>
</Figure>

<Lbl>Define </Lbl>

<LBody>users and their roles. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_74.jpg"/>
</Figure>

<Lbl>Define </Lbl>

<LBody>role rights and implement them as policies (Use Case2). </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_75.jpg"/>
</Figure>
Add/Remove policies when needed.Moreover, two architectural configurations are possible: one is where the application firewall takes the position of a reverse proxy (i. e. one firewall for a number of applications), in the other configuration each application is protected by one firewall. With the reverse proxy implementation, the input flow is intercepted on a single point. There is only one PolicyEnforcementPoint, and all the flow should go through it. With the second implementation, several PolicyEnforcementPoints are distributed on the network, close to the different applications that have to be controlled. These enforcement points intercept every request to the application. It is also possible to control access for requests coming from internal networks. </P>
<Figure id="LinkTarget_2443">

<ImageData src="images/4-Security Pattern Catalog_img_76.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2444">

<ImageData src="images/4-Security Pattern Catalog_img_77.jpg"/>
Consequences</Figure>

<P>This pattern presents the following advantages: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_78.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>institution policies to control access are easily defined and administered, as the policies have centralized administration. This makes the whole system less complex, and thus more secure. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_79.jpg"/>
</Figure>

<Lbl>This </Lbl>

<LBody>firewall could be combined with an Intrusion Detection System to facilitate the prevention of some attacks. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_80.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>firewall lends itself to a systematic logging of incoming and outgoing messages. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_81.jpg"/>
</Figure>

<Lbl>As </Lbl>

<LBody>authentication of Clients is performed, users can be held responsible for their actions. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_82.jpg"/>
</Figure>

<Lbl>New </Lbl>

<LBody>applications are easily integrated into the system by adding their specific policies. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_83.jpg"/>
</Figure>

<Lbl>New </Lbl>

<LBody>clients can be accommodated by adding new policies to the policy base of an application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_84.jpg"/>
</Figure>

<Lbl>Because </Lbl>

<LBody>of their separation, the application and the filtering policies can evolve independently.The pattern also has some (possible)liabilities: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_85.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>application could affect the performance of the protected system as it is a bottleneck in the network. This can be improved by considering the firewall a virtual concept and using several machines for implementation. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_86.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>solution is intrusive for existing applications that already implement their own access control. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_87.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>application itself must be built in a secure way or normal access to commands could allow attacks through the requests. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_88.jpg"/>
</Figure>

<Lbl>We </Lbl>

<LBody>still need the operating system and the network infrastructure to be secure. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2445">

<ImageData src="images/4-Security Pattern Catalog_img_89.jpg"/>
Knownuses</Figure>

<P>This pattern is used in several commercial products, such as Cerebit InnerGuard, or Netegrity SiteMinder. This model is also used as an underlying architecture for XML Application Firewalls. There are also some products called Application security gateways that incorporate these functions plus others. </P>

</Part>

<Part>
<H3 id="LinkTarget_2446">Audit Interceptor </H3>
<Figure id="LinkTarget_2447">

<ImageData src="images/4-Security Pattern Catalog_img_90.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: You want to intercept and audit requests and responses to and from the Business tier, in a flexible and modifyable way. </P>
<Figure id="LinkTarget_2448">

<ImageData src="images/4-Security Pattern Catalog_img_91.jpg"/>
Problem</Figure>

<P>Auditing is an essential part of any security design. Most enterprise applications have security-audit requirements. A security audit allows auditors to reconcile actions or events that have taken place in the application with the policies that govern those actions. In this manner, the audit log serves as a record of events for the application. This record can then be used for forensic purposes following a security breach. That record must be checked periodically to ensure that the actions that users have taken are in accordance with the actions allowed by their roles. Deviations must be noted from audit reports, and corrective actions must be taken to ensure those deviations do not happen in the future, either through code fixes or policy changes. The most important part of this procedure is recording the audit trail and making sure that the audit trail helps proper auditing of appropriate events and user actions associated. These events and actions are often not completely understood or defined prior to construction of the application. Therefore, it is essential that an auditing framework is able to easily support additions or changes to the auditing events. </P>
<Figure id="LinkTarget_2449">

<ImageData src="images/4-Security Pattern Catalog_img_92.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_93.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want centralized and declarative auditing of service requests and responses. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_94.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want auditing of services decoupled from the applications themselves. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_95.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want pre-and post-process audit handling of service requests, response errors, and exceptions. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2450">

<ImageData src="images/4-Security Pattern Catalog_img_96.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2451">

<ImageData src="images/4-Security Pattern Catalog_img_97.jpg"/>
Solution</Figure>

<P>Use an Audit Interceptor to centralize auditing functionality and define audit events declaratively, independent of the Business tier services. An Audit Interceptor intercepts Business tier requests and responses. It creates audit events based on the information in a request and response using declarative mechanisms defined externally to the application. By centralizing auditing functionality, the burden of implementing it is removed from the back-end business component developers. Therefore, there is reduced code replication and increased code reuse. A declarative approach to auditing is crucial to maintainability of the application. Seldom are all the auditing requirements correctly defined prior to implementation. Only through iterations of auditing reviews are all of the correct events captured and the extraneous events discarded. Additionally, auditing requirements often change as corporate and industry policies evolve. To keep up with these changes and avoid code maintainability problems, it is necessary to define audit events in a declarative manner that does not require recompilation or redeployment of the application. Since the Audit Interceptor is the centralized point for auditing, any required programmatic change is isolated to one area of the code, which increases code maintainability. </P>
<Figure id="LinkTarget_2452">

<ImageData src="images/4-Security Pattern Catalog_img_98.jpg"/>
Structure</Figure>

<P>The classes of the Audit Interceptor are depicted in Figure 1 . The Client attempts to access the Target. The AuditInterceptor class intercepts the request and uses the AuditEventCatalog to determine if an audit event should be written to the AuditLog. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_99.jpg"/>
</Figure>


<H5>Figure 1: Class layout of the Audit Interceptor. </H5>
<Figure id="LinkTarget_2453">

<ImageData src="images/4-Security Pattern Catalog_img_100.jpg"/>
Dynamics</Figure>

<P>Figure 2 shows the sequence of events for the Audit Interceptor pattern. The Client attempts to access the Target, not knowing that the Audit Interceptor is an intermediary in the request. This approach allows clients to access services in the typical manner without introducing new APIs or interfaces specific to auditing that the client would otherwise not care about. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_101.jpg"/>
</Figure>



<H5>Figure 2: Event sequence for the Audit Interceptor. </H5>

<P>The diagram in Figure 2 does not reflect the implementation of how the request is intercepted, but simply illustrates that the AuditInterceptor receives the request and then forwards it to the Target. </P>
<Figure id="LinkTarget_2454">

<ImageData src="images/4-Security Pattern Catalog_img_102.jpg"/>
Participants</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_103.jpg"/>
</Figure>
Client: A client sends a request to the Target. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_104.jpg"/>
</Figure>
AuditInterceptor: The AuditInterceptor intercepts the request. It encapsulates the details of auditing the request. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_105.jpg"/>
</Figure>
EventCatalog: The EventCatalog maintains a mapping of requests to audit events. It hides the details of managing the life cycle of a catalog from an external source. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_106.jpg"/>
</Figure>
AuditLog: AuditLog is responsible for writing audit events to a destination. This could be a database table, flat file, JMS queue, or any other persistent store. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_107.jpg"/>
</Figure>
Target: The Target is any Business-tier component that would be accessed by a client. Typically, this is a business object or other component that sits behind a SessionFacade, but not the SessionFacade itself, because it would mostly be the entry point that invokes the AuditInterceptor. </P>
<Figure id="LinkTarget_2455">

<ImageData src="images/4-Security Pattern Catalog_img_108.jpg"/>
Collaborations</Figure>

<P>The Audit Interceptor pattern is illustrated in the following steps (see Figure 2 ): </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_109.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>attempts to access Target resource. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_110.jpg"/>
</Figure>

<Lbl>AuditInterceptor </Lbl>

<LBody>intercepts request and uses EventCatalog to determine which, if any, audit event to generate and log. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_111.jpg"/>
</Figure>

<Lbl>AuditInterceptor </Lbl>

<LBody>uses AuditLog to log audit event. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_112.jpg"/>
</Figure>

<Lbl>AuditInterceptor </Lbl>

<LBody>forwards request to Target resource. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_113.jpg"/>
</Figure>

<Lbl>AuditInterceptor </Lbl>

<LBody>uses EventCatalog to determine if the request response or any exceptions raised should generate an audit event. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_114.jpg"/>
</Figure>

<Lbl>AuditInterceptor </Lbl>

<LBody>uses AuditLog to log generated audit event. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2456">

<ImageData src="images/4-Security Pattern Catalog_img_115.jpg"/>
Implementation</Figure>

<P>The Audit Interceptor requires that it be inserted into the message flow to intercept requests. The Intercepting Session Facade strategy designates the Session Facade as the point of interception for the Intercepting Auditor. The Session Facade receives the request and then invokes the Audit Interceptor at the beginning of the request and again at the end of the request. Figure 3 depicts the class diagram for the Secure Service Facade Interceptor Strategy. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_116.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_116.jpg"/>
</Figure>



<H5>Figure 3: Secure Service Facade Interceptor strategy class diagram. </H5>

<P>Using a Secure Service Facade Interceptor strategy, developers can audit at the entry and exit points to the Business tier. The SecureServiceFacade is the appropriate point for audit interception, because its job is to forward to the Application Services and Business Objects. Typically, a request consists of several Business Objects or Application Services, though only one audit event is required for that request. For example, a credit card verification service may consist of one Secure Service Facade that invokes several Business Objects that make up that service, such as an expiration date check, a LUN10check, and a card type check. It is unlikely that each individual check generates an audit event; it is likely that only the verification service itself generates the event. In Figure 3 , the SecureServiceFacade is the entry to the Business tier. It provides the remote interface that the Client uses to access the target component, such as another EJB or a Business Object. Instead of forwarding directly to the target component, the SecureServiceFacade first invokes AuditInterceptor. The AuditInterceptor then consults the EventCatalog to determine whether to generate an audit event and, if so, what audit event to generate. If an audit event is generated, the AuditLog is then used to persist the audit event. Afterward, the SecureServiceFacade then forwards the request as usual to the Target. On the return of invocation of the Target, the SecureServiceFacade again calls the AuditInterceptor. This allows auditing of both start and end events. Exceptions raised from the invocation of the Target also cause the SecureServiceFacade to invoke the AuditInterceptor. More often than not, you want to generate audit events for exceptions. Figure 4 depicts the Secure Service Facade Interceptor strategy sequence diagram. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_117.jpg"/>
</Figure>



<H5>Figure 4: Secure Service Facade Interceptor strategy sequence diagram. </H5>
<Figure id="LinkTarget_2457">

<ImageData src="images/4-Security Pattern Catalog_img_118.jpg"/>
Pitfalls</Figure>

<P>The Audit Interceptor pattern provides developers with a standard way of capturing and auditing events in a decoupled manner. Auditing is an essential part of any security architecture. Audit events enable administrators to capture key events that they can later use to reconstruct who did what and when in the system. This is useful in cases of a system crash or in tracking down an intruder if the system is compromised. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_119.jpg"/>
</Figure>

<Lbl>business </Lbl>

<LBody>tier Auditing. The Audit Interceptor pattern is responsible for providing a mechanism to capture audit events using an Interceptor approach. It is independent of where the audit information gets stored or how it is retrieved. Therefore, it is necessary to understand the general issues relating to auditing. Typically, audit logs (whether flat files or databases)should be stored separately from the applications, preferably on another machine or even off-site. This prevents intruders from covering their tracks by doctoring or erasing the audit logs. Audit logs should be writable but not updateable, depending on the implementation. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_120.jpg"/>
</Figure>

<Lbl>distributed </Lbl>

<LBody>security JMS. The Audit Interceptor pattern is responsible for auditing potentially hundreds or even </LBody>
</LI>
</L>

<P>thousands of events per second in high-throughput systems. In these cases, a scalable solution must be designed to accommodate the high volume of messages. Such a solution would involve dumping the messages onto a persistent JMS queue for asynchronous persistence. In this case, the JMS queue itself must be secured. This can be done by using a JMS product that supports message-level encryption or using some of the other strategies for securing JMS described in Chapter5. Since the queue must be persistent, you will also need to find a product that supports a secure backing store. </P>
<Figure id="LinkTarget_2458">

<ImageData src="images/4-Security Pattern Catalog_img_121.jpg"/>
Consequences</Figure>

<P>Auditing is one of the key requirements for mission-critical applications. Auditing provides a trail of recorded events that can tie back to a Principal. The Audit Interceptor provides a mechanism to audit Business-tier events so that operations staff and security auditors can go back and examine the audit trail and look for all forms of application-layer attacks. The Audit Interceptor itself does not prevent an attack, but it does provide the ability to capture the events of the attack so that they can later be analyzed. Such an analysis can help prevent future attacks. The Audit Interceptor pattern has the following consequences for developers: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_122.jpg"/>
</Figure>
Centralized, declarative auditing of service requests. The Audit Interceptor centralizes the auditing code within the application. This promotes reuse and maintainability. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_123.jpg"/>
</Figure>
Pre-and post-process audit handling of service requests. The Audit Interceptor enables developers to record audit events prior to a method call or after a method call. This is important when considering the business requirements. Auditing is often required prior to the service or method call as a form of recording an&quot;attempt.&quot;In other cases, an audit event is required only after the outcome of the call has been decided. And finally, there are cases where an audit event is needed in the event of an exception with the call. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_124.jpg"/>
</Figure>

<Lbl>Auditing </Lbl>

<LBody>of services decoupled from the services themselves. The Audit Interceptor pattern decouples the business logic code from the auditing code. Business developers should not have to consider auditing requirements or implement code to support auditing. By using the Audit Interceptor, auditing can be achieved without impacting business developers. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_125.jpg"/>
</Figure>

<Lbl>Supports </Lbl>

<LBody>evolving requirements and increases maintainability. The Audit Interceptor supports evolving auditing requirements by decoupling the events that need to be audited from the implementation. An audit catalog can be created that defines audit events declaratively, thus allowing different event types for different circumstances to be added without changing code. This improves the overall maintainability of the code by reducing the number of changes to it. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_126.jpg"/>
</Figure>

<Lbl>Reduces </Lbl>

<LBody>performance. The cost of using an interceptor pattern is that performance is reduced anytime the interceptor is invoked. Every time that Audit Interceptor determines that a request or response does not require generation of an audit event, it unnecessarily decreases performance. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2459">

<ImageData src="images/4-Security Pattern Catalog_img_127.jpg"/>
Knownuses</Figure>

</Part>

<Part>
<H3 id="LinkTarget_2460">Authentication Enforcer </H3>
<Figure id="LinkTarget_2461">

<ImageData src="images/4-Security Pattern Catalog_img_128.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: You need to verify that each service request is from an authenticated entity. </P>
<Figure id="LinkTarget_2462">

<ImageData src="images/4-Security Pattern Catalog_img_129.jpg"/>
Problem</Figure>

<P>You need to verify that each request is from an authenticated entity, and since different classes handle different requests, authentication code is replicated in many places and the authentication mechanism can't easily be changed. Choice of user authentication mechanisms often require changes based on changes in business requirements, application-specific characteristics, and underlying security infrastructures. In a coexisting environment, some applications may use HTTP basic authentication or form-based authentication. In some applications, you may be required to use client certificate-based authentication or custom authentication via JAAS. It is therefore necessary that the authentication mechanisms be properly abstracted and encapsulated from the components that use them. During the authentication process, applications transfer user credentials to verify the identity requesting access to a particular resource. The user credentials and associated data must be kept private and must not be made available to other users or coexisting applications. For instance, when a user sends a credit card number and PIN to authenticate a Web application for accessing his or her banking information, the user wants to ensure that the information sent is kept extremely confidential and does not want anyone else to have access to it during the process. </P>
<Figure id="LinkTarget_2463">

<ImageData src="images/4-Security Pattern Catalog_img_130.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_131.jpg"/>
</Figure>

<Lbl>Access </Lbl>

<LBody>to the application is restricted to valid users, and those users must be properly authenticated. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_132.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>may be multiple entry points into the application, each requiring user authentication. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_133.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>is desirable to centralize authentication code and keep it isolated from the presentation and business logic. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2464">

<ImageData src="images/4-Security Pattern Catalog_img_134.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2465">

<ImageData src="images/4-Security Pattern Catalog_img_135.jpg"/>
Solution</Figure>

<P>Create a centralized authentication enforcement that performs authentication of users and encapsulates the details of the authentication mechanism. </P>

<P>The Authentication Enforcer pattern handles the authentication logic across all of the actions within the Web tier. It assumes responsibility for authentication and verification of user identity and delegates direct interaction with the security provider to a helper class. This applies not only to password-based authentication, but also to client certificate-based authentication and other authentication schemes that provide a user's identity, such as Kerberos. Centralizing authentication and encapsulating the mechanics of the authentication process behind a common interface eases migration to evolving authentication requirements and facilitates reuse. The generic interface is protocol-independent and can be used across tiers. This is especially important in cases where you have clients that access the Business tier or Web Services tier components directly. </P>
<Figure id="LinkTarget_2466">

<ImageData src="images/4-Security Pattern Catalog_img_136.jpg"/>
Structure</Figure>

<P>Figure 1 shows the participants in the Authentication Enforcer pattern. The core Authentication Enforcer consists of three classes: AuthenticationEnforcer, RequestContext, and Subject. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_137.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_137.jpg"/>
</Figure>


<H5>Figure 1: Class layout of the Authentication Enforcer. </H5>
<Figure id="LinkTarget_2467">

<ImageData src="images/4-Security Pattern Catalog_img_138.jpg"/>
Dynamics</Figure>

<P>The dynamics of an authentication enforcer are depicted in Figure 2 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_139.jpg"/>
</Figure>



<H5>Figure 2: Sequence diagram of the Authentication Enforcer. </H5>
<Figure id="LinkTarget_2468">

<ImageData src="images/4-Security Pattern Catalog_img_140.jpg"/>
Participants</Figure>

<P>Figure 1 is a class diagram of the Authentication Enforcer pattern participant classes. Their responsibilities are: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_141.jpg"/>
</Figure>

<Lbl>client </Lbl>

<LBody>A client uses the AuthenticationEnforcer to authenticate a user. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_142.jpg"/>
</Figure>

<Lbl>authenticationenforcer </Lbl>

<LBody>The AuthenticationEnforcer authenticates the user using the credentials passed in the RequestContext. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_143.jpg"/>
</Figure>

<Lbl>requestcontext </Lbl>

<LBody>The RequestContext contains the user's credentials extracted from the protocol-specific request mechanism. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_144.jpg"/>
</Figure>

<Lbl>subject </Lbl>

<LBody>The AuthenticationEnforcer creates a Subject instance that represents the authenticated user. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2469">

<ImageData src="images/4-Security Pattern Catalog_img_145.jpg"/>
Collaborations</Figure>

<P>Figure 2 depicts a typical client authentication using Authentication Enforcer. In this case, the Client is a SecureBaseAction that delegates to the AuthenticationEnforcer, which retrieves the appropriate user credentials from the UserStore. Upon successful authentication, the AuthenticationEnforcer creates a Subject instance for the requesting user and stores it in its cache. </P>

<P>Client (such as a FrontController or ApplicationController)creates RequestContext containing user's credentials. </P>

<P>Client invokes AuthenticationEnforcer's authenticate method, passing the RequestContext. </P>

<P>AuthenticationEnforcer retrieves the user's credentials from the RequestContext and attempts to locate user's Subject instance in its cache based upon the supplied user identifier in the credentials. This identifier may vary depending upon the authentication mechanism and may possibly require some form of mapping, for example, if an LDAP DN retrieved from a client certificate is used as a credential. Unable to locate an entry in the cache, the AuthenticationEnforcer retrieves the user's corresponding credentials in the UserStore. (Typically this will contain a hash of the password.)The AuthenticationEnforcer will verify that the user-supplied credentials match the known credentials for that user in the UserStore and upon successful verification will create a Subject for that user. The AuthenticationEnforcer will then place the Subject in the cache and return it to the SecureBaseAction. </P>
<Figure id="LinkTarget_2470">

<ImageData src="images/4-Security Pattern Catalog_img_146.jpg"/>
Implementation</Figure>

<P>The Authentication Enforcer pattern provides a consistent and structured way to handle authentication and verification of requests across actions within Web-tier components and also supports Model-View-Controller (MVC)architecture without duplicating the code. The three strategies for implementing an Authentication Enforcer pattern include Container Authenticated Strategy, Authentication Provider Strategy (Using Third-party product), and the JAAS Login Module Strategy. </P>

<P>Three implementation strategies are described here: the Container Authenticated Strategy, the Authentication Provider-Based Strategy and the JAAS Login Module Strategy. </P>

<P>The Container Authenticated Strategy is usually considered to be the most straightforward solution, where the container performs the authentication process on behalf of the application. The J2EE specification mandates support for HTTP Basic Authentication, Form Based Authentication, Digest-based Authentication, and Client-certificate Authentication. The J2EE container takes the responsibility for authenticating the user using one of these four methods. These mechanisms don't actually define the method to verify the credentials, but rather they show how to retrieve them from the user. How the container performs the authentication with the supplied credentials depends on the vendor-specific J2EE container implementation. Most J2EE containers handle the authentication process by associating the current HTTPServletRequest object, and its internal session, with the user. By associating a session with the user, the container ensures that the initiated request and all subsequent requests from the same user can be associated with the same session until that user's logout or the authenticated session expires. Once authenticated, the Web application can make use of the following methods provided by the HTTPServletRequest interface. getRemoteUser () </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_147.jpg"/>
</Figure>

<Lbl>Determines </Lbl>

<LBody>the user name with which the client authenticated. isUserInRole (String username) </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_148.jpg"/>
</Figure>

<Lbl>Determines </Lbl>

<LBody>the given user is in a specified security role. getUserPrincipal () </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_149.jpg"/>
</Figure>

<Lbl>Returns </Lbl>

<LBody>a java. security. Principal object.The Authentication Provider-Based Strategy adopts a third-party authentication provider for providing authentication for J2EE applications. Figure 3 illustrates how the Authentication provider is responsible for the authentication of the user, and the Authentication Enforcer extracts the user's Principal and creates a Subject instance with that Principal. </LBody>
</LI>
</L>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_150.jpg"/>
</Figure>



<H5>Figure 3: Sequence diagram for Authentication Provider strategy. </H5>

<P>As you can see in Figure 3 , the authentication provider takes care of the authentication and creation of the Principal. The Authentication Enforcer simply creates the Subject and adds the Principal and the Credential to it. The Subject then holds a collection of permissions associated with all the Principals for that user. The Subject object can then be used in the application to identify, and also to authorize, the user. </P>

<P>The JAAS Login Module Strategy is more involved, because it takes responsibility for authentication from the container and moves it to the application that uses an authentication provider. This provides a pluggable approach and more programmatic control offering more flexibility to applications that require additional authentication mechanisms not supported by the J2EE specification. In essence, JAAS provides a standard programmatic approach to nonstandard authentication mechanisms. It also allows incorporation of multifactor authentication using security providers based on smart cards and biometrics. Figure 4 shows the additional components required by this strategy. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_151.jpg"/>
</Figure>



<H5>Figure 4: Class diagram for JAAS Login Module strategy. </H5>

<P>In this strategy, the AuthenticationEnforcer is implemented as a JAAS client that interacts with JAAS LoginModule (s)for performing authentication. The JAAS LoginModules are configured using a JAAS configuration file, which identifies one or more JAAS LoginModules intended for authentication. Each LoginModule is specified via its fully qualified class name and an authentication Flag value that controls the overall authentication behavior. The flag values (such as Required, Requisite, Sufficient, Optional)defines the overall authentication process. The authentication process proceeds down the specified list of entries in the configuration file based on the flag values. The AuthenticationEnforcer instantiates a LoginContext class that loads the required LoginModule (s), specified in the JAAS configuration file. To initiate authentication the AuthenticationEnforcer invokes the LoginContext. login ()method which in turn calls the login ()method in the LoginModule to perform the login and authentication. The LoginModule invokes a CallbackHandler to perform the user interaction and to prompt the user for obtaining the authentication credentials (such as username/password, smart card and biometric samples). Then the LoginModule authenticates the user by verifying the user authentication credentials. If authentication is successful, the LoginModule populates the Subject with a Principal representing the user. The calling application can retrieve the authenticated Subject by calling the LoginContext's getSubject method. Figure 5 shows the sequence diagram for JAAS Login Module strategy. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_152.jpg"/>
</Figure>



<H5>Figure 5: Sequence diagram for JAAS Login Module strategy. </H5>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_153.jpg"/>
</Figure>

<Lbl>SecureBaseAction </Lbl>

<LBody>creates RequestContext containing user's credentials. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_154.jpg"/>
</Figure>

<Lbl>SecureBaseAction </Lbl>

<LBody>invokes AuthenticationEnforcer's login method, passing in the RequestContext. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_155.jpg"/>
</Figure>

<Lbl>AuthenticationEnforcer </Lbl>

<LBody>creates a CallbackHandler object that contains the username and password extracted from the </LBody>
</LI>
</L>

<P>RequestContext </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_156.jpg"/>
</Figure>
AuthenticationEnforcer creates a LoginContext. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_157.jpg"/>
</Figure>

<Lbl>LoginContext </Lbl>

<LBody>loads the AuthenticationProvider implementation of a LoginModule. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_158.jpg"/>
</Figure>

<Lbl>LoginContext </Lbl>

<LBody>initializes the AuthenticationProvider. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_159.jpg"/>
</Figure>

<Lbl>AuthenticationEnforcer </Lbl>

<LBody>invokes login method on the AuthenticationProvider. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_160.jpg"/>
</Figure>

<Lbl>AuthenticationProvider </Lbl>

<LBody>retrieves the username and password by calling handle on the CallbackHandler. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_161.jpg"/>
</Figure>

<Lbl>AuthenticationProvider </Lbl>

<LBody>uses username and password to authenticate user. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_162.jpg"/>
</Figure>

<Lbl>Upon </Lbl>

<LBody>successful invocation AuthenticationProvider, upon commit, sets the Principal in the Subject and returns the Subject back up the request chain. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2471">

<ImageData src="images/4-Security Pattern Catalog_img_163.jpg"/>
Pitfalls</Figure>

<P>The following security factors and risks apply when using the Authentication Enforcer pattern and its strategies. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_164.jpg"/>
</Figure>
Authentication: Keep all user login code in classes separate from your application classes so you can re-implement them if you port the application or change your user authentication mechanism. The J2EE platform expects that developers will not be writing authentication functionality directly into their applications; the authentication mechanisms must remain independent from the application functionality. However, developers will do so as long as the container-provided mechanisms aren't adequate to suit the needs of an application. If this is done, it would be wise for the developer to isolate the code so that it can be easily removed as containers become more capable. The risk is this: As long as developers are writing authentication code in the application, they are opening up the possibility for bugs that attackers may be able to exploit. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_165.jpg"/>
</Figure>
Standardization: Whenever possible, employ a JAAS Login Module Strategy. It promotes modularity and standardization. Most major application servers support JAAS, and it has become the industry-recognized standard. By using a proprietary approach, you increase the risk of creating security holes that can be exploited to subvert the application. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_166.jpg"/>
</Figure>
Web authentication: Choose the right approach for your security requirements. Basic HTTP authentication is usually highly vulnerable to attacks and provides unacceptable exposure. On the other hand, requiring client certificates for authentication may deter potential users of the system, which is an abstract form of a denial of service attack. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_167.jpg"/>
</Figure>
Confidentiality: During the authentication process, sensitive information is sent over the wire, so confidentiality becomes a critical requirement. Use a Secure Pipe pattern during the user login process to protect the user's credentials. Not securing transmission of the user credentials presents a risk that they may be captured and used by an attacker to masquerade as a legitimate user. </P>
<Figure id="LinkTarget_2472">

<ImageData src="images/4-Security Pattern Catalog_img_168.jpg"/>
Consequences</Figure>

<P>By employing the Authentication Enforcer pattern, developers will be able to benefit from reduced code and consolidated authentication and verification to one class. The Authentication Enforcer pattern encapsulates the authentication process needed across actions into one centralized point that all other components can leverage. By centralizing authentication logic and wrapping it in a generic Authentication Enforcer, authentication mechanism details can be hidden and the application can be protected from changes in the underlying authentication mechanism. This is necessary because organizations change products, vendors, and platforms throughout the lifetime of an enterprise application. </P>

<P>A centralized approach to authentication reduces the number of places that authentication mechanisms are accessed and thereby reduces the chances for security holes due to misuse of those mechanisms. The Authentication Enforcer enables authenticating users by means of various authentication techniques that allow the application to appropriately identify and distinguish user's credentials. A centralized approach also forms the basis for authorization that is discussed in the Authorization Enforcer pattern. The Authentication Enforcer also provides a generic interface that allows it to be used across tiers. This is important if you need to authenticate on more than one tier and do not want to replicate code. Authentication is a key security requirement for almost every application, and the Authentication Enforcer provides a reusable approach for authenticating users. </P>
<Figure id="LinkTarget_2473">

<ImageData src="images/4-Security Pattern Catalog_img_169.jpg"/>
Knownuses</Figure>

</Part>

<Part>
<H3 id="LinkTarget_2474">Authorization Enforcer </H3>
<Figure id="LinkTarget_2475">

<ImageData src="images/4-Security Pattern Catalog_img_170.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Verify that requests for services are properly authorized at the method and link level. </P>
<Figure id="LinkTarget_2476">

<ImageData src="images/4-Security Pattern Catalog_img_171.jpg"/>
Problem</Figure>

<P>Many components need to verify that each request is properly authorized at the method and link level. For applications that cannot take advantage of container-managed security, this custom code has the potential to be replicated. </P>

<P>In large applications, where requests can take multiple paths to access multiple business functionality, each component needs to verify access at a fine-grained level. Just because a user is authenticated does not mean that user should have access to every resource available in the application. At a minimum, an application makes use of two types of users; common end users and administrators who perform administrative tasks. In many applications there are several different types of users and roles, each of them require access based on a set of criterion defined by the business rules and policies specific to a resource. Based on the defined set of criterion, the application must enforce that a user can be able to access only the resources (and in the manner)that user is allowed to do. </P>
<Figure id="LinkTarget_2477">

<ImageData src="images/4-Security Pattern Catalog_img_172.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_173.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to minimize the coupling between the view presentation and the security controller. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_174.jpg"/>
</Figure>

<Lbl>Web </Lbl>

<LBody>applications require access control on a URL basis. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_175.jpg"/>
</Figure>

<Lbl>Authorization </Lbl>

<LBody>logic required to be centralized and should not spread all over the code base in order to reduce risk of misuse or security holes. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_176.jpg"/>
</Figure>

<Lbl>Authorization </Lbl>

<LBody>should be segregated from the authentication logic to allow for evolution of each without impacting the other. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2478">

<ImageData src="images/4-Security Pattern Catalog_img_177.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2479">

<ImageData src="images/4-Security Pattern Catalog_img_178.jpg"/>
Solution</Figure>

<P>Create an Access Controller that will perform authorization checks using standard Java security API classes. </P>

<P>The AuthorizationEnforcer provides a centralized point for programmatically authorizing resources. In addition to centralizing authorization, it also serves to encapsulate the details of the authorization mechanics. With programmatic authorization, access control to resources can be implemented in a multitude of ways. Using an AuthorizationEnforcer provides a generic encapsulation of authorization mechanisms by defining a standardized way for controlling access to Web-based applications. It provides fine-grained access control beyond the simple URL restriction. It provides the ability to restrict links displayed in a page or a header as well as to control the data within a table or list that is displayed, based on user permissions. </P>
<Figure id="LinkTarget_2480">

<ImageData src="images/4-Security Pattern Catalog_img_179.jpg"/>
Structure</Figure>


<H5>Figure 1: Class diagram for the Authorization Enforcer. </H5>

<P>Figure 1 shows the AuthorizationEnforcer class diagram. </P>
<Figure id="LinkTarget_2481">

<ImageData src="images/4-Security Pattern Catalog_img_180.jpg"/>
Dynamics</Figure>

<P>See the implementation section for the dynamics of the different implementation strategies. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_181.jpg"/>
</Figure>



<H5>Figure 2: Sequence diagram for the Authorization Enforcer. </H5>
<Figure id="LinkTarget_2482">

<ImageData src="images/4-Security Pattern Catalog_img_182.jpg"/>
Participants</Figure>



<H5>SecureBaseAction </H5>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_183.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>an action class that gets the Subject from the RequestContext, and checks whether it is authorized for various permissions. RequestContext </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_184.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>a protocol-independent object used to encapsulate protocol-specific request information. AuthorizationEnforcer </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_185.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>an object used to generically enforce authorization in the Web tier. Subject </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_186.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>a class used to store a user's identities and credential information. AuthorizationProvider </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_187.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>a security provider that implements the authorization logic. PermissionCollection </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_188.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>a class used to store permissions, with a method for verifying whether a particular permission is implied in the collection. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2483">

<ImageData src="images/4-Security Pattern Catalog_img_189.jpg"/>
Collaborations</Figure>

<P>Figure 2 shows a sequence diagram depicting the authorization of a user to a permission using the Authorization Enforcer. </P>
<Figure id="LinkTarget_2484">

<ImageData src="images/4-Security Pattern Catalog_img_190.jpg"/>
Implementation</Figure>

<P>There are three commonly adopted strategies that can be employed to provide authorization using Authorization Enforcer pattern. The first is using an authorization provider, using a third-party security solution that provides authentication and authorization services. The second is purely programmatic authorization strategy which makes use of the Java2security API classes and leveraging the Java2Permissions class. The third is a JAAS authorization strategy that makes use of the JAAS principal based policy files and takes advantage of the underlying JAAS programmatic authorization mechanism for populating and checking a user's access privileges. </P>

<P>Not discussed further here is the J2EE container-managed authorization strategy. This strategy, or more correctly, the implementation, was found to be too static and inflexible. In the Authorization Provider strategy, the Authorization Enforcer makes use of a third-party security provider which handles authentication and provides policy based access control to J2EE based application components. In a typical authorization scenario (see Figure 2 ), the client (an Application Controller or extended action class)wants to perform a permission check on a particular user defined in the Subject class retrieved from his or her session. Prior to the illustrated flow, the SecureBaseAction class would have used the AuthenticationEnforcer to authenticate a user and then placed that user's Subject into the session. The Subject object can then be subsequently retrieved from the RequestContext. In the flow above through the following process: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_191.jpg"/>
</Figure>

<Lbl>SecureBaseAction </Lbl>

<LBody>retrieves the Subject from the RequestContext. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_192.jpg"/>
</Figure>

<Lbl>SecureBaseAction </Lbl>

<LBody>invokes AuthorizationEnforcer's authorize method, passing in the Subject. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_193.jpg"/>
</Figure>

<Lbl>AuthorizationEnforcer </Lbl>

<LBody>calls the AuthorizationProvider's authorize method, again passing the Subject. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_194.jpg"/>
</Figure>

<Lbl>AuthorizationProvider </Lbl>

<LBody>retrieves the appropriate permissions for the Principals defined in the Subject class and creates a </LBody>
</LI>
</L>

<P>PermissionsCollection. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_195.jpg"/>
</Figure>
AuthorizationProvider stores the PermissionsCollection in the Subject's public credential set.Sometime later, the SecureBaseAction needs to check that a user has a specific Permission and calls the isAuthorized method of the AuthorizationEnforcer. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_196.jpg"/>
</Figure>

<Lbl>AuthorizationEnforcer </Lbl>

<LBody>retrieves the PermissionsCollection from the Subject's public credential set. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_197.jpg"/>
</Figure>

<Lbl>AuthorizationEnforcer </Lbl>

<LBody>calls the implies method of the PermissionCollection, which passes in the checked Permission and returns the response.The Programmatic Authorization Strategy has the advantage of being flexible enough to easily accommodate new types of permissions for the variety of resources that you want to protect. The programmatic authorization strategy is a purely programmatic approach to authorization. It allows developers to arbitrarily create permissions and store them in the PermissionsCollection class, as demonstrated in Figure 2 . These permissions could be dynamically created at runtime as resources are created. For example, consider an application that allows administrators to upload new forms. Those forms may have access-control requirements that do not correspond to existing roles. You may need to create a resource permission that allows you to specify the name of the form and to then assign that permission to a user or group of users as necessary. It is often necessary to not only deny access to a particular link on a page, but to hide it from the view of those users without appropriate permissions to view its contents. In this case, a custom tag library can be constructed to provide tags for defining permission-based access to links and other resources in the JSPs. The JAAS Authorization Strategy is less flexible than a purely programmatic authorization strategy but provides the benefit of offering a standard JAAS LoginModule-based approach to authorization. It also utilizes a declarative means of mapping permissions to resources. This is a good approach for applications that do not support dynamic resource creation. Developers can map permissions to resources and roles to permissions declaratively at deployment time, thus eliminating programmatic mappings that often result in bugs and cause security vulnerabilities. </LBody>
</LI>
</L>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_198.jpg"/>
</Figure>



<H5>Figure 3: JAAS strategy for the Authorization Enforcer. </H5>

<P>Figure 3 shows the sequence diagram of the Authorization Enforcer implemented using the JAAS Authorization Strategy. The key participants and their roles are as follows: AuthorizationEnforcer. An object used to generically enforce authorization in the Web tier. Subject </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_199.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>a Java2security class used to store a user's identities and security-related information. PrivilegedAction </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_200.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>a computation to be performed with privileges enabled. Policy </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_201.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>a JAAS Principal-based policy file, which defines the Principals with designated permissions to execute the specific application code or other privileges associated with the application or resources. JAAS Module </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_202.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>responsible for enforcing access control by enforcing the JAAS Policy and verifying that the authenticated Subject has been granted the appropriate set of permissions before invoking the PrivilegedAction. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2485">

<ImageData src="images/4-Security Pattern Catalog_img_203.jpg"/>
Pitfalls</Figure>

<P>Authorization. Protect resources on a case by case basis. Fine-grained authorization allows you to properly protect the application without imposing a one-size-fits-all approach that could expose unnecessary security vulnerabilities. A common security vulnerability arises from access-control models that are too coarse-grained. When the model is too coarse-grained, you inevitably have users that do not fit nicely into the role-permission mappings defined. Often, administrators are forced to give these users elevated access due to business requirements. This leads to increased exposure. For instance, you have two groups of users that you break into two roles (staff and admin). The staff role only has the ability to read form data. The admin </P>

<P>gpy () yy role has the ability to create, read, update, and delete (CRUD)form data. You find that you have a few users that need to update the form data, though they should not be able to create or delete it. You are now forced to put them into the admin role, giving them these additional permissions because your model is too coarse-grained. </P>
<Figure id="LinkTarget_2486">

<ImageData src="images/4-Security Pattern Catalog_img_204.jpg"/>
Consequences</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_205.jpg"/>
</Figure>

<Lbl>Centralizes </Lbl>

<LBody>control. The Authorization Enforcer allows developers to encapsulate the complex intricacies of implementing access control. It provides a focus point for providing access control checks, thus eliminating the chance for repetitive code. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_206.jpg"/>
</Figure>

<Lbl>Improves </Lbl>

<LBody>reusability. Authorization Enforcer allows greater reuse through encapsulation of disparate access-control mechanisms through common interfaces. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_207.jpg"/>
</Figure>

<Lbl>Promotes </Lbl>

<LBody>separation of responsibility. Partitions authentication and access-control responsibilities, insulating developers from changes in implementations. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2487">

<ImageData src="images/4-Security Pattern Catalog_img_208.jpg"/>
Knownuses</Figure>

</Part>

<Part>
<H3 id="LinkTarget_2488">Checkpointed System </H3>
<Figure id="LinkTarget_2489">

<ImageData src="images/4-Security Pattern Catalog_img_209.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Structure a system so that its state can be recovered and restored to a known valid state in case a component fails. Aliases: Snapshot, Undo </P>
<Figure id="LinkTarget_2490">

<ImageData src="images/4-Security Pattern Catalog_img_210.jpg"/>
Problem</Figure>

<P>A component failure can result in loss or corruption of state information maintained by the failed component. Systems which rely on retained state for correct operation must be able to recover from loss or corruption of state information. </P>
<Figure id="LinkTarget_2491">

<ImageData src="images/4-Security Pattern Catalog_img_211.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_212.jpg"/>
</Figure>

<Lbl>Operations </Lbl>

<LBody>on a component update its state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_213.jpg"/>
</Figure>

<Lbl>Correctness </Lbl>

<LBody>of the system's operation depends on correctness of its components'state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_214.jpg"/>
</Figure>

<Lbl>Component </Lbl>

<LBody>failures could cause loss or corruption of a component's state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_215.jpg"/>
</Figure>

<Lbl>Transactions </Lbl>

<LBody>which occurred between the time a state snapshot is taken and the time the system is rolled back to the snapshot state are irrelevant or inconsequential, or can be reapplied. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2492">

<ImageData src="images/4-Security Pattern Catalog_img_216.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2493">

<ImageData src="images/4-Security Pattern Catalog_img_217.jpg"/>
Solution</Figure>

<P>The Checkpointed System pattern (see Figure 1 )consists of a Recovery Proxy (Proxy:)and a Recoverable Component which periodically saves a recoverable version of the component's state as a Memento. The Memento can be used to restore the component's state when required. </P>
<Figure id="LinkTarget_2494">

<ImageData src="images/4-Security Pattern Catalog_img_218.jpg"/>
Structure</Figure>


<H5>Figure 1: Class layout of the Checkpointed System. </H5>

<P>See Figure 1 . </P>
<Figure id="LinkTarget_2495">

<ImageData src="images/4-Security Pattern Catalog_img_219.jpg"/>
Dynamics</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_220.jpg"/>
</Figure>



<H5>Figure 2: Event sequence for the Checkpointed System. </H5>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2496">

<ImageData src="images/4-Security Pattern Catalog_img_221.jpg"/>
Participants</Figure>

<P>The relations between the participants are shown in Figure 1 . The participants and their responsabilities are: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_222.jpg"/>
</Figure>

<Lbl>Stateful </Lbl>

<LBody>Component Abstract class. Defines component operations. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_223.jpg"/>
</Figure>

<Lbl>Recovery </Lbl>

<LBody>Proxy Proxyfor Recoverable Component. A Stateful Component. Caretaker for Recoverable Component's Mementos. Initiates creation of Mementos when Recoverable Component state changes. Detects failures and initiates state recovery by instructing Recoverable Component to restore state from Memento. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_224.jpg"/>
</Figure>

<Lbl>Recoverable </Lbl>

<LBody>Component A Stateful Component. Implements component operations. Periodically saves component state to Memento to support later recovery operations. Restores component state when required. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_225.jpg"/>
</Figure>

<Lbl>MementoThe </Lbl>

<LBody>Recoverable Component's externalized state. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2497">

<ImageData src="images/4-Security Pattern Catalog_img_226.jpg"/>
Collaborations</Figure>

<P>The interactions between the participants are shown in Figure 2 . </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_227.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Recovery Proxy responds to requests to perform operations. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_228.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Recovery Proxy periodically instructs the Recoverable Component to create a new Memento to save the Recoverable Component's current state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_229.jpg"/>
</Figure>

<Lbl>In </Lbl>

<LBody>the event of a failure, the Recovery Proxy instructs the Recoverable Component to restore its state using the information stored in the Memento, and then instructs the Recoverable Component to execute requested operations. Note that any state resulting from operations performed after the most recent state save will be lost. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2498">

<ImageData src="images/4-Security Pattern Catalog_img_230.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2499">

<ImageData src="images/4-Security Pattern Catalog_img_231.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2500">

<ImageData src="images/4-Security Pattern Catalog_img_232.jpg"/>
Consequences</Figure>

<P>Use of the Checkpointed System pattern: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_233.jpg"/>
</Figure>

<Lbl>Improves </Lbl>

<LBody>component fault tolerance. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_234.jpg"/>
</Figure>

<Lbl>Improves </Lbl>

<LBody>component error recovery. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_235.jpg"/>
</Figure>

<Lbl>Increases </Lbl>

<LBody>system resource consumption (extra resources are required for the Memento). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_236.jpg"/>
</Figure>

<Lbl>Increases </Lbl>

<LBody>system complexity; creating a Memento may require the creation of work queues or other transaction management constructs to ensure consistency of the state data stored in the Memento. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_237.jpg"/>
</Figure>

<Lbl>May </Lbl>

<LBody>increase system latency or decrease throughput if creation of the Memento requires processing to pause or stop. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_238.jpg"/>
</Figure>

<Lbl>Allows </Lbl>

<LBody>loss of a small number of transactions and their associated state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_239.jpg"/>
</Figure>

<Lbl>Increases </Lbl>

<LBody>system cost per unit of functionality. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2501">

<ImageData src="images/4-Security Pattern Catalog_img_240.jpg"/>
Knownuses</Figure>

<P>The periodic save feature of many applications (for example, Microsoft Word)is an instance of the Checkpointed System pattern. </P>

</Part>

<Part>
<H3 id="LinkTarget_2502">Comparator Checked Fault Tolerant System </H3>
<Figure id="LinkTarget_2503">

<ImageData src="images/4-Security Pattern Catalog_img_241.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Structure a system so that an independent failure of one component will be detected quickly and so that an independent single-component failure will not cause a system failure. </P>

<P>Aliases: Tandem System </P>
<Figure id="LinkTarget_2504">

<ImageData src="images/4-Security Pattern Catalog_img_242.jpg"/>
Problem</Figure>

<P>It is sometimes very important to detect component faults quickly, or to detect component faults at a specific point during processing, to prevent component faults from causing system failures. Inspection of the output of a component may not directly reveal whether a fault has occurred or not. Some mechanism is required to support detection of faults which have not yet caused a failure. </P>

<P>Use Comparator-Checked Fault-Tolerant System when: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_243.jpg"/>
</Figure>

<Lbl>Faults </Lbl>

<LBody>in one component are not expected to be strongly correlated with similar or identical faults in another component (this will usually be the case when faults are caused by factors external to components; it will often not be the case when faults are caused by component design or implementation errors). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_244.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>is feasible to compare the outputs or internal states of components. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_245.jpg"/>
</Figure>

<Lbl>Component </Lbl>

<LBody>faults must be detected soon after they occur, or at specific points during processing, but in any case before they lead to a system failure. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_246.jpg"/>
</Figure>

<Lbl>Duplicating </Lbl>

<LBody>system components is economical. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2505">

<ImageData src="images/4-Security Pattern Catalog_img_247.jpg"/>
Forces</Figure>

<P>The Comparator-Checked Fault-Tolerant System must resolve the following forces: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_248.jpg"/>
</Figure>

<Lbl>Each </Lbl>

<LBody>component may fail at random times, without prior warning. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_249.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>is possible that erroneous output is produced that is still within an acceptable output range for the component. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_250.jpg"/>
</Figure>

<Lbl>For </Lbl>

<LBody>the system to remain functional, faults need to be detected with little or no delays. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2506">

<ImageData src="images/4-Security Pattern Catalog_img_251.jpg"/>
ExampleSolution</Figure>

<P>Structure a system so that an even number of recoverable components execute tasks concurrently. Let the components produce memento's as a means to compare their results. If a discrepancy between the results of a pair of components is detected, take corrective action. </P>
<Figure id="LinkTarget_2507">

<ImageData src="images/4-Security Pattern Catalog_img_252.jpg"/>
Structure</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_253.jpg"/>
</Figure>


<H5>Figure 1: Comparator checked fault tolerant system class diagram. </H5>

<P>A Comparator-Checked Fault-Tolerant System consists of an even number of Recoverable Components (often four or more), organized as sets of pairs, together with a Comparator for each pair. Each comparator examines Mementos produced by each member of its pair to determine whether they match. If the Mementos do not match, the Comparator concludes that a fault has occurred in one of the components and takes corrective action. An overview is given in Figure 1 . </P>
<Figure id="LinkTarget_2508">

<ImageData src="images/4-Security Pattern Catalog_img_254.jpg"/>
Dynamics</Figure>



<H5>Figure 2: Comparator checked fault tolerant system sequence diagram. </H5>

<P>The dynamics of a comparator checked fault tolerant system are described in Figure 2 . </P>
<Figure id="LinkTarget_2509">

<ImageData src="images/4-Security Pattern Catalog_img_255.jpg"/>
Participants</Figure>



<H5>Recoverable Components </H5>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_256.jpg"/>
</Figure>

<Lbl>perform </Lbl>

<LBody>operations on behalf of clients. Each Recoverable Component is a member of a pair. Comparator </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_257.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>afor a pair of Recoverable Components. The Caretaker for Recoverable Components'. Checks Mementos created by the members of its pair of Recoverable Components. If the Mementos do not match, the Comparator concludes that a fault has occurred in one of its Recoverable Components and initiates corrective action. In systems consisting of two or more pairs, the usual corrective action is to take the faulted pair offline. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_258.jpg"/>
</Figure>

<Lbl>Comparator </Lbl>

<LBody>responds to requests for operations. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_259.jpg"/>
</Figure>

<Lbl>Comparator </Lbl>

<LBody>routes each request to both Recoverable Components, each of which creates a Memento externalizing its state upon completion of the operation. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_260.jpg"/>
</Figure>

<Lbl>Comparator </Lbl>

<LBody>retrieves state from both Mementos and compares them. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_261.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>the states of the Mementos match, Comparator returns the operationÂ¿s result to the client; otherwise (if the states do not match), Comparator initiates recovery actions. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2510">

<ImageData src="images/4-Security Pattern Catalog_img_262.jpg"/>
Collaborations</Figure>
<Figure id="LinkTarget_2511">

<ImageData src="images/4-Security Pattern Catalog_img_263.jpg"/>
Implementation</Figure>

<P>The Comparator's error checking mechanism works by comparing the two Mementos. If the state comparison shows any difference, the pair is taken offline. In some implementations, the ``failed''pair continues processing inputs but presents no outputs. Continued processing allows the next collaboration. </P>

<P>The Comparator of a failed pair may collaborate with the error checking mechanisms of the surviving pair's Comparator to identify which Recoverable Component of the failed pair has actually failed. This function can be used to guide manual or automatic intervention, correction, and restart. </P>

<P>A Comparator may use its Mementos to maintain a consistent externalized image of the ``correct''state. This can be used to enable the restart of a failed element or its replacement. </P>
<Figure id="LinkTarget_2512">

<ImageData src="images/4-Security Pattern Catalog_img_264.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2513">

<ImageData src="images/4-Security Pattern Catalog_img_265.jpg"/>
Consequences</Figure>

<P>Use of the Comparator-Checked Fault-Tolerant System pattern: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_266.jpg"/>
</Figure>

<Lbl>Improves </Lbl>

<LBody>system tolerance of component faults. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_267.jpg"/>
</Figure>

<Lbl>Substantially </Lbl>

<LBody>increases component costs. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_268.jpg"/>
</Figure>

<Lbl>Increases </Lbl>

<LBody>system complexity. Creating the Memento may require the creation of work queues or other transaction management constructs to ensure consistency of the state data stored in the Memento. Creating the Comparator and its recovery function will also add complexity. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_269.jpg"/>
</Figure>

<Lbl>May </Lbl>

<LBody>impair system latency or throughput if creation of a checkpoint requires processing to pause or stop. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2514">

<ImageData src="images/4-Security Pattern Catalog_img_270.jpg"/>
Knownuses</Figure>

<P>The Tandem Nonstop operating system is an example of the Comparator-Checked Fault-Tolerant System pattern. </P>

</Part>

<Part>
<H3 id="LinkTarget_2515">Container Managed Security </H3>
<Figure id="LinkTarget_2516">

<ImageData src="images/4-Security Pattern Catalog_img_271.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: You need a simple, standard way to enforce authentication and authorization in your J2EE applications and don't want to reinvent the wheel or write home-grown security code. Using a Container Managed Security pattern, the container performs user authentication and authorization without requiring the developer to hard-wire security policies in the application code. </P>
<Figure id="LinkTarget_2517">

<ImageData src="images/4-Security Pattern Catalog_img_272.jpg"/>
Problem</Figure>

<P>Using a Container Managed Security pattern, the container performs user authentication and authorization without requiring the developer to hard-wire security policies in the application code. It employs declarative security that requires the developer to only define roles at a desired level of granularity through deployment descriptors of the J2EE resources. The administrator or deployer then uses the container-provided tool to map the roles to the users and groups available in the realm at the time of deployment. A realm is a database of users and their profiles that includes at least usernames and passwords, but can also include role, group, and other pertinent attributes. The actual enforcement of authentication and authorization at runtime is handled by the container in which the application is deployed and is driven by the deployment descriptors. Most containers provide authentication mechanisms by configuring user realms for LDAP, RDBMS, UNIX, and Windows. </P>

<P>Declarative security can be supplemented by programmatic security in the application code that uses J2EE APIs to determine user identity and role membership and thereby enforce enhanced security. In cases where an application chooses not to use a J2EE container, configurable implementation of security similar to Container Managed Security can still be designed by using JAAS-based authentication providers and JAAS APIs for programmatic security. </P>
<Figure id="LinkTarget_2518">

<ImageData src="images/4-Security Pattern Catalog_img_273.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_274.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>need to authenticate users and provide access control to business components. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_275.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want a straightforward, declarative security model based on static mappings. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_276.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to prevent developers from bypassing security requirements and inadvertently exposing business functionality. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2519">

<ImageData src="images/4-Security Pattern Catalog_img_277.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2520">

<ImageData src="images/4-Security Pattern Catalog_img_278.jpg"/>
Solution</Figure>

<P>Use Container Managed Security to define application-level roles at development time and perform user-role mappings at deployment time or thereafter. </P>

<P>In a J2EE application, both ejb-jar. xml and web. xml deployment descriptors can define container-managed security. The J2EE security elements in the deployment descriptor declare only the logical roles as conceived by the developer. The application deployer maps these application domain logical roles to the deployment environment. Container Managed Security at the Web tier uses delayed authentication, prompting the user for login only when a protected resource is accessed for the first time. On this tier, it can offer security for the whole application or specific parts of the application that are identified and differentiated by URL patterns. At the Enterprise Java Beans tier, Container Managed Security can offer method-level, fine-grained security or object-level, coarse-grained security. </P>
<Figure id="LinkTarget_2521">

<ImageData src="images/4-Security Pattern Catalog_img_279.jpg"/>
Structure</Figure>

<P>Figure 1: Structure of container managed security enforcement. </P>

<P>Figure 1 depicts a generic class diagram for a Container Managed Security implementation. Note that the class diagram can only be applicable to the container's implementation of Container Managed Security. The J2EE application developer would not use such a class structure, because it is already implemented and offered by the container for use by the developer. </P>
<Figure id="LinkTarget_2522">

<ImageData src="images/4-Security Pattern Catalog_img_280.jpg"/>
Dynamics</Figure>


<H5>Figure 2: Container managed security dynamics. </H5>

<P>Figure 2 depicts a sequence of operations involved in fulfilling a client request on a protected resource on the Web tier that uses an EJB component on the Business tier. Both tiers leverage Container Managed Security for authentication and access control. </P>
<Figure id="LinkTarget_2523">

<ImageData src="images/4-Security Pattern Catalog_img_281.jpg"/>
Participants</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_282.jpg"/>
</Figure>
Client: A client sends a request to access a protected resource to perform a specific task. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_283.jpg"/>
</Figure>
Container: The container intercepts the request to acquire authentication credentials from the client and thereafter authenticates the client using the realm configured in the J2EE container for the application. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_284.jpg"/>
</Figure>

<Lbl>Protected </Lbl>

<LBody>Resource: The security policy of the protected resource is declared via the Deployment Descriptor. Upon authentication, the container uses the Deployment Descriptor information to verify whether the client is authorized to access the protected resource using the method, such as GET and POST, specified in the client request. If authorized, the request is forwarded to the protected resource for fulfillment. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_285.jpg"/>
</Figure>

<Lbl>Enterprise </Lbl>

<LBody>Java Bean: The protected resource in turn could be using a Business Tier Enterprise Java Bean that declares its own security policy via the ejb. jar deployment descriptor. The security context of the client is propagated to the EJB container while making the EBJ method invocation. The EJB container intercepts the requests to validate against the security policy much like it did in the Web tier. If authorized, the EJB method is executed, fulfilling the client request. The results of execution of the request are then returned to the client. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_286.jpg"/>
</Figure>

<Lbl>When </Lbl>

<LBody>a Client makes an unauthenticated request for a Protected Resource, this Protected Resource will first check the authentication of the Client with the Container. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_287.jpg"/>
</Figure>

<Lbl>At </Lbl>

<LBody>this point, the Container will take over the authentication process and forward a request to authenticate to the Client. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_288.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>client presents appropriate authentication credentials to the Container, which then performs the authentication. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_289.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Container forwards the request to the Protected Resource, together with the role of the authenticated Client. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_290.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Protected Resource is now able to invoke the appropriate method on the EJB, together with the role of the Client. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_291.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>EJB checks the authorization with the Container, which replies that the action is indeed authorized. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_292.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>EJB now executes the invoked method, and returns the results. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2524">

<ImageData src="images/4-Security Pattern Catalog_img_293.jpg"/>
Collaborations</Figure>
<Figure id="LinkTarget_2525">

<ImageData src="images/4-Security Pattern Catalog_img_294.jpg"/>
Implementation</Figure>

<P>Container Managed Security can be used in the Web and Business tiers of a J2EE application, depending on whether a Web container, an EJB container, or both are used in an application. It can also be supplemented by Bean Managed/Programmatic Security for fine-grained implementations. The various scenarios are described in this section. In the Web Tier Container Managed Security strategy, security restraints are specified in the web. xml of the client/user-facing Web application (that is, the Web tier of the J2EE application). If this is the only security strategy used in the application, an assumption is made that the back-end Business tier is not directly exposed to the client for direct integration. The web. xml declares the authentication method via the&lt;auth-method&gt;node of the web. xml to mandate either BASIC, DIGEST, FORM, or CLIENT-CERT authentication modes whenever authentication is required. It also declares authorization for protected resources that are identified and distinguished by their URL patterns. The actual enforcement or security is performed by the J2EE-compliant Web container in this strategy. </P>

<P>In the Service Tier Container Managed Security strategy, the developer configures the EJB's deployment descriptors to incorporate security into the service backbone of the application. A security role in EJB's ejb-jar. xml is defined through a&lt;security-role-ref&gt;element. These bean-specific logical roles can be associated to a security role defined with a different name in the&lt;role-name&gt;elements of the application deployment descriptor via a&lt;role-link&gt;element. The&lt;assembly-descriptor&gt;section of ejb-jar. xml, which is the application-level deployment descriptor, lists all the logical application-level roles via&lt;rolename&gt;elements, and these roles are mapped to the actual principals in the realm at the time of deployment. </P>

<P>Declarative Security for EJBs can either be at the bean level or at a more granular method level. Home and Remote interface methods can declare a&lt;method-permission&gt;element that includes one or more&lt;role-name&gt;elements that are allowed to access one or more EJB methods as identified by the&lt;method&gt;elements. One can also declare&lt;exclude-list&gt;elements to disable access to specific methods. To specify an explicit identity that an EJB should use when it invokes methods on other EJBs, the developer can use&lt;use-caller-identity&gt;or&lt;run-as&gt;/&lt;role-name&gt;elements under the&lt;security-identity&gt;element of the deployment descriptor. For finer granularity or to meet requirements unfulfilled by Container Managed Security, a developer could choose to use programmatic security in bean code or Web tier code in conjunction with Container Managed Security. For example, in the EJB code, the caller principal as a java. security. Principal instance can be obtained from the EJBContext. getCallerPrincipal ()method. The EJBContext. isCallerInRole (String)method can determine if a caller is in a role that is declared with a&lt;securityrole-ref&gt;element. Similarly, on the Web tier, HttpServletRequest. getUserPrincipal ()returns a java. security. Principal object containing the name of the current authenticated user, and HttpServletRequest. isUserInRole (String)returns a Boolean indicating whether the authenticated user is included in the specified logical role. These APIs are very limited in scope and are confined to determining a user's identity and role membership. This approach is useful where instance-level security is required, such as permitting only the admin role to perform account transfers exceeding a certain amount limit. </P>
<Figure id="LinkTarget_2526">

<ImageData src="images/4-Security Pattern Catalog_img_295.jpg"/>
Pitfalls</Figure>

<P>The extent of security offered by this pattern is limited to the security mechanisms offered by the container where the application code is deployed. It is also constrained by the limited subset of security aspects covered in the J2EE specification. As a result, the pattern elicits several risks: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_296.jpg"/>
</Figure>

<Lbl>Limitations </Lbl>

<LBody>to fine-grained security. Use of Container Managed Security limits the ability of the application to incorporate fine-grained security such as that based on an object's run-time attribute values, time of day, and physical location of the client. These deficiencies could be overcome by programmatic security inside business components, but the security context information accessible to the component code is limited to principal information and the role association. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_297.jpg"/>
</Figure>

<Lbl>Requires </Lbl>

<LBody>preconceived granularity of roles. Container Managed Security necessitates a preestablished notion of roles at the granularity level required by the application over the foreseeable future. This is because roles need to be defined in the deployment descriptor for each Web tier resource, ejb-tier business objects, or business methods before the application is packaged and deployed. Retrofitting additional roles after deployment would require repackaging the application with new deployment descriptors. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_298.jpg"/>
</Figure>

<Lbl>Too </Lbl>

<LBody>limiting. Container Managed Security of the J2EE specification omits many aspects of integration between the container and the existing security infrastructure and limits itself to authentication and role-based access control. This may be too limiting for certain requirements, making programmatic security inevitable.Is Container Managed Security comprehensive at the Web tier?If the granularity of security enforcement is not matched by the granularity offered by the resource URL identifiers used by Container Managed Security to distinguish and differentiate resources, this pattern may not fulfill the requirements. This is particularly true in applications that use a single controller to front multiple resources. In such cases, the request URI would be the same for all resources, and individual resources would be identified only by way of some identifier in the query string (such as/myapp/controller?page=resource1). Container Manager Security by URL patterns is not applicable in such cases unless the container supports extensive use of regular expressions. Resource-level security in such scenarios requires additional work in the application. </LBody>
</LI>
</L>

<P>Is Container Managed Security required at the service tier?If all the back-end business services are inevitably fronted by a security gateway such as Secure Service Proxy or Secure Service Fa Ã§ ade, having additional security enforcement via Container Managed Security on EJBs may not add much value and may incur unnecessary performance overhead. The choice must be carefully made in such cases. </P>
<Figure id="LinkTarget_2527">

<ImageData src="images/4-Security Pattern Catalog_img_299.jpg"/>
Consequences</Figure>

<P>Container Managed Security offers flexible policy management at no additional cost to the organization. While it allows the </P>

<P>developer to incorporate security in the application by way of simply defining roles in the deployment descriptor without writing any implementation code, it also supports programmatic security for fine-grained access control. The pattern offers the following other benefits to the developer: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_300.jpg"/>
</Figure>
Straightforward, declarative security model based on static mappings. The Container Managed Security pattern provides an easy-to-use and easy-to-understand security model based on declarative user-to-role and role-to-resource mappings. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_301.jpg"/>
</Figure>

<Lbl>Developers </Lbl>

<LBody>are prevented from bypassing security requirements and inadvertently exposing business functionality. Developers often advertently or inadvertently bypass security mechanisms within the code. Using Container Managed Security prevents this and ensures that EJB methods are adequately protected and properly restricted at deployment time by the application deployer. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_302.jpg"/>
</Figure>

<Lbl>Less </Lbl>

<LBody>prone to security holes. Since security is implemented by a time-tested container, programming errors are less likely to lead to security holes. However, the security functionality offered by the container could be too limited and inflexible to modify. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_303.jpg"/>
</Figure>

<Lbl>Separation </Lbl>

<LBody>of security code from business objects. Since the container implements the security infrastructure, the application code is free of security logic. However, developers often end up starting with Container Managed Security and then using programmatic security in conjunction with it, which leads to mangled code with a mixture of declarative and programmatic security that is difficult to manage. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2528">

<ImageData src="images/4-Security Pattern Catalog_img_304.jpg"/>
Knownuses</Figure>

<P>Probably the best known use is the declarative container managed security offered by the J2EE platform. </P>

</Part>

<Part>
<H3 id="LinkTarget_2529">Controlled Object Factory </H3>
<Figure id="LinkTarget_2530">

<ImageData src="images/4-Security Pattern Catalog_img_305.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: This pattern addresses how to specify the rights of processes with respect to a new object. When a process creates a new object through a factory, the request includes the features of the new object. These features include a list of rights to access the object. </P>
<Figure id="LinkTarget_2531">

<ImageData src="images/4-Security Pattern Catalog_img_306.jpg"/>
Problem</Figure>

<P>A computing system that needs to control access to its created objects because of their different degrees of sensitivity. Rights for these objects are defined by authorization rules or policies that are enforced when a process attempts to access an object. </P>

<P>In a computing environment, executing applications need to create objects for their work. Some objects are created at program initialization, while others are created dynamically during execution. The access rights of processes with respect to objects must be defined when these objects are created, or there may be opportunities for the processes to misuse them. Applications also need resources such as I/O devices and others that may come from resource pools: when these resources are allocated, the application must be given rights to them. </P>
<Figure id="LinkTarget_2532">

<ImageData src="images/4-Security Pattern Catalog_img_307.jpg"/>
Forces</Figure>

<P>The solution to this problem must resolve the following forces: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_308.jpg"/>
</Figure>

<Lbl>Applications </Lbl>

<LBody>create objects of many different types, but we need to handle them uniformly with respect to their access rights, otherwise it would be difficult to apply standard security policies. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_309.jpg"/>
</Figure>

<Lbl>We </Lbl>

<LBody>need to allow objects in a resource pool to be allocated and have their rights set dynamically: not doing so would be too rigid. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_310.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>may be specific policies that define who can access a new object, and we need to apply these when creating the rights for an object. This is a basic aspect of security. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2533">

<ImageData src="images/4-Security Pattern Catalog_img_311.jpg"/>
Example</Figure>

<P>In many operating systems the creator of an object gets all possible rights to the object. Other operating systems apply predefined sets of rights: for example, in Unix all the members of a file ownerÂ¿s group may receive equal rights for a new file. These approaches may result in unnecessary rights being given to some users, violating the principle of least privileges. </P>
<Figure id="LinkTarget_2534">

<ImageData src="images/4-Security Pattern Catalog_img_312.jpg"/>
Solution</Figure>

<P>Whenever a new object is created, define a list of subjects that can access it, and in what way. </P>
<Figure id="LinkTarget_2535">

<ImageData src="images/4-Security Pattern Catalog_img_313.jpg"/>
Structure</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_314.jpg"/>
</Figure>


<H5>Figure 1: The structure of a Controlled Object Factory. </H5>

<P>The structure of ais shown in Figure 1 . </P>
<Figure id="LinkTarget_2536">

<ImageData src="images/4-Security Pattern Catalog_img_315.jpg"/>
Dynamics</Figure>



<H5>Figure 2: Controlled object factory dynamics. </H5>

<P>The dynamics of aare shown in Figure 2 . A process creating an object through adefines the rights for other subjects with respect to this object. </P>
<Figure id="LinkTarget_2537">

<ImageData src="images/4-Security Pattern Catalog_img_316.jpg"/>
Participants</Figure>

<P>When a Process creates a new object through a Factory, the CreationRequest includes the features of the new object. Among these features is a list of rights that define the access rights for a Subject to access the created Object. This implies that we need to intercept every access request: this is done by. </P>
<Figure id="LinkTarget_2538">

<ImageData src="images/4-Security Pattern Catalog_img_317.jpg"/>
Collaborations</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_318.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>Process invokes the Factory to create a new Object with the provided Access Rights . </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_319.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Factory then creates a new Object . </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_320.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Factory also creates a new Access\_Right object, to hold the access rights. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_321.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Access\_Right object then attaches itself to the new Object . </LBody>
</LI>
</L>
<Figure id="LinkTarget_2539">

<ImageData src="images/4-Security Pattern Catalog_img_322.jpg"/>
Implementation</Figure>

<P>Each object may have an associated access control list (ACL). This will list the rights each user has for the associated object. Each entry specifies the rights that any other object within the system can have. In general, each right can be an ``allow''or a ``deny''. These are also known as Access Control Entries (ACE)in the Windows environment. The set of access rules is also known as the Access Control List (ACL)in Windows and most operating systems. Capabilities are an alternative to an ACL. A capability corresponds to a row in an access matrix. This is in contrast to the ACL, which is associated with the object. The capability indicates to the secure object that the subject does indeed have the right to perform the operation. The capability may carry some authentication features in order to show that the object can trust the provided capability information. A global table can contain rows that represent capabilities for each authenticated user, or the capability may be implemented as a lists for each user which indicates which object each user has access to. </P>
<Figure id="LinkTarget_2540">

<ImageData src="images/4-Security Pattern Catalog_img_323.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2541">

<ImageData src="images/4-Security Pattern Catalog_img_324.jpg"/>
Consequences</Figure>

<P>The following benefits may be expected from applying this pattern: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_325.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>will be no objects that have default access rights because somebody forgot to define rights to access them </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_326.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>is possible to define access rights to an object based on its sensitivity </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_327.jpg"/>
</Figure>

<Lbl>Objects </Lbl>

<LBody>allocated from a resource pool can have rights attached to them dynamically </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_328.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>operating system can apply ownership policies: for example, the creator of an object may receive all possible rights to the objects it creates. The following potential liabilities may arise from applying this pattern: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_329.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>is a process creation overhead </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_330.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>may not be clear what initial rights to define </LBody>
</LI>
</L>
<Figure id="LinkTarget_2542">

<ImageData src="images/4-Security Pattern Catalog_img_331.jpg"/>
Knownuses</Figure>

<P>The Win32API allows a process to create objects with various Create system calls using a structure that contains access control information (DACL)passed as a reference. When the object is created, the access control information is associated with the object by the kernel. The kernel returns a handle to the caller to be used for access to the object. </P>

</Part>

<Part>
<H3 id="LinkTarget_2543">Controlled Object Monitor </H3>
<Figure id="LinkTarget_2544">

<ImageData src="images/4-Security Pattern Catalog_img_332.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: This pattern addresses how to control access by a process to an object. Use a reference monitor to intercept access requests from processes. The reference monitor checks whether the process has the requested type of access to the object. </P>
<Figure id="LinkTarget_2545">

<ImageData src="images/4-Security Pattern Catalog_img_333.jpg"/>
Problem</Figure>

<P>The context of the problem lies in an operating system that consists of many users, objects that may contain sensitive data, and where we need to have controlled access to resources. When objects are created we define the rights processes have to them. These authorization rules or policies must be enforced when a process attempts to access an object. </P>
<Figure id="LinkTarget_2546">

<ImageData src="images/4-Security Pattern Catalog_img_334.jpg"/>
Forces</Figure>

<P>The solution to this problem must resolve the following forces: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_335.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>may be many objects with different access restrictions defined by authorization rules: we need to enforce these restrictions when a process attempts to access an object. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_336.jpg"/>
</Figure>

<Lbl>We </Lbl>

<LBody>need to control different types of access, or the object may be misused. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2547">

<ImageData src="images/4-Security Pattern Catalog_img_337.jpg"/>
Example</Figure>

<P>Our operating system does not check all user requests to access resources such as files or memory areas. A hacker discovered that some accesses are not checked, and was able to steal customer information from our files. He also left a program that randomly overwrites memory areas and produces serious disruption to the other users. </P>
<Figure id="LinkTarget_2548">

<ImageData src="images/4-Security Pattern Catalog_img_338.jpg"/>
Solution</Figure>

<P>Use ato intercept access requests from processes. Thechecks whether the process has the requested type of access to the object according to some access rule. </P>
<Figure id="LinkTarget_2549">

<ImageData src="images/4-Security Pattern Catalog_img_339.jpg"/>
Structure</Figure>


<H5>Figure 1: Class structure of a controlled object monitor. </H5>

<P>Figure 1 shows the class diagram for this pattern. This is a specific implementation of a. The modification shows how the system associates the rules to the secure object in question. </P>
<Figure id="LinkTarget_2550">

<ImageData src="images/4-Security Pattern Catalog_img_340.jpg"/>
Dynamics</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_341.jpg"/>
</Figure>



<H5>Figure 2: Dynamics of a controlled object monitor. </H5>

<P>The dynamics of aare depicted in Figure 2 . </P>
<Figure id="LinkTarget_2551">

<ImageData src="images/4-Security Pattern Catalog_img_342.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_343.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>Process uses Access Requests to request access to an Authorization Enforcer . </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_344.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Authorization Enforcer checks access requests against a number of Access Rules . </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_345.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>process accesses Objects . It therefore uses a certain Access Type . </LBody>
</LI>
</L>
<Figure id="LinkTarget_2552">

<ImageData src="images/4-Security Pattern Catalog_img_346.jpg"/>
Collaborations</Figure>

<P>Figure 2 shows the dynamics of secure subject access to a secure object. Here the request is sent to thewhere it checks the Access Rules. If the access is allowed, it is performed and result returned to the subject. Note that here, a handle or ticket is returned to the Subject so that future access to the secure object can be directly performed without additional checking. </P>
<Figure id="LinkTarget_2553">

<ImageData src="images/4-Security Pattern Catalog_img_347.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2554">

<ImageData src="images/4-Security Pattern Catalog_img_348.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2555">

<ImageData src="images/4-Security Pattern Catalog_img_349.jpg"/>
Consequences</Figure>

<P>The following benefits may be expected from applying this pattern: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_350.jpg"/>
</Figure>

<Lbl>Each </Lbl>

<LBody>access request can be intercepted and accepted or rejected depending on the authorization rules. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_351.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>access rules can implement an access matrix defining different types of access for each subject. We can add content-dependent rules if required. The following potential liabilities may arise from applying this pattern: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_352.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>is a need to protect the authorization rules. However, the same mechanism that protects resources can also protect the rules. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_353.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>is an overhead involved in controlling each access. This is specially heavy for content-dependent rules. However, some accesses may be compiled for efficiency. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2556">

<ImageData src="images/4-Security Pattern Catalog_img_354.jpg"/>
Knownuses</Figure>

<P>Windows NT. The Windows NT security subsystem provides security using the patterns described here. It has the following three components: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_355.jpg"/>
</Figure>

<Lbl>Local </Lbl>

<LBody>Security Authority </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_356.jpg"/>
</Figure>

<Lbl>Security </Lbl>

<LBody>Account Manager </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_357.jpg"/>
</Figure>

<Lbl>Security </Lbl>

<LBody>Reference MonitorThe Local Security Authority (LSA)and Security Account Manager (SAM)work together to authenticate the user and create the user's access token. The security reference monitor runs in kernel mode and is responsible for the enforcement of access validation. When an access to an object is requested, a comparison is made between the file's security descriptor and the Secure ID (SID)information stored in the user's access token. The security descriptor is made up of Access Control Entries (ACE's)included in the object's Access Control List (ACL). When an object has an ACL the SRM checks each ACE in the ACL to determine if access is to be granted. After the Security Authorization Enforcer (SRM)grants access to the object, further access checks are not needed, as a handle to the object that allows further access is returned the first time. </LBody>
</LI>
</L>

<P>Types of object permissions are no access, read, change, full control, and special access. For directory access, the following are added: list, add, and read. Windows use the concept of a handle for access to protected objects within the system. Each object has a Security Descriptor (SD)that contains a Discretionary Access Control List (DACL)for the object. Each also process has a security token that contains an SID which identifies the process. This is used by the kernel to determine whether access is allowed. The ACL contains Access Control Entries (ACE's)that indicate what access is allowed for a particular process SID. The kernel scans the ACL for the rights corresponding to the requested access. </P>

<P>A process requests access to the object when it asks for a handle using, for example, a call to CreateFile (), which is used both to create a new file or open an existing file. When the file is created, a pointer to an SD is passed as a parameter. When an existing file is opened, the request parameters, in addition to the file handle, contain the desired access, such as GENERIC\_READ. If the process has the desired rights for the access, the request succeeds and an access handle is returned, so that different handles to the same object may have different accesses. Once the handle is obtained, additional access to read a file will not require further authorization. The handle may also be passed to another trusted function for further processing. </P>

<P>Java1.2Security. The Java security subsystem provides security using the patterns described here. The Java Access Controller builds access permissions based on permission and policy. It has a checkPermission method that determines the codesource object of each calling method and uses the current Policy object to determine the permission objects associated with it. Note that the checkPermission method will traverse the call stack to determine the access of all calling methods in the stack. The java. policy file is used by the security manager that contains the grant statements for each codesource. </P>

<P id="LinkTarget_2557">Controlled Process Creator </P>
<Figure id="LinkTarget_2558">

<ImageData src="images/4-Security Pattern Catalog_img_358.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: This pattern addresses how to define and grant appropriate access rights for a new process, in an operating system in which processes or threads need to be created according to application needs. </P>
<Figure id="LinkTarget_2559">

<ImageData src="images/4-Security Pattern Catalog_img_359.jpg"/>
Problem</Figure>

<P>A user executes an application composed of several concurrent processes. Processes are usually created through system calls to the operating system. A process that needs to create a new process gets the operating system to create a child process that is given access to some resources. A computing system uses many processes or threads. Processes need to be created according to application needs, and the operating system itself is composed of processes. If processes are not controlled, they can interfere with each other and access data illegally. Their rights for resources should be carefully defined according to appropriate policies, for exampleÂ¿need-to-know.Â¿ </P>
<Figure id="LinkTarget_2560">

<ImageData src="images/4-Security Pattern Catalog_img_360.jpg"/>
Forces</Figure>

<P>The solution to this problem must resolve the following forces: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_361.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>should be a convenient way to select a policy to define processÂ¿rights. Defining rights without a policy brings contradictory and non-systematic access restrictions that can be easily circumvented. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_362.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>child process may need to impersonate its parent in specific actions, but this should be carefully controlled, otherwise a compromised child could leak information or destroy data. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_363.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>number of child processes created by a process must be restricted, or process spawning could be user to carry out denial-of-service attacks. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_364.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>are situations in which a process needs to act with more than its normal rights, for example to access data in a file to which it doesnÂ¿t normally have access. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2561">

<ImageData src="images/4-Security Pattern Catalog_img_365.jpg"/>
Example</Figure>

<P>Most operating systems create a process with the same rights as its parent. If a hacker can trick an operating system into creating a child of the supervisor process, this runs with all the rights of the supervisor. </P>
<Figure id="LinkTarget_2562">

<ImageData src="images/4-Security Pattern Catalog_img_366.jpg"/>
Solution</Figure>

<P>Because new processes are created through system calls or messages to the operating system, we have a chance to control the rights given to a new process. Typically, operating systems create a new process as a child process. We let the parent assign a specific set of rights to its children, which is more secure because a more precise control of rights is possible. </P>
<Figure id="LinkTarget_2563">

<ImageData src="images/4-Security Pattern Catalog_img_367.jpg"/>
Structure</Figure>

<P>The structure of the controlled process creator is depicted in Figure 1 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_368.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_368.jpg"/>
</Figure>

<P>Figure 1: Structure of the controlled process creator. </P>
<Figure id="LinkTarget_2564">

<ImageData src="images/4-Security Pattern Catalog_img_369.jpg"/>
Dynamics</Figure>

<P>The dynamics of the controlled process creator are depicted in Figure 2 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_370.jpg"/>
</Figure>

<P>Figure 2: Dynamics of the controlled process creator. </P>
<Figure id="LinkTarget_2565">

<ImageData src="images/4-Security Pattern Catalog_img_371.jpg"/>
Participants</Figure>

<P>The Controlled Process Creator is a part of the operating system in charge of creating processes. The Creation Request contains the access rights that the parent defines for the created child. These access rights must be a subset of the parentÂ¿s access rights. </P>
<Figure id="LinkTarget_2566">

<ImageData src="images/4-Security Pattern Catalog_img_372.jpg"/>
Collaborations</Figure>

<P>A process requests the creation of a new process by submitting a Creation Request to the Process Creator. The Process Creator then creates both a new process and a set of access rights, based on this Creation Request, and assigns the access rights to the new process. </P>
<Figure id="LinkTarget_2567">

<ImageData src="images/4-Security Pattern Catalog_img_373.jpg"/>
Implementation</Figure>

<P>For each required application of kernel threads, define their rights according to their intended function. </P>
<Figure id="LinkTarget_2568">

<ImageData src="images/4-Security Pattern Catalog_img_374.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2569">

<ImageData src="images/4-Security Pattern Catalog_img_375.jpg"/>
Consequences</Figure>

<P>The following benefits may be expected from applying this pattern: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_376.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>created process can receive rights according to required security policies. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_377.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>number of children produced by a process can be controlled. This is useful to control denial of service attacks. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_378.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>rights may include the parent's id, allowing the child to run with the rights of its parent.The following potential liability may arise from applying this pattern: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_379.jpg"/>
</Figure>

<Lbl>Explicit </Lbl>

<LBody>rights transfer takes more time than using a default transfer. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2570">

<ImageData src="images/4-Security Pattern Catalog_img_380.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2571">Credential Tokenizer </P>
<Figure id="LinkTarget_2572">

<ImageData src="images/4-Security Pattern Catalog_img_381.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: You need a flexible mechanism to encapsulate a security token that can be used by different security infrastructure providers. </P>
<Figure id="LinkTarget_2573">

<ImageData src="images/4-Security Pattern Catalog_img_382.jpg"/>
Problem</Figure>

<P>There are different forms of user credentials (also referred to as security tokens), such as username/passwords, binary security tokens (for example, X.509v3certificates), Kerberos tickets, SAML tokens, smart card tokens and biometric samples. Most security tokens are domain-specific. To encapsulate these user credentials for use with different security product architectures, developers have to modify the security token processing routine to accommodate individual security product architectures, which depends on the specific security specification the security product uses. A user credential based on a digital certificate will be processed differently than that of a Kerberos ticket. There is no consistent and flexible mechanism for using a common user credential tokenizer that supports different types of security product architectures supporting different security specifications. </P>
<Figure id="LinkTarget_2574">

<ImageData src="images/4-Security Pattern Catalog_img_383.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_384.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>need a reusable component that helps to extract processing logic to handle creation and management of security tokens instead of embedding them in the business logic or the authentication process. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_385.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to shield off the design and implementation complexity using a common mechanism that can accommodate a security credential and interface with a supporting security provider that makes use of them. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2575">

<ImageData src="images/4-Security Pattern Catalog_img_386.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2576">

<ImageData src="images/4-Security Pattern Catalog_img_387.jpg"/>
Solution</Figure>

<P>Use a Credential Tokenizer to encapsulate different types of user credentials as a security token that can be reusable across different security providers. A Credential Tokenizer is a security API abstraction that creates and retrieves the user identity information (for example, public key/X.509v3certificate)from a given user credential (for example, a digital certificate issued by a Certificate Authority). Each security specification has slightly different semantics or mechanisms to handle user identity and credential information. These include the following characteristics: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_388.jpg"/>
</Figure>

<Lbl>Java </Lbl>

<LBody>applications that need to access user credentials or security tokens from different application security infrastructures. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_389.jpg"/>
</Figure>

<Lbl>Web </Lbl>

<LBody>Services security applications that need to encapsulate a security token, such as username token or binary token, in the SOAP message. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_390.jpg"/>
</Figure>

<Lbl>Java </Lbl>

<LBody>applications that support SAML or Liberty that need to include an authentication credential in the SAML assertion request or response. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_391.jpg"/>
</Figure>

<Lbl>Java </Lbl>

<LBody>applications that need to retrieve user credentials for performing SSO with legacy applications. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2577">

<ImageData src="images/4-Security Pattern Catalog_img_392.jpg"/>
Structure</Figure>

<P>The structure of the Credential Tokenizer is depicted in Figure 1 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_393.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_393.jpg"/>
</Figure>

<P>Figure 1: Structure of the credential tokenizer. </P>
<Figure id="LinkTarget_2578">

<ImageData src="images/4-Security Pattern Catalog_img_394.jpg"/>
Dynamics</Figure>

<P>The dynamics of a Credential Tokenizer are depicted in Figure 2 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_395.jpg"/>
</Figure>

<P>Figure 2: Dynamics of the credential tokenizer. </P>
<Figure id="LinkTarget_2579">

<ImageData src="images/4-Security Pattern Catalog_img_396.jpg"/>
Participants</Figure>

<P>The Credential Tokenizer can be used to create different security tokens (SecurityToken), including username token and binary tokens (X.509v3certificate. When creating a security token, the Credential Tokenizer creates a system context (TokenContext)that encapsulates the token type, the name of the principal, the service configuration, and the protocol binding that the security token supports. </P>

<P>There are two major objects in the Credential Tokenizer: SecurityToken and TokenContext. The SecurityToken is a base class that encapsulates any security token. It can be extended to implement username token (UsernameToken), binary token (BinaryToken), and certificate token (X509v3CertToken). In this pattern, Username token is used to represent a user identity using Username Password. Binary tokens are used to represent a variety of security tokens that resemble a user identity using binary text form (such as Kerberos Tickets). Certificate tokens denote digital certificates issued to represent a user identity. An X.509v3certificate is a common form of certificate token. </P>

<P>The TokenContext class refers to the system context used to create security tokens. It includes information such as the security token type, service configuration, and protocol binding for the security token. This class defines public interfaces only to set or get the security token information. TokenContextImpl is the implementation for TokenContext. </P>
<Figure id="LinkTarget_2580">

<ImageData src="images/4-Security Pattern Catalog_img_397.jpg"/>
Collaborations</Figure>

<P>As an illustration of the collaborations in a credential tokenizer, the Client may be a service requester that is required to create the Username Password-token to represent in the WS-Security headers of a SOAP message. The CredentialTokenizer denotes the credential tokenizer that creates and manages user credentials. The UserCredential denotes the actual Credential Token, such as username/password or a X.509v3digital certificate. The following sequences describe the interaction between the Client, CredentialTokenizer, and UserCredential: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_398.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>creates an instance of CredentialTokenizer. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_399.jpg"/>
</Figure>

<Lbl>CredentialTokenizer </Lbl>

<LBody>retrieves the service configuration and the protocol bindings for the target service request. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_400.jpg"/>
</Figure>

<Lbl>CredentialTokenizer </Lbl>

<LBody>retrieves the user credentials from SecurityProvider according to the service configuration. For example, it extracts the key information from an X.509v3certificate. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_401.jpg"/>
</Figure>

<Lbl>CredentialTokenizer </Lbl>

<LBody>creates a security token from the user credentials just retrieved. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_402.jpg"/>
</Figure>

<Lbl>Upon </Lbl>

<LBody>successful completion of creating the security token, CredentialTokenizer returns the security token to Client. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2581">

<ImageData src="images/4-Security Pattern Catalog_img_403.jpg"/>
Implementation</Figure>

<P>To build a Credential Tokenizer, developers need to identify the service, authentication scheme, application provider, and underlying protocol bindings. For example, in a SOAP communication model, the service requestor is required to use a digital certificate as a binary security token for accessing a service end-point. In this case, the service configuration specifies the X.509v3digital certificate as the security token and SOAP messages and SOAP over HTTPS as the protocol binding. Similarly, in a J2EE application, the client is required to use a Client-certificate for enabling mutual authentication. In this case, the authentication requirements specify an X.509v3digital certificate as the security token and SOAP over HTTPS as the protocol binding, but the request is represented as HTML generated by a J2EE application using a JSP or a servlet. </P>

<P>Credential Tokenizer provides an API abstraction mechanism for constructing security tokens based on a defined authentication requirement, protocol binding, and application provider. It also provides API mechanisms for retrieving security tokens issued by a security infrastructure provider. Different strategies to implement a credential tokenizer exist: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_404.jpg"/>
</Figure>

<Lbl>Service </Lbl>

<LBody>Provider Interface Approach: using a service provider interface approach to define the public interfaces for different security tokens will be more flexible and adaptive for different security tokens and devices. For example, certificate tokens may differ in vendor implementation. Developers can use the same public interfaces to support different credential token implementations and meet the requirements of different platforms and service providers without customizing the APIs for specific devices. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_405.jpg"/>
</Figure>

<Lbl>Protocol </Lbl>

<LBody>Binding Strategy: as with the Assertion Builder pattern, it is possible that the same client may be using the Credential Tokenizer to encapsulate user credentials as a security token in a SOAP message. To accommodate such use, developers can employ a custom service configuration look-up function (for example, refer to getProtocolBinding method in the SSOContext discussed in SSO Delegator pattern)to determine the data transport and application environment requirements. In this way, the common processing logic of the user credential processing and security token encapsulation can be reused. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2582">

<ImageData src="images/4-Security Pattern Catalog_img_406.jpg"/>
Pitfalls</Figure>

<P>The Credential Tokenizer pattern is essential to encapsulating user credentials and user information to meet authentication and non-repudiation security requirements. One important security factor for building reliable credential tokenizers is the identity management infrastructure and whether the keys are securely managed prior to the credential processing. The following are security factors and risks associated with the Credential Tokenizer pattern. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_407.jpg"/>
</Figure>
Username password token. Username password tokens are highly vulnerable to attacks by using a password dictionary. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_408.jpg"/>
</Figure>
X.509v3certificate token. Certificate token is a reliable security token and is stronger than Username Password token. However, it may be susceptible to human error during the management of the distribution of digital certificates and the timely revocation of certificates. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_409.jpg"/>
</Figure>
Key management strategy. The security factor of key management strategy defines the process of generating key pairs, storing them in safe locations, and retrieving them. The generation of SAML assertion statements and signed SOAP messages using WS-Security is key management strategy. If the key management strategy and the infrastructures are not in place, the user credential token processing will be at risk.Should we use username/password as a security token? Some security architects insist that the username/password pair is not secure enough and should not be used as a security token. To mitigate the potential risk of a weak password, security architects should reinforce strong password policies and adopt a flexible security token mechanism such as Credential Tokenizer to accommodate different types of security tokens for future extension and interoperability. </P>

<P>What other objects can be encapsulated as security token?You can embed different types of security tokens in the Credential Tokenizer, not just username/password or digital certificate. For example, you can embed binary security tokens, because they can be encapsulated as a SAML token for an authentication assertion statement. In addition, you can also add the REL token (which denotes the rights, usage permissions, constraints, legal obligations, and license terms pertaining to an electronic document)based on the eXtensible Rights Markup Language (XrML). </P>
<Figure id="LinkTarget_2583">

<ImageData src="images/4-Security Pattern Catalog_img_410.jpg"/>
Consequences</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_411.jpg"/>
</Figure>
Supports SSO. The Credential Tokenizer pattern helps in capturing authentication credentials for multifactor </P>

<P>authentication. It also helps in using&quot;shared state&quot;(the&quot;shared state&quot;mechanism allows a login module to put the authentication credentials into a shared map and then passes it to other login modules)among authentication providers in order to establish single sign-on, where the Credential Tokenizer can be used for retrieving the SSO token and providing SSOToken on demand for requesting applications. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_412.jpg"/>
</Figure>
Provides a vendor-neutral credential handler. The Credential Tokenizer pattern wraps vendor-specific APIs using a generic mechanism in order to create or retrieve security tokens from security providers. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_413.jpg"/>
</Figure>
Enables transparency by encapsulating multiple identity management infrastructures. The Credential Tokenizer pattern encapsulates any form of security token as a credential token and thus eases integration and enables interoperability with different identity management infrastructures. </P>
<Figure id="LinkTarget_2584">

<ImageData src="images/4-Security Pattern Catalog_img_414.jpg"/>
Knownuses</Figure>

<P>(Nothing given) </P>

<P id="LinkTarget_2585">Demilitarized Zone </P>
<Figure id="LinkTarget_2586">

<ImageData src="images/4-Security Pattern Catalog_img_415.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Any organization conducting e-commerce or publishing information over Web technologies must make their service easily accessible to their users. However, any form of Web site or e-commerce system is a potential target for attack, especially those on the Internet. A Demilitarized Zone (DMZ)separates the business functionality and information from the Web servers that deliver it, and places the Web servers in a secure area. This reduces the ``surface area''of the system that is open to attack. </P>
<Figure id="LinkTarget_2587">

<ImageData src="images/4-Security Pattern Catalog_img_416.jpg"/>
Problem</Figure>

<P>Internet technology systems, particularly those facing the public Internet, are regularly subject to attacks against their functionality, resources and information. How do we protect our systems from direct attacks? </P>
<Figure id="LinkTarget_2588">

<ImageData src="images/4-Security Pattern Catalog_img_417.jpg"/>
Forces</Figure>

<P>Solving this problem requires you to resolve the following forces: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_418.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>cost of an extensive security solution will be high, but the cost of an intrusion may also be high in terms of system damage, theft and loss of customer confidence. If the potential rewards from the attack are high in terms of financial gain or publicity, the risk of such an attack will be higher. The scope, and hence cost, of any countermeasure must be commensurate with the level of perceived threat and the potential cost of the intrusion. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_419.jpg"/>
</Figure>

<Lbl>To </Lbl>

<LBody>prevent attack, we must make intrusion into any part of the system as difficult as possible, especially an organization's internal business systems. However, increasing the level of security will generally make the system more difficult to use, which conflicts with the goal of making the system open and easy for legitimate users. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2589">

<ImageData src="images/4-Security Pattern Catalog_img_420.jpg"/>
Example</Figure>

<P>A commercial Internet system holds customer profiling information, dealer order information and commercially-sensitive sales information, any of which could be stolen or corrupted by an attacker. This information must be shared with the organizationÂ¿s corporate systems, making them liable to attack as well. You could use a firewall to control access to your systems from the outside world as shown below. </P>

<P>The firewall would be configured to allow only inbound traffic to access the Web server. However, this places a large onus on the system administrators to configure the firewall correctly, and on the firewall software to operate correctly. If the firewall fails, an attacker could potentially have direct access to other business resources such as the SAP system or mainframe shown in the diagram. The configurationof the firewall is further complicated by the fact that for any highly-available Webbased system, multiple servers must be exposed to support either load balancing or failover. If the Web-based system is also high-functionality, additional protocols must be allowed through the firewall. All of this makes a configuration error more likely. </P>
<Figure id="LinkTarget_2590">

<ImageData src="images/4-Security Pattern Catalog_img_421.jpg"/>
Solution</Figure>

<P>Provide a region of the system that is separated from both the external users and the internal data and functionality---commonly known as a demilitarized zone (DMZ). This region will contain the servers, such as Web servers, that expose the functionality of the Web-based application. Restrict access to this region from the outside by limiting network traffic flow to certain physical servers. Use the same techniques to restrict access from servers in the DMZ to the internal systems. </P>
<Figure id="LinkTarget_2591">

<ImageData src="images/4-Security Pattern Catalog_img_422.jpg"/>
Structure</Figure>

<P>The structure of a DMZ is depicted in Figure 1 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_423.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_423.jpg"/>
</Figure>

<P>Figure 1: Structure of a demilitarized zone. </P>
<Figure id="LinkTarget_2592">

<ImageData src="images/4-Security Pattern Catalog_img_424.jpg"/>
Dynamics</Figure>

<P>The dynamics of a DMZ are depicted in Figure 2 and Figure 3 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_425.jpg"/>
</Figure>

<P>Figure 2: Dynamics of a DMZ: rejecting a request. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_426.jpg"/>
</Figure>

<P>Figure 3: Dynamics of a DMZ: allowing a request. </P>
<Figure id="LinkTarget_2593">

<ImageData src="images/4-Security Pattern Catalog_img_427.jpg"/>
Participants</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_428.jpg"/>
</Figure>
External router, a filtering router whose principal responsibility is to ensure that all inbound traffic is directed to the firewall. Its secondary responsibility may be to keep out random traffic generated by attackers. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_429.jpg"/>
</Figure>
Firewall, responsible for receiving inbound requests from the external router and subjecting them to more sophisticated </P>

<P>analysis, such as stateful inspection. If a request is judged to be legitimate, it will be forwarded to an appropriate Web server. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_430.jpg"/>
</Figure>
Web servers, providing access to the applicationÂ¿s functionality and information. There may be multiple Web servers that are accessed through a load balancer. A Web server will receive a request from the firewall and service that request. A request for a static resource, such as a fixed page of HTML or an image, may be delivered from a cache held on a local disk. A request for a dynamic resource will be proxied through to an application server that is shielded from the outside world in the style of a protection reverse proxy. No application functionality, such as servlets or ASP. NET pages, will run on the Web servers, as this makes them open to direct attack. Although described here as ``Web''servers, these servers may support access through other protocols such as FTP. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_431.jpg"/>
</Figure>

<Lbl>Internal </Lbl>

<LBody>router, a filtering router whose principal responsibility is to ensure that it only passes legitimate traffic from the Web servers through to the internal network. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_432.jpg"/>
</Figure>

<Lbl>Application </Lbl>

<LBody>servers, a platform on which the application's code runs, typically in the form of Web components such as servlets and business components such as EJBs. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2594">

<ImageData src="images/4-Security Pattern Catalog_img_433.jpg"/>
Collaborations</Figure>

<P>The first scenario in Figure 3 shows a successful client request for some business functionality. The client browser request is filtered by the external router to ensure that it is destined for a valid server. The request is forwarded to the firewall to undergo more rigorous checking. If the firewall is happy with the protocol use, the request goes onwards to the server requested by the client. </P>

<P>The second scenario shows a malicious client call being blocked by the firewall. The client browser request is again filtered by the external router to ensure that it is destined for a valid server. The request is then forwarded to the firewall to undergo more rigorous checking. At this stage, the firewall detects invalid protocol use---maybe some form of protocol-based attack, or an attempt to flood the server. The request is rejected and the suspicious activity is logged. See Figure 2 . </P>
<Figure id="LinkTarget_2595">

<ImageData src="images/4-Security Pattern Catalog_img_434.jpg"/>
Implementation</Figure>

<P>Since the request handling and business functionality must be separated by a filter, it is best to use dedicated web and application servers where any programmatic functionality, whether business or presentation, is deployed on an application server that is physically separate from the Web server. These application servers can be placed on a more protected network than the Web servers. This protected network will have easier (possibly direct)access to the corporate information and services required by the Web-based application. </P>

<P>The external router should be configured to deny any attempted access to any network addresses outside of those known in the DMZ. To increase security, any requests with a destination address that does not match the Web server address (or that of the Web server cluster)may be rejected. The external router may also reject requests based on the port number of the request, for example rejecting any request that is not for port80. The external router will therefore block direct attacks on the internal router, and possibly the firewall. </P>

<P>The Web servers will be built solely for the purpose of delivering static Web content or proxying requests through to the application servers. These Web servers should be locked down (or ``hardened'')by removing unnecessary functionality. Such hardening helps to prevent other, unintended, access to the servers. </P>

<P>The internal router will limit network traffic to connections between the Web servers on the DMZ and specific internal servers, such as the application servers, using a fixed set of protocols. This restriction reduces the risk of attack on other internal systems. The use of an internal router helps to reduce the risk of attack should the external router be breached. Because of this threat, no traffic should be allowed directly from the external router to the internal router. The whole operation of the routers and the traffic filtering may be controlled from a machine running specific firewall software. This makes it easier to apply consistent rules to the routers and to use statistical analysis to detect potential attacks. The firewall applies more sophisticated traffic filtering rules to detect more complex attacks. Depending on the type of firewall, the network traffic may or may not pass through the firewall itself. </P>

<P>Because the number of servers exposed to the outside world is reduced, it means that fewer parts of the system need a high level of security. In the scenario described, the application servers will not need to be hardened to the same level as the Web servers. To access those servers not directly exposed (and hence less securely configured), any attacker will have to breach several security elements that form part of the DMZ. Hopefully, they will set off various intruder alerts as they do soÂ¿if, indeed, they are capable of doing so. </P>

<P>Applying a DMZ to a system is a good way to provide protection for the system. However, you must remember that protecting the platforms on which the system is built is only part of the solution. Since security is a matter of policy as well as technology, all protection mechanisms---such as a DMZ---must be backed up with appropriate procedures and processes to ensure that the level of security remains high. If there is a high level of concern about possible attacks on the system, an intrusion detection system (IDS)may also be used. An IDS monitors the traffic on the network, or on specific hosts, looking for suspicious activity. If the IDS identifies a pattern of network or host traffic that indicates an attack is underway, it will notify the system administrators. An IDS could be used on the DMZ itself, on the internal network, or both. </P>

<P>Implementation variants include: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_435.jpg"/>
</Figure>
Multi-homed firewall. The number of machines involved in implementing the DMZ will vary according to the level of protection required (based on anticipated risk)and the amount of money available. In the simplest case, the DMZ may be partitioned using a single firewall machine. This machine will have three network cards: one connected to the Internet, one connected to the internal network and one connected to a dedicated LAN containing only the Web servers and any other ``public facing''parts of the system. The firewall software running on the machine will manage the traffic between the three networks to maintain three separate security zones. The benefits of such an ``multi-homed host''implementation include reduced cost and ease of maintenance. However, this system creates a single point of failure, both in terms of security and availability. It also means that any attacker is only one system away from gaining access to the sensitive internal systems. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_436.jpg"/>
</Figure>

<Lbl>Firewall </Lbl>

<LBody>as filter. A multi-homed firewall host may be used in place of the external or internal router. This means that all traffic must pass through the firewall (and its filtering rules)to reach the internal network or the DMZ itself. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_437.jpg"/>
</Figure>

<Lbl>Stealth </Lbl>

<LBody>firewall. Rather than relaying traffic, the firewall may simply be attached to the demilitarized network and act inÂ¿stealthÂ¿mode, simply monitoring traffic for potential intrusion. This can make the firewall itself more difficult for an intruder to detect. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2596">

<ImageData src="images/4-Security Pattern Catalog_img_438.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2597">

<ImageData src="images/4-Security Pattern Catalog_img_439.jpg"/>
Consequences</Figure>

<P>The following benefits may be expected from applying this pattern: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_440.jpg"/>
</Figure>

<Lbl>Security </Lbl>

<LBody>is improved, because fewer systems are exposed to attack and multiple firewall artefacts must be breached to compromise security. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_441.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>level and depth of protection can be varied to match the anticipated risk and the cost limitations. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_442.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>additional security is transparent to the users of the system functionality and to the developers of such functionality. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_443.jpg"/>
</Figure>

<Lbl>Fewer </Lbl>

<LBody>hosts must be hardened to withstand attack than if they were all exposed to the outside world.The following potential liabilities may arise from applying this pattern: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_444.jpg"/>
</Figure>

<Lbl>Availability </Lbl>

<LBody>may be impacted, because the firewall becomes a single point of failure. The standard procedure is therefore for a firewall to ``fail closed''---that is, in the event of failure, it will deny all connections to the protected systems. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_445.jpg"/>
</Figure>

<Lbl>Manageability </Lbl>

<LBody>is impacted, because the very restrictions that limit access to internal data may make it difficult to access the application from an internal monitor. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_446.jpg"/>
</Figure>

<Lbl>Cost </Lbl>

<LBody>is increased, because extra elements must be procured to build the DMZ. These include not only the filtering routers, firewall software and firewall host, but also the extra network equipment, such as switches and cabling, used on the DMZ itself. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_447.jpg"/>
</Figure>

<Lbl>Performance </Lbl>

<LBody>is impacted due to the overhead of network traffic filtering. Performance is also impacted as it becomes necessary physically to separate the Web servers from the application servers. If this has not already been done to improve another non-functional characteristic, it must be done to implement a DMZ, and so will add multiple extra network hops for each user transaction. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2598">

<ImageData src="images/4-Security Pattern Catalog_img_448.jpg"/>
Knownuses</Figure>

<P>DMZs are extremely common for almost all Internet sites and advice on the creation of DMZ configurations is offered by almost all major network hardware and software vendors, such as: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_449.jpg"/>
</Figure>

<Lbl>Sun </Lbl>

<LBody>http://www. sun. com/executives/iforce/solutions/SecuritySolnIIFinal3. pdf Microsoft http://www. microsoft. com/windows2000/techinfo/reskit/en-us/default. asp?url=/windows2000/techinfo/reskit/enus/deploy/dgcf\_inc\_icku. asp </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_450.jpg"/>
</Figure>

<Lbl>Cisco </Lbl>

<LBody>(variously described as part of their SAFE Blueprint) </LBody>
</LI>
</L>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_451.jpg"/>
</Figure>

<P id="LinkTarget_2599">Encrypted Storage </P>
<Figure id="LinkTarget_2600">

<ImageData src="images/4-Security Pattern Catalog_img_452.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: The Encrypted Storage pattern ensures that even if data is stolen, the most sensitive data will remain safe from prying eyes. </P>
<Figure id="LinkTarget_2601">

<ImageData src="images/4-Security Pattern Catalog_img_453.jpg"/>
Problem</Figure>

<P>Web applications are often required to store a great deal of sensitive user information, such as credit card numbers, passwords, and social security numbers. Although every effort can be taken to defend the Web server, one can never be sure that some new vulnerability wonâ€™t be discovered, leading to the compromise of the server. Hackers are known to specifically target this sort of information. </P>

<P>Historically, Web sites that have experienced the loss of sensitive customer data have found it very difficult to recover from the adverse publicity. While many sites have recovered from the shame of being defaced, the large-scale loss of credit card numbers is a catastrophic failure. Ultimately, it is always preferable not to store sensitive data. However, sometimes it is not avoidable. For example, credit card transactions are often not a single event. If an item is back ordered or the user requires a refund, the site must be able to access the credit card number that was used. Similarly, many government and financial sites rely on the social security number as the primary identifier for American users. These sites need a better approach to protecting this data. </P>
<Figure id="LinkTarget_2602">

<ImageData src="images/4-Security Pattern Catalog_img_454.jpg"/>
Forces</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2603">

<ImageData src="images/4-Security Pattern Catalog_img_455.jpg"/>
Example</Figure>

<P>The UNIX password file hashes each user's password and stores only the hashed form. Several Web sites with which we are familiar use encryption to protect the most sensitive data that must be stored on the server. All use variations on this pattern. </P>
<Figure id="LinkTarget_2604">

<ImageData src="images/4-Security Pattern Catalog_img_456.jpg"/>
Solution</Figure>

<P>The Encrypted Storage pattern encrypts the most critical user data before it is ever committed to disk. Before it can be used, it is decrypted in memory. If the Web server is compromised, an attacker may be able to steal the data store, but will not be able to gain access to the sensitive data. </P>

<P>In the most straightforward approach, each userâ€™s data is protected using a single key. Under this solution, the application server maintains a single key that is used to encrypt and decrypt all critical user data. The key should be stored in a secure fashion, and especially not in the same data store as the protected data. </P>

<P>The key should be changed occasionally. This requires that the system be able to decrypt data using the old key and re-encrypt it using the new. Because of the complexity of encrypting and decrypting data on the fly, this should be performed with the database off-line during a period of downtime. If downtime is not possible, a large key should be selected with the expectation that it will not be changed. </P>
<Figure id="LinkTarget_2605">

<ImageData src="images/4-Security Pattern Catalog_img_457.jpg"/>
Structure</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_458.jpg"/>
</Figure>

<P>Figure 1:Encrypted storage </P>
<Figure id="LinkTarget_2606">

<ImageData src="images/4-Security Pattern Catalog_img_459.jpg"/>
Dynamics</Figure>

<P>Server startup: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_460.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>server loads the key into the encryption module </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_461.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>server takes protective measures to ensure that the key cannot be further accessed </LBody>
</LI>
</L>

<P>Receipt of sensitive data: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_462.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>client submits a transaction containing sensitive data </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_463.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>server submits the data to the encryption module </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_464.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>server overwrites the cleartext version of the sensitive data </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_465.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>sensitive data is stored in the database with other user data and an identifier for the sensitive information </LBody>
</LI>
</L>

<P>Use of sensitive data: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_466.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>transaction requiring the key is requested (usually from the client) </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_467.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>transaction processor retrieve the user data from the database </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_468.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>sensitive data is submitted to the encryption module for decryption </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_469.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>transaction is processed </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_470.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>cleartext sensitive data is overwritten </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_471.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>transaction is reported to the client without any sensitive data </LBody>
</LI>
</L>

<P>Key refreshing: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_472.jpg"/>
</Figure>
A utility program is started and loaded with both the old and the new key </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_473.jpg"/>
</Figure>
Each user record in the database is converted individually. </P>
<Figure id="LinkTarget_2607">

<ImageData src="images/4-Security Pattern Catalog_img_474.jpg"/>
Participants</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2608">

<ImageData src="images/4-Security Pattern Catalog_img_475.jpg"/>
Collaborations</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2609">

<ImageData src="images/4-Security Pattern Catalog_img_476.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2610">

<ImageData src="images/4-Security Pattern Catalog_img_477.jpg"/>
Pitfalls</Figure>

<P>Never echo the sensitive data to the user. If you need to differentiate among several credit card numbers, display only the last four digits of the card. These should be stored in the database along with the encrypted card number. Both performance and security could suffer if the card numbers are decrypted every time the last four digits are required. </P>

<P>Do not rely on any Operating System-level encrypting file system. Encrypting file systems are adequate for defending against a lost hard drive. But if the system is compromised by a remote attacker, the attacker will gain some sort of toehold on the system. In that case, the operating system will dutifully decrypt all data as it is requested from the file system and deliver it to the attacker. </P>

<P>The following general principles should be followed: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_478.jpg"/>
</Figure>

<Lbl>Never </Lbl>

<LBody>attempt to invent an encryption algorithm. Use a tested algorithm from Applied Cryptography. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_479.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>possible, use a freely available library rather than coding one from scratch. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_480.jpg"/>
</Figure>

<Lbl>After </Lbl>

<LBody>sensitive data is used, the memory variables containing it should be overwritten. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_481.jpg"/>
</Figure>

<Lbl>Care </Lbl>

<LBody>must be taken to insure that sensitive data is not written into virtual memory during processing. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_482.jpg"/>
</Figure>

<Lbl>Use </Lbl>

<LBody>only symmetric encryption algorithms. Asymmetric (public/private) algorithms are too computationally expensive and could easily result in processor resources being exhausted during normal usage. </LBody>
</LI>
</L>

<P>Protection of the Key </P>

<P>If at all possible, the key should not be stored on the file system. There are COTS devices available that provide the system with a physical encryption card. These devices offer performance benefits, and also guarantee that the key cannot be read off the device. The key is manually loaded into the card, the encryption takes place on the card, and the key cannot be extracted from the card. The only downside to this approach is the cost â€“ both the cost of purchasing the hardware and the development and maintenance costs of programming around it. A cheaper alternative to loading the key is to require that an administrator load the key at system start, either from removable media or using a strong passphrase. This reduces the risk of having the key on-line, but does expose the key to a fair number of different people. This approach may sacrifice some availability because an operator </P>

<P>py pppp y yp </P>

<P>must manually intervene whenever the system restarts. </P>

<P>If neither of these approaches is feasible, the Web server can read the key value from a file at server startup. This approach ensures that the server can restart unattended, but puts the key at risk if the system is compromised. To reduce this risk, use one or more of the Server Sandbox pattern techniques, even going so far as to chroot the server so it cannot see the key file once it has completed its initialization process. </P>

<P>Unless a hardware encryption device is used, the server will have to maintain a copy of the encryption key in RAM in order to decrypt data as it is needed. Minimize the code modules that have access to the key. And if the operating system supports it, mark the decryption module so that it will never be swapped to disk. Also be aware that a coredump file might contain the key â€“ these should be disabled on a production server. </P>

<P>In addition to protecting the key from attackers, the key must also be protected from conventional loss. The loss of the key would be catastrophic, since all user data would become inaccessible to the server. Maintain multiple backups of the key at various off-premises locations. Recognize that multiple keys increase the risk that one could be stolen, and take care to protect them all. </P>

<P>Variation: One Key Per User </P>

<P>This alternative is similar to the Password Propagation pattern in that it requires that the individual userâ€™s password be available in order to gain access to that userâ€™s data. The server itself does not even have a key that will allow access to a userâ€™s data. It is not really applicable to the protection of credit card numbers, as those numbers must be available to the server even when the user is not connected. </P>

<P>In this approach, the userâ€™s password is used to encrypt the data that is sensitive to that user. To decrypt the data, the user must again provide their password, which is never stored in decrypted form. Because decryption of the data requires the user to provide his/her password, and because that password is not known outside of the context of an authenticated user transaction, the site administrator has no access to that data. </P>

<P>If the password itself is stored in the data, it should be stored in hashed form, using a different algorithm than the hash function used to encrypt the sensitive data. If the password is stored in plaintext or hashed using the same algorithm, the attacker will have the key needed to decrypt the data. </P>

<P>If the user changes his/her password, the data must be decrypted using the old password and reencrypted using the new. If the user loses his/her password, encrypted data will be lost. Data protected in this way must be data that can be recovered through some other means, such as the user providing it again. </P>

<P>Possible Attacks </P>

<P>There are a number of possible attacks that could be perpetrated against this pattern: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_483.jpg"/>
</Figure>

<Lbl>Search </Lbl>

<LBody>of virtual memory â€“ if sensitive data is paged out of RAM into a disk-based virtual memory file, it may be possible for an attacker to search the pagefile for obvious data patterns (such as numeric strings that are recognized as credit card numbers). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_484.jpg"/>
</Figure>

<Lbl>Key </Lbl>

<LBody>capture â€“ an attacker will attempt to gain access to the key used to encrypt the data </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_485.jpg"/>
</Figure>

<Lbl>Dictionary </Lbl>

<LBody>attack â€“ when encryption keys are generated from passwords, password-guessing attacks are generally much less difficult than exhaustive search of all possible keys. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_486.jpg"/>
</Figure>

<Lbl>Race </Lbl>

<LBody>condition attack â€“ an attacker may be able to capture the data before it has been encrypted. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2611">

<ImageData src="images/4-Security Pattern Catalog_img_487.jpg"/>
Consequences</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2612">

<ImageData src="images/4-Security Pattern Catalog_img_488.jpg"/>
Knownuses</Figure>

<P>(Nothing given) </P>

<P id="LinkTarget_2613">Firewall </P>
<Figure id="LinkTarget_2614">

<ImageData src="images/4-Security Pattern Catalog_img_489.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Control incoming and outgoing network connections, restrict access to certain hosts on the network level. </P>
<Figure id="LinkTarget_2615">

<ImageData src="images/4-Security Pattern Catalog_img_490.jpg"/>
Problem</Figure>

<P>Beside regular users, attackers can probe, access and misuse any system inside of the internal network. </P>

<P>It is unlikely that the access control facilities of all internal systems are activated and configured appropriately. In particular, out-of-the box installations offer standard services which can be misused by an attacker. Even if there are access restrictions it is unlikely that they are consistent, especially when more than one administrator is involved and there are no ``global''guidelines. </P>

<P>Even worse, we can assume that most internal systems are not hardened: experience shows that patches are not applied in time and that many, often unneeded services are running. This makes internal system also vulnerable to attacks at a rather low level: script-kiddies download exploitation software and conduct random attacks (not to speak of deliberate attacks carried out by an experienced attacker). </P>

<P>Another basic threat is that the overall network topology is visible, i. e. an attacker can analyze possible targets without further burden. </P>

<P>Furthermore, it might happen that attacks can not even be detected as one cannot ensure that the audit facilities of the internal systems are activated and configured appropriately. </P>

<P>Therefore, you should restrict the ingoing and outgoing traffic at the border between the internal and the external network. </P>

<P>The regular router has to be replaced with a firewall system (or extended accordingly)that implements the following functions: analysis, access control, filtering and modification. </P>

<P>The firewall must be able to analyze the messages which are sent through it. The analysis itself can be conducted in several ways which differ in parameters such as technical implementation, quality, or granularity. For example, it is possible to analyze the semantics of specific protocol headers, the different states of a protocol, or the relationship between several parallel connections. </P>

<P>Based on the information gathered before, a firewall will be able to make an access control decision. First, the message has to be identified somehow, e. g. by the identity of the user, the process Id of the corresponding application or network addresses. With the given information the firewall can now decide whether a particular message is dangerous or not (hereby, a set of rules is usually evaluated). Possible access control actions are to grant, reject, discard, or modify messages. </P>
<Figure id="LinkTarget_2616">

<ImageData src="images/4-Security Pattern Catalog_img_491.jpg"/>
Forces</Figure>

<P>The following forces contribute to the problem: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_492.jpg"/>
</Figure>

<Lbl>Authorized </Lbl>

<LBody>users want to be able to use the network without being hindered or blocked in doing their work. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_493.jpg"/>
</Figure>

<Lbl>Unauthorized </Lbl>

<LBody>users have to be denied access to the network. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_494.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>network can have multiple access points, making security policy enforcement hard. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_495.jpg"/>
</Figure>

<Lbl>We </Lbl>

<LBody>want to be able to provide a basic level of protection, even (especially?)with regard to unsecured and unpatched hosts. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_496.jpg"/>
</Figure>

<Lbl>Some </Lbl>

<LBody>services are intended for internal use only, we want to limit external access to these services (but keeping them accessible from the internal net). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_497.jpg"/>
</Figure>

<Lbl>Abusive </Lbl>

<LBody>network traffic, e. g. denial-of-service attacks, should be blocked at the perimeter of the network. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2617">

<ImageData src="images/4-Security Pattern Catalog_img_498.jpg"/>
Example</Figure>

<P>A real world example for a firewall is the guard of a prison in a more oppressive country. The guard can examine all letters for and from the prisoners. He is basically in a position to decide whether a letter is passed or not. </P>
<Figure id="LinkTarget_2618">

<ImageData src="images/4-Security Pattern Catalog_img_499.jpg"/>
Solution</Figure>

<P>An interceptor, the, is placed between the internal and external network. All incoming or outgoing connections pass through this host, i. e. it is a ``choke point''. The network administrator can then, by configuring the firewall with a policy, decide which network connections are allowed and which are not and enforce these decisions. </P>
<Figure id="LinkTarget_2619">

<ImageData src="images/4-Security Pattern Catalog_img_500.jpg"/>
Structure</Figure>

<P>Figure 1: Structure of a firewall, separating the internal from the external network. </P>

<P>The high-level structure of a firewall is shown in Figure 1 . In it, the external network (containing the external system)is separated from the internal network (containing the internal system). This forces all communication between the internal and external system to pass through the firewall. </P>

<P>The firewall contains a decision engine which is configured with a policy (provided by the network administrator). Depending on this policy and information gathered from the network level, the firewall will allow or deny certain communications between the internal and external system. </P>
<Figure id="LinkTarget_2620">

<ImageData src="images/4-Security Pattern Catalog_img_501.jpg"/>
Dynamics</Figure>

<P>Figure 2: Intercepting and allowing/denying a connection. </P>

<P>A graphical overview of the process of intercepting and allowing or disallowing a network connection is given in Figure 2 . </P>
<Figure id="LinkTarget_2621">

<ImageData src="images/4-Security Pattern Catalog_img_502.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_503.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Initiator is a network host that an be on the internal or the external network. This host initiates communications between itself and the service it wants to invoke by creating a new connection. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_504.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Firewall intercepts the connection before it is established, and then either allows its creation or prevents it from being established. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_505.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Service is a network host on the opposite side of the firewall; i. e. if the initiator is internal, then the service is external and vice versa. It offers a service to the initiator. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2622">

<ImageData src="images/4-Security Pattern Catalog_img_506.jpg"/>
Collaborations</Figure>

<P>The Initiator initiates a new Connection to the Service . This connection is intercepted by the Firewall , and then checked if it conforms to the firewall policy. If the connection is allowed, the firewall completes the connection and the Initiator is allowed to communicate with the Service . Otherwise, if the connection is not allowed, the Firewall terminates it. </P>
<Figure id="LinkTarget_2623">

<ImageData src="images/4-Security Pattern Catalog_img_507.jpg"/>
Implementation</Figure>

<P>Two implementation variants of a firewall are mentioned: the stateless firewall and the statefull firewall. In general, the stateless firewall is more performant and the statefull firewall is more advanced, i. e. it is able to make more intelligent decisions. </P>

<P>The stateless firewall does not take the state of the network connection into account. In the case of a TCP/IP network, for example, certain packets (either TCP or UDP)to and from a certain IP address and port are either allowed or disallowed. However, the stateless firewall is not able to distinguish a packet that belongs to a valid TCP connection from a ``rogue''packet. </P>

<P>The statefull firewall, on the other hand, maintains a table of current network connections and their state, i. e. (in the case of a TCP connection (description from the Linux manpage on netstat)): </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_508.jpg"/>
</Figure>
syn\_sent The socket is actively attempting to establish a connection. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_509.jpg"/>
</Figure>
syn\_recv A connection request has been received from the network. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_510.jpg"/>
</Figure>
established The socket has an established connection. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_511.jpg"/>
</Figure>
fin\_wait1 The socket is closed, and the connection is shutting down. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_512.jpg"/>
</Figure>
fin\_wait2 Connection is closed, and the socket is waiting for a shutdown from the remote end. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_513.jpg"/>
</Figure>
time\_wait The socket is waiting after close to handle packets still in the network. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_514.jpg"/>
</Figure>
closed The socket is not being used.This statefull information allows the statefull firewall to distinguish packets that belong to an active connection from other packets, enabling it to make more intelligent enforcement decisions. </P>
<Figure id="LinkTarget_2624">

<ImageData src="images/4-Security Pattern Catalog_img_515.jpg"/>
Pitfalls</Figure>

<P>Before deploying a firewall, the network administrator must be aware of the following pitfalls: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_516.jpg"/>
</Figure>

<Lbl>Since </Lbl>

<LBody>the firewall operates on the network level, it is application-agnostic. While this design decision keeps the firewall platform and application independent, it also entails that the firewall is unaware of the events on the application level: an allowed connection can still contain malicious traffic, such as buffer overflows or SQL injections. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_517.jpg"/>
</Figure>

<Lbl>While </Lbl>

<LBody>certain protocols are commonly associated with a known range of ports (i. e. HTTP connections are TCP connections to port80), this need not be the case: an HTTP service could be configured to listen to another port as well. As such, blocking connections to and from a certain port is no guarantee that communication using this protocol is prevented. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_518.jpg"/>
</Figure>

<Lbl>Certain </Lbl>

<LBody>protocols, such as FTP, use different connections for transmitting both data and control sequences. It can be particularly tricky to write policies that enforce control over these protocols correctly. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_519.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>firewall is impaired by a reverse proxy (or potentially all non-transparent intermediaries), as the network connections do not appear to be originating from the proxied servers anymore, but from the proxy itself. The firewall should be positioned so that it is able to make the necessary distinctions between authorized and unauthorized connections. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2625">

<ImageData src="images/4-Security Pattern Catalog_img_520.jpg"/>
Consequences</Figure>

<P>The consequences of applying a firewall between two networks can be summarized as follows: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_521.jpg"/>
</Figure>
Accountability: As a firewall analyzes all messages which pass through it, rather fine-grained log information can be generated easily. Thus it is possible to detect possible attacks and to hold regular users responsible for their actions. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_522.jpg"/>
</Figure>
Availability: A firewall also helps to increase the availability of internal systems as the ``attack surface''is made smaller significantly. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_523.jpg"/>
</Figure>
Confidentiality/Integrity: As there is an additional line of defense, the confidentiality and integrity of information hosted at the internal systems is increased, too. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_524.jpg"/>
</Figure>
Manageability: A firewall is an additional, complex component of the network infrastructure. Thus, the efforts for managing the network are higher. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_525.jpg"/>
</Figure>
Usability: Integrating a firewall often requires to change applications or the users behavior. In either way, a firewall has an impact on the usability. </P>

<P>Performance: The analysis and access control decision process consumes additional processing time. Thus, every firewall decreases the performance. Especially in high-bandwidth environments, this is an important issue. Cost: There will be additional costs for setting up and maintaining a firewall. </P>
<Figure id="LinkTarget_2626">

<ImageData src="images/4-Security Pattern Catalog_img_526.jpg"/>
Knownuses</Figure>

<P>Some widely deployed firewalls are, Linux'IPTABLES, IPFW and PF from the BSD family. </P>

<P id="LinkTarget_2627">Full View with Errors </P>
<Figure id="LinkTarget_2628">

<ImageData src="images/4-Security Pattern Catalog_img_527.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Prevent users to perform illegal operations by showing an error message when the user tries to perform an illegal operation. </P>

<P>Aliases: Full View With Exceptions, Reveal All and Handle Exceptions, Notified View </P>
<Figure id="LinkTarget_2629">

<ImageData src="images/4-Security Pattern Catalog_img_528.jpg"/>
Problem</Figure>

<P>Users should not be allowed to perform illegal operations. </P>
<Figure id="LinkTarget_2630">

<ImageData src="images/4-Security Pattern Catalog_img_529.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_530.jpg"/>
</Figure>

<Lbl>Users </Lbl>

<LBody>may be confused when some options are either not present or disabled. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_531.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>options pop in and out depending upon roles, the user may get confused on what is available. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_532.jpg"/>
</Figure>

<Lbl>Users </Lbl>

<LBody>should not be able to see operations they are not allowed to do. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_533.jpg"/>
</Figure>

<Lbl>Users </Lbl>

<LBody>should not view data they do not have permissions for. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_534.jpg"/>
</Figure>

<Lbl>Users </Lbl>

<LBody>do not like being told what they cannot do. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_535.jpg"/>
</Figure>

<Lbl>Users </Lbl>

<LBody>get annoyed with security errors, permission denied, and illegal operation messages. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2631">

<ImageData src="images/4-Security Pattern Catalog_img_536.jpg"/>
Example</Figure>

<P>(Non-security)Once an officer is allowed on a military base, he or she could go to any building on the base. In effect, the officer has a full view of the buildings on the base. If the officer tries to enter a restricted area without proper clearance, either someone would stop and check them noting that they are not allowed in the restricted area, or alarms would sound and guards would show up to arrest the officer. </P>

<P>Graphical applications often provide many ways to view data. Users can dynamically choose which view on which data they want. When an application has these multiple views, the developer must always be concerned with which operations are legal given the current state of the application and the privileges of the user. The conditional code for determining whether an operation is legal can be very complicated and difficult to test. By giving the user a complete view to what all users have access to can make teaching how to use the system easier and can make for more generic GUIs. </P>
<Figure id="LinkTarget_2632">

<ImageData src="images/4-Security Pattern Catalog_img_537.jpg"/>
Solution</Figure>

<P>Design the application so users see everything that they might have access to. When a user tries to perform an operation, check if it is valid. Notify them with an error message when they perform illegal operations. </P>

<P>This pattern is very useful when a user can perform almost any operation. It is easier to show the user everything and just provide an error message when an illegal operation is attempted. </P>

<P>The solution for this pattern is simple when only a few error message need to be displayed. Just display the error message to standard error or in a dialog box. If many error messages are spread throughout the application, a separate error reporting mechanism may be useful. This mechanism could also be used for error logging. </P>

<P>Typically, an error-reporting framework would have two principal components. The log event object has a message describing the error condition and a severity level indicating if the event is a warning, an error, or just user information. When a log event is created it can automatically register itself with the logger. The logger is a Singleton that automatically receives and processes log events. The logger can be configured to display dialogs or write to a file depending on the severity of the event. </P>
<Figure id="LinkTarget_2633">

<ImageData src="images/4-Security Pattern Catalog_img_538.jpg"/>
Structure</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_539.jpg"/>
</Figure>

<P>Figure 1: Structure of the Full View with Errors pattern. </P>

<P>See Figure 1 for an overview of the pattern when a separate error reporting mechanism is used. When no such mechanism is used, the user interface itself incorporates the logger functionality. </P>
<Figure id="LinkTarget_2634">

<ImageData src="images/4-Security Pattern Catalog_img_540.jpg"/>
Dynamics</Figure>

<P>Figure 2: Event sequence for the Full View with Errors pattern. </P>

<P>See Figure 2 for an overview of the event sequence when a separate error reporting mechanism is used. When no such mechanism is used, the user interface itself incorporates the logger functionality. </P>
<Figure id="LinkTarget_2635">

<ImageData src="images/4-Security Pattern Catalog_img_541.jpg"/>
Participants</Figure>

<P>See also Figure 1 . </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_542.jpg"/>
</Figure>

<Lbl>User </Lbl>

<LBody>Interface The user interface is responsible for offering all operations to the user. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_543.jpg"/>
</Figure>

<Lbl>Logger </Lbl>

<LBody>The logger is responsible of taking appropriate action when a log event is </LBody>
</LI>
</L>
<Figure id="LinkTarget_2636">

<ImageData src="images/4-Security Pattern Catalog_img_544.jpg"/>
Collaborations</Figure>

<P>See also Figure 2 . </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_545.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>user performs an operation using the user interface. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_546.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>user interface validates whether the execution of the operation should be allowed or not. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_547.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>the operation is allowed, the user interface executes the operation and possibly returns the result to the user. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_548.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>the operation is disallowed, the user interface notifies the logger of the failure. The logging component then takes appropriate action (for example based on the severity of the failure). This action may be displaying a notification to the user or logging the event to a file. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2637">

<ImageData src="images/4-Security Pattern Catalog_img_549.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2638">

<ImageData src="images/4-Security Pattern Catalog_img_550.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2639">

<ImageData src="images/4-Security Pattern Catalog_img_551.jpg"/>
Consequences</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_552.jpg"/>
</Figure>

<Lbl>Training </Lbl>

<LBody>materials for the application are consistent for each type of user. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_553.jpg"/>
</Figure>

<Lbl>Retrofitting </Lbl>

<LBody>this pattern into an existing system is straightforward. Just write a GUI that will handle all options and whenever a problem happens with an operation, simply exit the operation and open an error dialog. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_554.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>is easier to dynamically change privileges on an operation because authorization is performed when the operation is attempted. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_555.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>is easier to implement since you don't have to have multiple views on the data. This also improves maintainability. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_556.jpg"/>
</Figure>

<Lbl>Users </Lbl>

<LBody>may get confused with a constant barrage of error dialogs. This hampers usability. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_557.jpg"/>
</Figure>

<Lbl>Operation </Lbl>

<LBody>validation can be more difficult when users can perform any operation. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_558.jpg"/>
</Figure>

<Lbl>Users </Lbl>

<LBody>will get frustrated when they see options that they cannot perform. This also decreases usability. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2640">

<ImageData src="images/4-Security Pattern Catalog_img_559.jpg"/>
Knownuses</Figure>

<P>Full View with Errors is used in Oracle databases. When you are using SQLPlus to access the data, you can execute any command. However, if you try to access data you don't have permission to see, an appropriate error message will be displayed. </P>

<P>Login windows inform users when they enter incorrect passwords. </P>

<P>Most word processors and text editors, including Microsoft Word and vi, let the user try to save over a read-only file. The program displays an error message after the save has been attempted and has failed. </P>

<P>Reuters SSL Developers Kit has a framework for reporting error, warning, and information events. It can be configured to report errors to standard error, a file, or a system dependent location such as a dialog. </P>

<P id="LinkTarget_2641">Input Guard </P>
<Figure id="LinkTarget_2642">

<ImageData src="images/4-Security Pattern Catalog_img_560.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Protect components from input that does not conform to the system specification. </P>
<Figure id="LinkTarget_2643">

<ImageData src="images/4-Security Pattern Catalog_img_561.jpg"/>
Problem</Figure>

<P>The Input Guard pattern applies to a system which has the following characteristics: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_562.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>system is composed from distinguishable components, which can play the role of fault compartments and which interact with each other by feeding one's output into another's input. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_563.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>errors that can be propagated into a system component have the form of erroneous input, i. e. input whose content or timing does not conform to the system specification.The second characteristic implies that internal errors (e. g. changes to the internal state due to electromagnetic disturbances in the environment where the system operates)are not considered by this pattern since they are not expressed as erroneous input according to the system specification. Moreover, this pattern does not deal with cases where the input to the system conforms with the system specification but it still contains errors according to the specification of the system's environment. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2644">

<ImageData src="images/4-Security Pattern Catalog_img_564.jpg"/>
Forces</Figure>

<P>In the above context, the Input Guard pattern solves the problem of stopping the propagation of an error from the outside to the inside of the guarded component by balancing the following forces: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_565.jpg"/>
</Figure>

<Lbl>Input </Lbl>

<LBody>that does not conform to the specification of the receiving component must be identified. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_566.jpg"/>
</Figure>

<Lbl>Different </Lbl>

<LBody>systems have different requirements regarding size impact of the fault containment mechanism. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_567.jpg"/>
</Figure>

<Lbl>Different </Lbl>

<LBody>systems have different requirements regarding the time penalty of the fault containment mechanism. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_568.jpg"/>
</Figure>

<Lbl>Fault </Lbl>

<LBody>containment is usually integrated with other solutions provided for other fault tolerance constituents (e. g. error masking, error detection, fault diagnosis and the others mentioned in Section1)in order to provide wider fault tolerance guarantees. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2645">

<ImageData src="images/4-Security Pattern Catalog_img_569.jpg"/>
Example</Figure>

<P>A system S consists of two components A and B. Component A takes as input two pairs of integers and provides as output a pair of integers representing the sum of the first and the second input pair. Component B takes as an argument a pair of integers and provides as output one integer representing the integer quotient of the division of the first input integer by the second one. The specification of component B imposes that both input values must be integers and the second input value cannot be zero. Component A receives its input form the user and feeds its output to component B, which in turn delivers its output to the user (see Figure 1 ). </P>

<P>Now, let's suppose that the system S is fed with with the following two pairs of integers (10,20)and (2,4). This input is legitimate according to the specification of system S and the expected output is5. The input pairs of integers are also legitimate input for the component A and the expected output is the pair (30,6). Figure1shows the case where an error has occurred inside component A and as a result the output (60,6)is delivered, which is erroneous according to the specification of component A. Notice however that the same pair is not erroneous input for the component B according to its specification (both60and6are integers and6does not equal zero). Hence, applying the Input Guard pattern on component B would not prevent the propagation of this error inside B. This kind of error can be contained inside the component that produced it (i. e. A)by applying theon component A. </P>
<Figure id="LinkTarget_2646">

<ImageData src="images/4-Security Pattern Catalog_img_570.jpg"/>
Solution</Figure>

<P>To stop erroneous input from propagating the error inside a component a guard is placed at every access point of the component to check the validity of the input. Every input to the guarded component is checked by the guard against the component specification. If and only if the input conforms with that specification then it is forwarded to the guarded component. </P>

<P>Notice that the above solution does not define the behavior of the guard in the presence of erroneous input, besides the fact that it does not forward it to the guarded component. This is intentionally left undefined in order to allow implementations of the Input Guard to be combined with error detection mechanisms (e. g. when a check fails, an error notification is sent to the part of the system responsible for fault diagnosis)or with the implementations of error masking mechanisms (e. g. the comparator entity of the Active Replication pattern). Hence, the behavior of the guard when the checks performed on the input fail depends on the other fault tolerance constituents with which the input guard is combined. </P>
<Figure id="LinkTarget_2647">

<ImageData src="images/4-Security Pattern Catalog_img_571.jpg"/>
Structure</Figure>

<P>Figure 1 (a)illustrates graphically the structure of the Input Guard pattern for a guarded component with a single access point. Figure 1 (b)contains the activity diagram that describes the functionality of the guard. </P>
<Figure id="LinkTarget_2648">

<ImageData src="images/4-Security Pattern Catalog_img_572.jpg"/>
Dynamics</Figure>

<P>Figure 1: The structure [a]and the activity diagram [b]of the Input Guard pattern. </P>

<P>See Figure 1 . </P>
<Figure id="LinkTarget_2649">

<ImageData src="images/4-Security Pattern Catalog_img_573.jpg"/>
Participants</Figure>

<P>The Input Guard pattern introduces two entities: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_574.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>guarded component which is the part of the system that is protected against the fault contamination from external errors propagated to it through its input. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_575.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>guard which is responsible to check for errors the input to the guarded component against its specification.There may be many instances of the guard entity for the same guarded component, depending on the system design and on the number of different access points the guarded component may have. For example, a software component with a number of interfaces and a number of operations declared in each interface may have one guard per interface or one guard per operation declared in its interfaces or any possible combination of those. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2650">

<ImageData src="images/4-Security Pattern Catalog_img_576.jpg"/>
Collaborations</Figure>

<P>When the Guarded Component receives input from the environment, the Guard intercepts the input. The input is then checked against a specification of the interface of the Guarded Component , to see if the input is indeed valid input for the component. If the input is valid, it is forwarded to the Guarded Component . If not, the input is dropped. </P>
<Figure id="LinkTarget_2651">

<ImageData src="images/4-Security Pattern Catalog_img_577.jpg"/>
Implementation</Figure>

<P>One possibility is to implement the guards as separate components in the system. This approach allows to have a number of guards proportional only to the number of the access points of the guarded component. The time overhead introduced by this approach is quite high since it includes the invocation of an additional component (i. e. the guard). Also, the space overhead of this approach is rather elevated since it increases the number of the components in a system by the number of guards that are implemented. Furthermore, in the case where components are mapped to individual units of failure (i. e. each component can fail as a whole and independently of other components)this approach introduces a well-known dilemma in fault tolerance: ``QUIS CUSTODIET IPOS CUSTODES?''(``who shall guard the guards?''). </P>

<P>Despite the above inconveniences, this implementation approach is valuable in the case of COTS-based systems composed from black-box components where the system composer does not have access to the internals of the components. Also, this approach can be applied when fault containment comes as a late-or after-thought in the system development and a quick fix is needed in form of a patch. This implementation approach does not require any modification on existing components of a system; rather, guards are introduced as separate add-on components to the existing system. </P>

<P>Another implementation approach is to make the guard part of the implementation of the guarded component. This practice is often employed in programming where a method checks its arguments before using them to perform its designated task. This allows the coupling of the guard (s)and the guarded component. By integrating the guard with theguarded component the space overhead of the Input Guard implementation is kept low since it does not introduce another component in the system. Coupling the guard and guarded component implementation is usually applied in the development of COTS software where the developer has no knowledge about the rest of the system in which the component will be integrated. Hence, in order to assure robust functioning of a component, the developer checks the input of the component on every call. The drawback of this implementation approach is the fact that the time overhead is high and fixed. This is because the guard is engaged on every call to the guarded component, even when the supplied input has already been checked by other fault tolerance means. </P>

<P>A third implementation possibility is to place the guard inside each of the components which may provide input to the guarded component. This approach allows the integration of the guard with other fault tolerance mechanisms (e. g. the guard of the Output Guard pattern for each component that provides input to the guarded component; see Section3for more details). Furthermore, this approach allows the elimination of redundant checks for errors which can increase the time and space overhead of fault tolerance solutions in a system. On the other hand, this approach is not applicable to COTS software. Third party developers may not have information about the specification of the other components to which they will feed their output, hence they do not know what conditions to check in the guard. A drawback of this implementation approach is the elevated space overhead; the number of guards is not only proportional to the access points of the guarded component but also to the number of components that provide input to the guarded component. Another drawback is that this guard cannot protect the guarded component from communication errors that occurred during the forward of the checked input from the guard to the guarded component. On the positive side however, this approach allows the guard to be selectively integrated only with those components that considered not robust enough and subject to produce erroneous input for the guarded component. This can be used to reduce the elevated space overhead of the approach. </P>
<Figure id="LinkTarget_2652">

<ImageData src="images/4-Security Pattern Catalog_img_578.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2653">

<ImageData src="images/4-Security Pattern Catalog_img_579.jpg"/>
Consequences</Figure>

<P>The Input Guard pattern has the following benefits: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_580.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>stops the contamination of the guarded component from erroneous input that does not conform to the specification of the guarded component. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_581.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>undefined behavior of the guard in the presence of errors allows its combination with error detection and error masking patterns, and fault diagnosis mechanisms. Whenever this is applicable, the system benefits in terms of reduced run-time overhead introduced by the implementation of the fault tolerant mechanism (e. g. the combination of fault containment and error detection in the context of system recovery from errors). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_582.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>similarities between the guard entities of the Input Guard pattern and Output Guard pattern (see Section3)allow the combination of the two in a single entity. This entity will operate on the same data and will perform two checks: one against the specification of the component that produced the data as output and the other against the specification of the component that will consume the data as input. When applicable, this combination can provide significant benefits in terms of time and space overhead since two separate checks will be performed by the same piece of code. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_583.jpg"/>
</Figure>

<Lbl>There </Lbl>

<LBody>are various ways that the Input Guard pattern can be implemented, each providing different benefits with respect to the time or space overhead introduced by the guard. It is also possible to integrate the guard with an existing system without having to modify the internals of the system components (first implementation alternative). That reduces significantly the amount of system re-engineering required for applying the Input Guard pattern to COTS-based systems made of black-box components.The Input Guard pattern imposes also some liabilities: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_584.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>is not possible to minimize both the time and the space overhead of this pattern. To keep low the time overhead introduced by the Input Guard pattern, the functionality of the guard must not be very time consuming. This results in a tendency to introduce a separate guard for each different access point (e. g. one guard per interface or even per operation declared in an interface)of the guarded component. Each such guard checks only a small part of the specification of the guarded component, minimizing thus the execution time of an individual guard. However, this results in a large number of guards, hence in an elevated space overhead. On the other hand, to keep low the space overhead introduced by the Input Guard pattern, the number of guards needs to remain as small as possible. This implies that each guard will have to check a lager number of input for the guarded component, becoming a potential bottleneck and thus penalizing the performance of the system with elevated time overhead. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_585.jpg"/>
</Figure>

<Lbl>For </Lbl>

<LBody>certain systems that require guards to be implemented as components (e. g. systems composed from black-box COTS software), the Input Guard pattern results unavoidably to an elevated time and space overhead. The space overhead is due to the introduction of the new components implementing the guards. The time overhead is due to the fact that passing input to the guarded component requires one additional indirection through the component implementing the guard that check the given input. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_586.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Input Guard pattern cannot prevent the propagation of errors that do conform with the specification of the guarded component. Such errors may contaminate the state of the guarded component if it has one. Although these errors cannot cause a failure on the guarded component since it operates according to its specification, they can cause a failure on the rest of the system. Such a failure of the entire system will be traced back to an error detected in the contaminated guarded component. Unless the error detection and fault diagnosis capabilities of the system allow to continue tracing the error until the initial fault that caused it, it is possible that inappropriate recovery actions will be taken targeted only at the guarded component, which, nonetheless, has been operating correctly according to its specification. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_587.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Input Guard pattern can effectively protect a component from being contaminated by erroneous input according to its specification. However, unless it is combined with some error detection and system recovery mechanisms, this pattern will result in a receive-omission failure (i. e. failure to receive input)of the guarded component. For certain systems, such a failure of one of their components may cause a failure on the entire system. Hence, the Input Guard pattern has limited applicability to such systems if it is not combined with other fault tolerance patterns. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2654">

<ImageData src="images/4-Security Pattern Catalog_img_588.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2655">Replicated System </P>
<Figure id="LinkTarget_2656">

<ImageData src="images/4-Security Pattern Catalog_img_589.jpg"/>
Patterndocumentation</Figure>
<Figure id="LinkTarget_2657">

<ImageData src="images/4-Security Pattern Catalog_img_590.jpg"/>
Quickinfo</Figure>

<P>Intent: Structure a system which allows provision of service from multiple points of presence, and recovery in case of failure of one or more components or links. </P>

<P>Aliases: Redundant Components, Horizontal Scalability </P>
<Figure id="LinkTarget_2658">

<ImageData src="images/4-Security Pattern Catalog_img_591.jpg"/>
Problem</Figure>

<P>Transactional systems often susceptible to outages because of failure of communication links, communication protocols, or other system elements. Nevertheless, it is important to assure availability of transaction services in the face of such failures. </P>
<Figure id="LinkTarget_2659">

<ImageData src="images/4-Security Pattern Catalog_img_592.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_593.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>system's state is updated via a series of individual transactions. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_594.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>completion state and result of each transaction must be accurately reflected in the system state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_595.jpg"/>
</Figure>

<Lbl>Equivalent </Lbl>

<LBody>services must be provided simultaneously from multiple ``points of presence'', each of which must rely on and consistently update the same system state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_596.jpg"/>
</Figure>

<Lbl>Link </Lbl>

<LBody>failures are more likely than component failures. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_597.jpg"/>
</Figure>

<Lbl>Each </Lbl>

<LBody>point of presence can be provided with reliable access to a master copy of the system state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_598.jpg"/>
</Figure>

<Lbl>Operational </Lbl>

<LBody>procedures call for a service to be periodically relocated from one platform or site to another, and brief pauses in processing for the purpose of relocation are acceptable. (Relocation might be desired to match the point of provision of the service to the locality of the offered load, or when the service may need to be relocated to a more capable (``larger'')platform to meet peak load demands.)Service must continue to be provided in the face of component or link failures. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2660">

<ImageData src="images/4-Security Pattern Catalog_img_599.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2661">

<ImageData src="images/4-Security Pattern Catalog_img_600.jpg"/>
Solution</Figure>

<P>Replicated System consists of two or more Replicas and a Workload Management Proxy which distributes work among the components. The Replicas must all be capable of performing the same work. The Replicas may be stateless or stateful. If they are stateful, they may be allowed to be inconsistent. If the Replicas are stateful and must be kept consistent, the Standby pattern may be used to ensure consistency of state across components. </P>
<Figure id="LinkTarget_2662">

<ImageData src="images/4-Security Pattern Catalog_img_601.jpg"/>
Structure</Figure>

<P>Figure 1: Structure of the Replicated System. </P>

<P>See Figure 1 . </P>
<Figure id="LinkTarget_2663">

<ImageData src="images/4-Security Pattern Catalog_img_602.jpg"/>
Dynamics</Figure>

<P>Figure 2: Event sequence of the Replicated System. </P>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2664">

<ImageData src="images/4-Security Pattern Catalog_img_603.jpg"/>
Participants</Figure>

<P>The relations between the participants are shown in Figure 1 . The participants and their responsabilities are: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_604.jpg"/>
</Figure>

<Lbl>Replica </Lbl>

<LBody>Implements operations. All Replicas in a replicated system must support the same set of operations. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_605.jpg"/>
</Figure>

<Lbl>Workload </Lbl>

<LBody>Management Proxy Dispatches operations to components based on workload scheduling algorithm. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2665">

<ImageData src="images/4-Security Pattern Catalog_img_606.jpg"/>
Collaborations</Figure>

<P>The interactions between the participants are shown in Figure 2 . </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_607.jpg"/>
</Figure>

<Lbl>Workload </Lbl>

<LBody>Management Proxy responds to requests for operations. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_608.jpg"/>
</Figure>

<Lbl>Workload </Lbl>

<LBody>Management Proxy dispatches operation requests to Replicas which are best able to handle them. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2666">

<ImageData src="images/4-Security Pattern Catalog_img_609.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2667">

<ImageData src="images/4-Security Pattern Catalog_img_610.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2668">

<ImageData src="images/4-Security Pattern Catalog_img_611.jpg"/>
Consequences</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_612.jpg"/>
</Figure>

<Lbl>Improves </Lbl>

<LBody>system tolerance to component failures. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_613.jpg"/>
</Figure>

<Lbl>Improves </Lbl>

<LBody>system ability to handle distributed load and link failures. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_614.jpg"/>
</Figure>

<Lbl>Makes </Lbl>

<LBody>the Workload Management Proxy a single point of failure; may make the persistent data store a single point of failure. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_615.jpg"/>
</Figure>

<Lbl>Making </Lbl>

<LBody>sure that the replica's are real replica's (i. e., they would respond identically to each request at all times)can be hard. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2669">

<ImageData src="images/4-Security Pattern Catalog_img_616.jpg"/>
Knownuses</Figure>

<P>Network Load Balancers (fronting replicated Web Servers, for example)are instances of the Replicated System pattern. </P>

<P id="LinkTarget_2670">Reverse Proxy </P>
<Figure id="LinkTarget_2671">

<ImageData src="images/4-Security Pattern Catalog_img_617.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Protect your web server infrastructure on an application protocol level, without hindering accessibility. </P>
<Figure id="LinkTarget_2672">

<ImageData src="images/4-Security Pattern Catalog_img_618.jpg"/>
Problem</Figure>

<P>Putting a web server or an application server directly on the Internet gives attackers direct access to any vulnerabilities of the underlying platform (application, web server, libraries, operating system). However, to provide a useful service to Internet users, access to your server is required. Firewalls shield your server from attacks on the network level, but a Security Reverse Proxy protects also on an application protocol level. </P>
<Figure id="LinkTarget_2673">

<ImageData src="images/4-Security Pattern Catalog_img_619.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_620.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>simple firewall is not enough to protect your web server, since some access must be provided to the Internet. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_621.jpg"/>
</Figure>

<Lbl>Attack </Lbl>

<LBody>scenarios often employ extra long, or extra crafted request parameters to exploit buffer overflows. Most firewalls work on the network packet level and cannot prohibit attacks using such invalid requests. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_622.jpg"/>
</Figure>

<Lbl>Installing </Lbl>

<LBody>patches to your web server platform helps to avoid exploitation of known vulnerabilities. But with each patch you risk that your system extensions cease to work. You need to rerun your integration tests at each patch level and might need to keep your extensions up to date with each patch level. It might even be impossible to upgrade your web server in a timely manner, because the extensions aren't ready. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_623.jpg"/>
</Figure>

<Lbl>Switching </Lbl>

<LBody>to another web server software by a different source is expensive, risky and time consuming, too. A new web server might have fewer vulnerabilities, but you are less familiar with it. In addition it might also require to adapt your own system extensions. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_624.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>cannot know about vulnerabilities detected in the future. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2674">

<ImageData src="images/4-Security Pattern Catalog_img_625.jpg"/>
Example</Figure>

<P>You are running your web site using a major software vendorÂ¿s web server software. Your web site uses this vendor's proprietary extensions to implement dynamic content for your visitors and you have invested heavily in your website's software. Your server is protected by a regular firewall. </P>

<P>You must open this firewall to allow access to the public port (80)of your web server. Attacks from the Internet exploiting vulnerabilities of your server software burden your system administrator with installing patches frequently. Switching to another vendor's web server is not possible because of the existing investment in the web server platform, its content and your own software extensions. In addition, with every new patch you install, you run the risk of destabilizing your configuration so that your system extensions cease to work, that your software extensions cease to work. How can you escape the dilemma to keeping your web site up without compromising its security and integrity? </P>
<Figure id="LinkTarget_2675">

<ImageData src="images/4-Security Pattern Catalog_img_626.jpg"/>
Solution</Figure>

<P>Change your network topology to use a protection reverse proxy that shields your real web server. Configure this reverse proxy to filter all requests, so that only (mostly)harmless requests will reach the real web server. Two firewalls ensure that no external network traffic reaches the real web server. The resulting network topology provides a demilitarized zone (DMZ)containing only the reverse proxy machine and a secured server zone containing the web server. </P>
<Figure id="LinkTarget_2676">

<ImageData src="images/4-Security Pattern Catalog_img_627.jpg"/>
Structure</Figure>

<P>The structure of a reverse proxy is depicted in Figure 1 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_628.jpg"/>
</Figure>

<P>Figure 1: Reverse proxy structure. </P>
<Figure id="LinkTarget_2677">

<ImageData src="images/4-Security Pattern Catalog_img_629.jpg"/>
Dynamics</Figure>

<P>The dynamics of a Reverse Proxy are included in Figure 2 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_630.jpg"/>
</Figure>

<P>Figure 2: Reverse proxy dynamics. </P>
<Figure id="LinkTarget_2678">

<ImageData src="images/4-Security Pattern Catalog_img_631.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_632.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>outer firewall filters incoming network traffic and allows only HTTP port access to the Reverse Proxy. Furthermore, it denies outbound connection from the Reverse Proxy to the Internet. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_633.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>reverse proxy accepts requests from browsers and forwards only valid requests to the backend server. Furthermore, it passes the reply from the backend server back to the originating browser. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_634.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>inner firewall separates the server zone from the DMZ. It denies inbound connections except from the Reverse Proxy and denies outbound connection from the backend servers. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_635.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>backend server provides the real web service. It accepts requests from the reverse proxy and returns replies. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_636.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>client connects to the reverse proxy. This connection is intercepted by the outer firewall, and checked against the firewall configuration to see if it is allowed to be established. We refer to thepattern for additional info. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_637.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>the outer firewall allows the connection, the reverse proxy then checks if the connection contains a valid request for the backend server. If not, the request of the client is denied. Otherwise, the reverse proxy forwards the request to the backend server. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_638.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>inner firewall intercepts and checks the connection from the reverse proxy to the backend server, and ensures that the connection originates from the proxy (i. e., no other external parties are allowed to communicate with the backend server directly). Again, we refer to thepattern. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_639.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>backend server receives the request of the client, acts accordingly, and returns a response. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2679">

<ImageData src="images/4-Security Pattern Catalog_img_640.jpg"/>
Collaborations</Figure>
<Figure id="LinkTarget_2680">

<ImageData src="images/4-Security Pattern Catalog_img_641.jpg"/>
Implementation</Figure>

<P>To implement the Security Reverse Proxy several tasks need to be done: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_642.jpg"/>
</Figure>

<Lbl>Plan </Lbl>

<LBody>your firewall and network configuration. Even if the firewall update is done after every other part is in place, it is good to start with a plan, so that configuration of the other components can rely on the firewall plan. Often the concrete configuration needs to consider more than just one protocol and some explicit ``holes''in your firewall may be needed. Find out what protocol your reverse proxy solution needs to support. Typically only HTTP (port80)is needed, but you might want to allow other protocols as well through your reverse proxy. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_643.jpg"/>
</Figure>

<Lbl>Select </Lbl>

<LBody>a Reverse Proxy platform. You might create your own reverse proxy, for example by configuring the Apache web server with mod\_rewrite and mod\_proxy modules, several vendors offer professional reverse proxy solutions, or you </LBody>
</LI>
</L>

<P>py ppyy might be brave and implement your own reverse proxy. Showing the details of implementing your own reverse proxy server software is beyond the scope of this pattern. If your reverse proxy needs to support more specialized or seldom used protocols, building one yourself might be the only option. When selecting a vendor or source for your security reverse proxy you should opt for a simple and proven solution. For example, using Apache you risk all Apache web server vulnerabilities to be present in your security reverse proxy. On the other hand, the Apache web server is deployed so often, that most vulnerabilities and countermeasures are known. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_644.jpg"/>
</Figure>
Configure your backend web server (s). The web content should rely on relative path names and not use its internal name or IP address to refer to itself. Otherwise, links might not work, because the browser can no longer directly access the machine it is running on. </P>

<L>
<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_645.jpg"/>
</Figure>

<Lbl>Configure </Lbl>

<LBody>your Security Reverse Proxy. For the security to work, you need to define what requests should be mapped towards your backend web server, and define what to happen if invalid requests occur. For example, you might want to log what request were denied by the reverse proxy. For request filtering there exists two approaches: black lists and white lists. </LBody>
</LI>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_646.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>black list filter only blocks requests that its list of malicious requests knows of, but passes on all others. Black list filters are easier to deploy but riskier. They are often used by ``higher-level''firewalls. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_647.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>white list filter is more restrictive and only lists allowed requests. It needs to be configured with detailed knowledge of the backend server and allowed URLs. A white list filter needs to be adapted every time your backend server changes significantly in its URL space. Nevertheless, it is the better choice for a Security Reverse Proxy.If your backend server relies on redirects or other mechanisms using its host address and you cannot change that, you need to configure your reverse proxy to modify server responses accordingly. </LBody>
</LI>
</L>
</L>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_648.jpg"/>
</Figure>

<Lbl>Deploy </Lbl>

<LBody>everything. Initial deployment with setting up firewalls, network and routers, host IP addresses and so on requires good planning. If you have something up and running already, this reconfiguration might mean some service interruption. Nevertheless, later changes to the topology need only consider the reverse proxy and eventually the inner firewall. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2681">

<ImageData src="images/4-Security Pattern Catalog_img_649.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2682">

<ImageData src="images/4-Security Pattern Catalog_img_650.jpg"/>
Consequences</Figure>

<P>The pattern implies the following benefits: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_651.jpg"/>
</Figure>

<Lbl>Your </Lbl>

<LBody>backend server is protected. Attackers can no longer directly exploit vulnerabilities of the backend server. Even when the backend server gets compromised, the firewalls hinder further spreading of Internet worms, etc., by blocking outgoing requests from the backend server. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_652.jpg"/>
</Figure>

<Lbl>Even </Lbl>

<LBody>with known vulnerabilities, you might be able to keep your web server configuration stable, because the Security Reverse Proxy with its request filtering can prohibit exploitation of the web server's vulnerabilities. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_653.jpg"/>
</Figure>

<Lbl>Easier </Lbl>

<LBody>patch administration. Only one machine remains connected to the Internet directly and needs to be monitored for potential vulnerabilities and existing patches to be applied. However, you cannot blindly trust your Security Reverse Proxy. A backend server still needs to be configured with your brain on, to avoid exploitation of vulnerabilities with ``allowed''requests.However, the Security Reverse Proxy pattern also has its liabilities: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_654.jpg"/>
</Figure>

<Lbl>Black </Lbl>

<LBody>list filtering can give you a false sense of security. Like patches, black lists can only be constructed after a vulnerability is known. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_655.jpg"/>
</Figure>

<Lbl>White </Lbl>

<LBody>list filtering can be fragile, when backend servers change. Adding functionality, or re-arranging content structure on the backend web server, can imply additional work to re-configure the white list filter of the Security Reverse Proxy. </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_656.jpg"/>
</Figure>
Latency. A reverse proxy adds latency to the communication, not only because of the additional network traffic, but also for the filtering and validation of requests. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_657.jpg"/>
</Figure>

<Lbl>Some </Lbl>

<LBody>loss of transparency. Some restrictions are imposed on the backend servers. However, these are typically good practice anyway, like relative paths in URLs. Nevertheless, the backend servers no longer see the communication end partner directly on the network level. So the protocol may need to provide a means to identify the original communication end point (which HTTP allows). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_658.jpg"/>
</Figure>

<Lbl>Additional </Lbl>

<LBody>point of failure. If the reverse proxy stops working, also any access to your web site is impossible. Any additional component that can fail increases the overall risk of system failure. To reduce this risk, you can provide a hot or cold stand by installation with hardware or software fail-over switches. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2683">

<ImageData src="images/4-Security Pattern Catalog_img_659.jpg"/>
Knownuses</Figure>

<P>Security Reverse Proxies are popular. Some organizations in the financial industry have the guideline to use a reverse proxy for every protocol provided over the Internet (with some exceptions, like DNS). Thus they can ensure that never a vulnerable server is directly accessible from the ``wild''. </P>

<P>You can use stunnel to provide a secure reverse proxy for some protocol. However, this only ensures a one on one connection, not like a ``normal''reverse proxy provides. </P>

<P id="LinkTarget_2684">Secure Access Layer </P>
<Figure id="LinkTarget_2685">

<ImageData src="images/4-Security Pattern Catalog_img_660.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Application security will be insecure if it is not properly integrated with the security of the external systems it uses. On top of the lower-level security, build a secure access layer for communicating in and out of the program. </P>

<P>Aliases: Using Low-level security, Using Non-application security, Only as strong as the weakest link </P>
<Figure id="LinkTarget_2686">

<ImageData src="images/4-Security Pattern Catalog_img_661.jpg"/>
Problem</Figure>

<P>When secure documents are transferred from one secure area to another in the military base, it is important that the security of the documents is not violated during the transfer. If the document is being transferred via a computer disk, the data could be encrypted and then locked in a briefcase and handcuffed to the arm of the courier during transfer. This will provide an isolation layer to protect the secure information during the transfer. </P>

<P>Most applications tend to be integrated with many other systems. The places where system integration occurs can be the weakest security points and the most susceptible to break-ins. If the developer is forced to put checks into the application wherever the applications communicates with these systems, then the code will be very convoluted and abstraction will be difficult. An application that is built on an insecure foundation will be insecure. In other words, it doesn't do any good to bar your windows when you leave your back door is wide open. </P>
<Figure id="LinkTarget_2687">

<ImageData src="images/4-Security Pattern Catalog_img_662.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_663.jpg"/>
</Figure>

<Lbl>Application </Lbl>

<LBody>development should not have to be developed with operating system, networking, and database specifics in mind. These can change over the life of an application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_664.jpg"/>
</Figure>

<Lbl>Putting </Lbl>

<LBody>low-level security code throughout the whole application makes it difficult to debug, modify, and port to other systems. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_665.jpg"/>
</Figure>

<Lbl>Even </Lbl>

<LBody>if the application is secure, a good hacker could find a way to intercept messages or go under the hood to access sensitive data. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_666.jpg"/>
</Figure>

<Lbl>Interfacing </Lbl>

<LBody>with external security systems is sometimes difficult. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_667.jpg"/>
</Figure>

<Lbl>An </Lbl>

<LBody>external system may not have sufficient security, and implementing the needed security may not be possible or feasible. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2688">

<ImageData src="images/4-Security Pattern Catalog_img_668.jpg"/>
Example</Figure>

<P>The PLoP registration program uses a Secure Access Layer. A layer was created where all communications is processed for registering through the web. This communications layer is positioned on top of Apache's Secure Socket Layer. This prevents any information from being sniffed during the entry of data such as credit card numbers. Also, a layer on the database side was also created to provide additional security by encrypting the credit card information in the database. The secure layer uses a key for encrypting and decrypting the data when needed. Thus, even if someone was able to access the database through some back door, the credit card data is still protected. </P>
<Figure id="LinkTarget_2689">

<ImageData src="images/4-Security Pattern Catalog_img_669.jpg"/>
Solution</Figure>

<P>Build your application security around existing operating system, networking, and database security mechanisms. If they do not exist, then build your own lower-level security mechanism. On top of the lower-level security, build a secure access layer for communicating in and out of the program. </P>

<P>Usually an application communicates with many pre-existing systems. For example, a financial application on a Windows NT client might use an Oracle database on a remote server. Given that most systems already provide a security interface, develop a layer in your application that encapsulates the interfaces for securely accessing these external systems. All communication between the application and the outside world will be routed through this secure layer. </P>

<P>The important point to this pattern is to build a layer to isolate the developer from change. This layer may have many different protocols depending upon the types of communications that need to be done. For example, this layer might have a protocol for accessing secure data in an Oracle database and another protocol for communicating securely with Netscape server through the Secure Sockets Layer (SSL). The crux of this pattern is to componentize each of these external protocols so they can be more easily secured. The architecture for different Secure Access Layers could vary greatly. However, the components'organization and integration is beyond the scope of this pattern. </P>

<P>By creating a Secure Access Layer with a standard set of protocols for communicating with the outside world, an application developer can localize these external interfaces and focus primarily on applications development. Communicate in and out of </P>

<P>the application will pass through the protocols provided by this layer. </P>

<P>This pattern assumes a convenient abstraction is possible. For example, VisualWorks'LensSession does not support Microsoft Access, so QueryDataManager cannot be used with a Microsoft Access database. Secure Access Layer, however, provides a location for a more general database abstraction. Third party drivers have been developed for ODBC that can communicate with Microsoft Access. By using the Secure Access Layer, it is easy to extend your application to use the ODBC protocol, thus allowing your application to communicate with any database that supports ODBC. </P>
<Figure id="LinkTarget_2690">

<ImageData src="images/4-Security Pattern Catalog_img_670.jpg"/>
Structure</Figure>

<P>The structure of a secure access layer is depicted in Figure 1 </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_671.jpg"/>
</Figure>

<P>Figure 1: Secure access layer class diagram. </P>
<Figure id="LinkTarget_2691">

<ImageData src="images/4-Security Pattern Catalog_img_672.jpg"/>
Dynamics</Figure>

<P>The dynamics of a secure access layer are depicted in Figure 2 </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_673.jpg"/>
</Figure>

<P>Figure 2: Secure access layer sequence diagram. </P>
<Figure id="LinkTarget_2692">

<ImageData src="images/4-Security Pattern Catalog_img_674.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_675.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Application is wrapped by the secure access layer. It depends on functionality offered by a certain provider. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_676.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Target offers an interface to the application which is a general abstraction of the specific interface as offered by the provider. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_677.jpg"/>
</Figure>

<Lbl>Theextends </Lbl>

<LBody>the target by wrapping invocations to it in a secure way, and mapping them to specific requests to a provider. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_678.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>SecureAccessLayer is an aggregation of these SecurityAdapters, and contains functionality to find and instantiate the appropriate adapter. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2693">

<ImageData src="images/4-Security Pattern Catalog_img_679.jpg"/>
Collaborations</Figure>

<P>When the Application wants certain functionality (for example, communicating with an Oracle database), it locates the appropriate SecurityAdapter by issuing a request to the SecureAccessLayer . The SecureAccessLayer will ensure that an instantiation of the appropriate adapter is available, and return a reference to the Application . </P>

<P>The Application then issues requests to this adapter, which will map these general requests to provider-specific requests. It will also ensure that these requests are wrapped in a secure way and that the interaction with the provider happens securely (i. e., the correct interaction protocols are respected). </P>

<P>Once the provider has issued a reply, the provider-specific reply is in turn mapped to a general format. This general reply is then returned to the Application . </P>
<Figure id="LinkTarget_2694">

<ImageData src="images/4-Security Pattern Catalog_img_680.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2695">

<ImageData src="images/4-Security Pattern Catalog_img_681.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2696">

<ImageData src="images/4-Security Pattern Catalog_img_682.jpg"/>
Consequences</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_683.jpg"/>
</Figure>

<Lbl>+ </Lbl>

<LBody>A Secure Access Layer can help isolate where an application communicates with external security systems. Isolating secure access points make it easier to integrate new security components and upgrade existing ones, improving maintainability. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_684.jpg"/>
</Figure>

<Lbl>+ </Lbl>

<LBody>A Secure Access Layer can make an application more portable. If the application later needs to communicate with Sybase rather than Oracle, then the access to the database is localized and only needs to be changed in one place. QueryObjects uses this approach by having all accesses to the database go through the QueryDataManager, which is built on top of the LensSession. The LensSession can map to either Oracle or Sybase. Therefore the application developer does not need to be concerned with either choice or future changes. </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_685.jpg"/>
</Figure>
-Different systems that your application may need to integrate with use different security protocols and schemes for accessing them. This can make it difficult to develop a Secure Access Layer that works for all integrated systems, and it also may cause the developer to keep track of information that many systems do not need. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_686.jpg"/>
</Figure>
-It can be very hard to retrofit a Secure Access Layer into an application which already has security access code spread throughout. </P>
<Figure id="LinkTarget_2697">

<ImageData src="images/4-Security Pattern Catalog_img_687.jpg"/>
Knownuses</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_688.jpg"/>
</Figure>

<Lbl>Secure </Lbl>

<LBody>Shell includes secure protocols for communicating in X11sessions and can use RSA encryption through TCP/IP connections. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_689.jpg"/>
</Figure>

<Lbl>SSL </Lbl>

<LBody>(Netscape Server)provides a Secure Access Layer that web clients can use for insuring secure communication. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_690.jpg"/>
</Figure>

<Lbl>Oracle </Lbl>

<LBody>provides its own Secure Access Layer that applications can use for communicating with it. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_691.jpg"/>
</Figure>

<Lbl>CORBA </Lbl>

<LBody>Security Services specifies how to authenticate, administer, audit and maintain security throughout a CORBA distributed object system. Any CORBA application's Secure Access Layer would communicate with CORBA's Security Service. </LBody>
</LI>
</L>

<P id="LinkTarget_2698">Secure Logger </P>
<Figure id="LinkTarget_2699">

<ImageData src="images/4-Security Pattern Catalog_img_692.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Application events must be logged in a centralized way, and it should be impossible to alter log files. </P>
<Figure id="LinkTarget_2700">

<ImageData src="images/4-Security Pattern Catalog_img_693.jpg"/>
Problem</Figure>

<P>All application events and related data must be securely logged for debugging and forensic purposes. This can lead to redundant code and complex logic. </P>

<P>All trustworthy applications require a secure and reliable logging capability. This logging capability may be needed for forensic purposes and must be secured against stealing or manipulation by an attacker. Logging must be centralized to avoid redundant code throughout the code base. All events must be logged appropriately at multiple points during the application's operational life cycle. In some cases, the data that needs to be logged may be sensitive and should not be viewable by unauthorized users. It becomes a critical requirement to protect the logging data from unauthorized users so that the data is not accessible or modifiable by a malicious user who tries to identify the information trail. Without centralized control, sometimes the code usually gets replicated, and it becomes difficult to maintain the changes and monitor the functionality. </P>

<P>One of the common elements of a successful intrusion is the ability to cover one's tracks. Usually, this means erasing any telltale events in various log files. Without a log trail, an administrator has no evidence of the intruder's activities and therefore no way to track the intruder. To prevent an attacker from breaking in again and again, administrators must take precautions to ensure that log files cannot be altered. Cryptographic algorithms can be adopted to ensure data confidentiality and the integrity of the logged data. But the application processing logic required to apply encryption and signatures to the logged data can be complex and cumbersome, further justifying the need to centralize the logger functionality. </P>
<Figure id="LinkTarget_2701">

<ImageData src="images/4-Security Pattern Catalog_img_694.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_695.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>need to log sensitive information that should not be accessible to unauthorized users. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_696.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>need to ensure the integrity of the data logged to determine if it was tampered with by an intruder. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_697.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to capture output at one level for normal operations and at other levels for greater debugging in the event of a failure or an attack. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_698.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to centralize control of logging in the system for management purposes. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_699.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to apply cryptographic mechanisms for ensuring confidentiality and integrity of the logged data. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2702">

<ImageData src="images/4-Security Pattern Catalog_img_700.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2703">

<ImageData src="images/4-Security Pattern Catalog_img_701.jpg"/>
Solution</Figure>

<P>Use a Secure Logger to log messages in a secure manner so that they cannot be easily altered or deleted and so that events cannot be lost. The Secure Logger provides centralized control of logging functionality that can be used in various places throughout the application request and response. Centralizing control provides a means of decoupling the implementation details of the logger from the code of developers who will use it throughout the application. The processing of the events can be modified without impacting existing code. For instance, developers can make a single method call in their Java code or JSP code. The Secure Logger takes care of how the events are securely logged in a reliable manner. </P>
<Figure id="LinkTarget_2704">

<ImageData src="images/4-Security Pattern Catalog_img_702.jpg"/>
Structure</Figure>

<P>Figure 1: Class layout of the Secure Logger </P>

<P>See Figure 1 . </P>
<Figure id="LinkTarget_2705">

<ImageData src="images/4-Security Pattern Catalog_img_703.jpg"/>
Dynamics</Figure>

<P>Figure 2: Event sequence for the Secure Logger </P>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2706">

<ImageData src="images/4-Security Pattern Catalog_img_704.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_705.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>A client sends a request to a particular target resource. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_706.jpg"/>
</Figure>

<Lbl>SecureLogger </Lbl>

<LBody>SecureLogger is a class used to manage logging of data in a secure, centralized manner. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_707.jpg"/>
</Figure>

<Lbl>LogManager </Lbl>

<LBody>LogManager obtains a Logger instance from LogFactory and uses it to log messages. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_708.jpg"/>
</Figure>

<Lbl>LogFactory </Lbl>

<LBody>A LogFactory is responsible for creating and returning Logger instances. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_709.jpg"/>
</Figure>

<Lbl>Logger </Lbl>

<LBody>A Logger writes log messages to a target destination. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2707">

<ImageData src="images/4-Security Pattern Catalog_img_710.jpg"/>
Collaborations</Figure>

<P>A client uses the SecureLogger to log events. The SecureLogger centralizes logging management and encapsulates the security mechanisms necessary for preventing unauthorized log alteration. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_711.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>wants to log an event using SecureLogger. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_712.jpg"/>
</Figure>

<Lbl>SecureLogger </Lbl>

<LBody>generates a sequence number and prepends it to the message. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_713.jpg"/>
</Figure>

<Lbl>SecureLogger </Lbl>

<LBody>passes the LogManager the modified event string to log. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_714.jpg"/>
</Figure>

<Lbl>LogManager </Lbl>

<LBody>obtains a handle to a Logger instance from a LogFactory. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_715.jpg"/>
</Figure>

<Lbl>LogFactory </Lbl>

<LBody>creates a Logger instance. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_716.jpg"/>
</Figure>

<Lbl>LogManager </Lbl>

<LBody>delegates actual logging of the event to the Logger.There are two parts to this logging process. The first part involves securing the data to be logged and the second part involves logging the secured data. The SecureLogger class takes care of securing the data and the LogManager class takes care of logging it. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2708">

<ImageData src="images/4-Security Pattern Catalog_img_717.jpg"/>
Implementation</Figure>

<P>There are two basic strategies for implementing a Secure Logger. One strategy is to secure the log itself from being tampered with, so that all data written to it is guaranteed to be correct and complete. This strategy is the Secure Log Store Strategy. The other strategy, the Secure Data Logger Strategy, secures the data so that any alteration or deletion of it can be detected. This works well in situations where you cannot guarantee the security of the log itself. </P>

<P>Secure Data Logger Strategy The Secure Data Logger Strategy entails preprocessing of the data prior to logging it. After the data is secured in the preprocessing, it is sent to the logger in the usual manner. There are four new classes introduced to help secure the data. Figure 3 illustrates the structure of the Secure Logger implemented using a Secure Data Logger Strategy. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_718.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_718.jpg"/>
</Figure>

<P>Figure 3: Secure Logger with Secure Data Logger Strategy class diagram </P>

<P>We use the MessageDigest, Cipher, Signature, and UIDGenerator classes for applying cryptographic mechanisms and performing various functions necessary to guarantee the data logged is confidential and tamperproof. Figure 4 shows the sequence of events used to secure the data prior to being logged. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_719.jpg"/>
</Figure>

<P>Figure 4: Secure Logger with Secure Data Logger Strategy sequence diagram </P>

<P>When you have sensitive data or fear that log entries might be tampered with and can't rely on the security of the infrastructure to adequately protect those entries, it becomes necessary to secure the data itself prior to being logged. That way, even if the log destination (file, database, or message queue)is compromised, the data remains secure and any corruption of the log will become clearly evident. </P>

<P>There are three elements to securing the data: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_720.jpg"/>
</Figure>

<Lbl>Protect </Lbl>

<LBody>sensitive data. Ensure all sensitive data are stored and remain confidential throughout the process. For example, Credit card numbers should not be viewed directly by unauthorized personnel. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_721.jpg"/>
</Figure>

<Lbl>Prevent </Lbl>

<LBody>data alteration. Make sure that data is tamperproof. For example, user IDs, transaction amounts, and so forth should not be changed. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_722.jpg"/>
</Figure>

<Lbl>Detect </Lbl>

<LBody>deletion of data. Detect if events have been deleted from the log, a tell-tale sign that an attacker has compromised the system.To protect sensitive data, encrypt it using a symmetric key algorithm. Public-key algorithms are too CPU-intensive to use for bulk data. They are better for encrypting and protecting a symmetric key for use with a symmetric key algorithm. Properly protecting the symmetric key can ensure that attackers cannot access sensitive data even if they have access to the logs. For this, the SecureLogger can use an EncryptionHelper class. This class is responsible for encrypting a given string but not for decrypting it. This is an extra security precaution to make it harder for attackers to gain access to that sensitive data. Decryption should only be done outside the application, using an external utility that is not accessible </LBody>
</LI>
</L>

<P>from the application and its residing host. Data alteration can be prevented by using digitally signed message digests in the same manner that e-mail is signed. A message digest is generated for each message in the log file and then signed. The signature prevents an attacker from modifying the message and creating a subsequent message digest for the altered data. For this operation, the SecureLogger uses MessageDigestHelper and DigitalSignatureHelper classes. Finally, to detect deletion of data, a sequence number must be used. Using message digests and digital signatures is of no use if the entire log entry, including the signed message, is deleted. To prevent deletion, each entry must contain a sequence number that is part of the data that gets signed. That way, it will be evident if an entry is missing, since there will be a gap in the sequence numbers. Because the sequence numbers are signed, an attacker would be unable to alter subsequent numbers in the sequence, making it easy for an administrator reviewing the logs to detect deletions. To accomplish this, the SecureLogger uses a UUIDpattern. </P>

<P>Secure Log Store Strategy In the Secure Log Store Strategy, the log itself is secured from tampering. A secure repository houses the log data and can be implemented using a variety of off-the-shelf products or various techniques such as a Secure Pipe. A Secure Pipe pattern is used to guarantee that the data is not tampered with in transit to the Secure Store. Figure 5 illustrates the structure of the Secure Logger pattern implemented using a Secure Log Store Strategy. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_723.jpg"/>
</Figure>

<P>Figure 5: Secure Logger Pattern with Secure Log Store Strategy class diagram </P>

<P>The Secure Log Store strategy does not require the data processing that the Secure Data Logger Strategy introduced. Instead, it makes use of a Secure Pipe pattern and a secure datastore (such as a database), represented as the SecureStore object in Figure 5 . In Figure 6 , the only change from the main Secure Logger pattern sequence is the introduction of the Secure Pipe pattern. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_724.jpg"/>
</Figure>

<P>Figure 6: Secure Logger pattern using Secure Pipe </P>

<P>In the Secure Log Store Strategy sequence diagram, depicted in Figure 6 , Logger establishes a secure connection to the SecureStore using a SecurePipe. The Logger then logs messages normally. The SecureStore is responsible for preventing tampering with the log file. It could be implemented as a database with create-only permissions for the Logger user; a listener on a separate, secure box with write only capabilities; or any other solution that prevents deletion, modification, or unauthorized creation of log entries. </P>
<Figure id="LinkTarget_2709">

<ImageData src="images/4-Security Pattern Catalog_img_725.jpg"/>
Pitfalls</Figure>

<P>The Secure Logger pattern provides the entry point for logging in the application. As such, it has the following security factors and risks associated with it: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_726.jpg"/>
</Figure>
Key Management. The Secure Logger must either encrypt data itself or establish a secure channel to a secure log store. Either way, there are key management issues that must be addressed. If the key or password for retrieving the key (such as for a keystore)must be kept in code, make sure that the code is obfuscated. Failure to properly protect the key will render the Secure Logger useless. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_727.jpg"/>
</Figure>
Integrity. The Secure Logger must provide integrity when communicating with the secure store in the Secure Data Store strategy. If the communication channel is not secure, it opens up the possibility that an attacker can compromise the communication channel and modify the data in transit.Should everything be logged from Web tier?No. The Secure Logger pattern is applicable across tiers. It should be implemented on each tier that requires logging. </P>

<P>Too much performance overhead. Using the Secure Data Store Strategy incurs severe performance overhead. Expect a significant slowdown due to the extensive use of cryptographic algorithms. The Secure Data Logger Strategy is the preferred strategy for performance, but it also incurs the same overhead associated with use of Secure Pipe. </P>

<P>How likely is log tampering?Log modifications to cover an attacker's tracks is not only common, it is the hallmark of a good hacker. It is difficult to determine how prevalent it is due to its very nature. Log files that have been successfully altered usually mean that the last trace of evidence that a system has been compromised is now gone. </P>

<P>Shouldn't log security be the responsibility of the system administrators?In many cases, system administrators can effectively secure the log, and additional security is unnecessary. It depends on the skill of your operations staff along with the requirements of the application. Like any other security, log security is only as strong as the weakest link. By consolidating and encapsulating log functionality using the Secure Logger, you provide the capability to add additional security, such as in the Secure Data Strategy, if and when you find external mechanisms are not sufficient. </P>
<Figure id="LinkTarget_2710">

<ImageData src="images/4-Security Pattern Catalog_img_728.jpg"/>
Consequences</Figure>

<P>Using the Secure Logger pattern helps in logging all data-related application events, user requests, and responses. It facilitates confidentiality and integrity of log files. In addition, it provides the following benefits: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_729.jpg"/>
</Figure>

<Lbl>Centralizes </Lbl>

<LBody>logging control. The Secure Logger improves reusability and maintainability by centralizing logging control and decoupling the implementation details from the API. This allows developers to use the logging facilities through the API independent of the security functionality built into the logger itself. This reduces the possibility that business developers will inadvertently circumvent security by misusing it. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_730.jpg"/>
</Figure>

<Lbl>Prevents </Lbl>

<LBody>undetected log alteration. The key to successfully compromising a system or application is the ability to cover your tracks. This involves alteration of log files to ensure that an administrator cannot detect that a breach has occurred. By employing a Secure Logger, security developers can prevent log alterations, ensuring that a breach can be detected through log file forensics, which is the first step in tracking down an intruder and preventing security breaches. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_731.jpg"/>
</Figure>

<Lbl>Reduces </Lbl>

<LBody>performance. The Secure Logger impacts performance due to the use of cryptographic algorithms. Operations such as message digests, digital signatures, and encryption are computationally expensive and add additional performance overhead. Use only the necessary functionality to avoid unwanted performance overhead. Reduced performance can lead to a self-inflicted denial of service attack. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_732.jpg"/>
</Figure>

<Lbl>Promotes </Lbl>

<LBody>extensibility. Security is a constantly evolving process. To protect against both current and future threats, code must be adaptable and extensible. The Secure Logger provides the requisite extensibility by hiding implementation details behind a generic interface. By increasing the overall lifespan of the code, you increase its reliability by having tested it and worked out all of its bugs. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_733.jpg"/>
</Figure>

<Lbl>Improves </Lbl>

<LBody>manageability. Since all of the logging control is centralized, it is easier to manage and monitor. The Secure Logger performs all of the necessary security processing prior to the actual logging of the data, which allows management of each function independently of the others without risk of impacting overall security. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2711">

<ImageData src="images/4-Security Pattern Catalog_img_734.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2712">Secure Message Router </P>
<Figure id="LinkTarget_2713">

<ImageData src="images/4-Security Pattern Catalog_img_735.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Securely communicate with multiple partner endpoints using message-level security and identity-federation mechanisms. </P>
<Figure id="LinkTarget_2714">

<ImageData src="images/4-Security Pattern Catalog_img_736.jpg"/>
Problem</Figure>

<P>Using Web services communication in an organizational workflow or across the Internet with multiple partners poses a lot of challenges. If the message sender signs and encrypts the message in its entirety, the message sender restricts the possibility of further message changes by the message recipient in the workflow. This becomes a critical issue when each recipient of the message in a workflow has a responsibility for a selected portion of that message and must modify or add to it. If the message-level security, such as signature and encryption, were applied to the entire message, any modification made by the initial recipient would invalidate the original message as well as expose the entire message, which was not intended for the initial recipient. In some cases, if a message is intended for multiple recipients and only selected fragments need to be revealed for each recipient, then it becomes more complex to convert each fragment as a message and then compile them together at the end of workflow. Let's consider an example scenario; a patient visits a hospital that handles all documents and communication electronically using XML Web services. All patient information (for example, contact information, insurance data, health analysis, lab results, doctor observations, prescriptions, visit schedule, credit card information, and so on)is represented in XML. During the visit, the patient's health record is maintained via a workflow involving doctors, pharmacists, insurance providers, and so on. Each individual participating in the workflow does not require complete access to the patient's record. Only selected portions of the message are required and applicable to each workflow participant. For example, the billing department only requires knowing the insurance provider and the co-payment and credit card information; it does not need to know the patient's health history. Although the information workflow happens within an organization, it is a violation of specific legal regulations to unnecessarily disclose information to personnel. Web services promise easier integration of applications, business partners, and consumers. With multiple parties involved, it often becomes more difficult to communicate with a standardized infrastructure representing a common scheme of authentication and authorization. Sometimes, each service needs a unique representation of credentials and message formats. In a trusted inter-organization or multi-partner communication scenario, eliminating point-topoint security and enabling interoperable mechanisms for single sign-on (SSO), global logout, identity registration, and termination are mandated. This is accomplished by adopting Liberty alliance standards, which define rules and guidelines for defining federated identities, identity registration and revocation, SSO with multiple partner services, global logout, and so forth. Thus, it becomes very important to provide a security intermediary infrastructure that can handle multiple recipients using a standards-based framework, that can provide message-level configuration security mechanisms, and that can support SSO for accessing disparate security infrastructures. </P>
<Figure id="LinkTarget_2715">

<ImageData src="images/4-Security Pattern Catalog_img_737.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_738.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to use a security intermediary to support Web servicesbased workflow applications or to send messages to multiple service endpoints. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_739.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to configure element-level security and access control that apply message-level security mechanisms, particularly authentication tokens and signatures and encrypted portions using XML digital signature or XML Encryption. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_740.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to make sure to reveal only the required portions of a protected message to a target recipient. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_741.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to implement SSO by interacting with an identity provider authority to generate SAML assertions and XACML-based access control lists for accessing Web services providers and applications that rely on SAML assertions. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_742.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to incorporate a global logout mechanism that sends a logout notification to all participating service endpoints. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_743.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to notify participating service providers when an identity is registered, revoked, and terminated. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_744.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to dynamically apply security criteria through message transformations and canonicalizations before forwarding them to their intended recipients. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_745.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to filter incoming message headers for security requirements and dynamically apply context-specific rules and other required security mechanisms before forwarding the messages to an endpoint. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_746.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to support document-based Web services, particularly by checking document-level credentials and attributes. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_747.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to enforce centralized logging for incoming messages, faults, messages sent, and intended recipients of the messages. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_748.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to configure multiple message formats and support XML schemas that guarantee interoperability with intended service endpoints without compromising message security. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_749.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to meet the mandated regulatory requirements defined by Web-services partners. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_750.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to use a centralized intermediary that provides mechanisms for configuring message-level security headers supporting XML security specifications such as OASIS WS-Security, XML Signature, XML Encryption, SAML, XACML, and Liberty Alliance. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2716">

<ImageData src="images/4-Security Pattern Catalog_img_751.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2717">

<ImageData src="images/4-Security Pattern Catalog_img_752.jpg"/>
Solution</Figure>

<P>The Secure Message Router pattern is used to establish a security intermediary infrastructure that aggregates access to multiple application endpoints in a workflow or among partners participating in a Web-services transaction. It acts on incoming messages and dynamically provides the security logic for routing messages to multiple endpoint destinations without interrupting the flow of messages. It makes use of a security configuration utility to apply endpoint-specific security decisions and mechanisms, particularly configuring message-level security that protects messages in entirety or reveals selected portions to its intended recipients. During operation, the Secure Message Router pattern works as a security enforcement point for outgoing messages before sending them to their intended recipients by providing endpoint-specific security services, including SSO, access control, and message-level security mechanisms. In addition, it can also provide identity-federation mechanisms that notify service providers and identity providers upon SSO, global logout, identity registration, and termination. In effect, a Secure Message Router must handle tasks such as: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_753.jpg"/>
</Figure>

<Lbl>Configuring </Lbl>

<LBody>message-level security that allows signing and encrypting an XML message or its selected elements intended for multiple service endpoints. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_754.jpg"/>
</Figure>

<Lbl>Configuring </Lbl>

<LBody>SSO access with multiple Web-services endpoints using SAML tokens and XACML assertions that can act as SSO session tickets. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_755.jpg"/>
</Figure>

<Lbl>Supporting </Lbl>

<LBody>the use of XKMS-based PKI services to retrieve keys for signing and encrypting appropriate message parts specific to a service endpoint or to participate in workflow. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_756.jpg"/>
</Figure>

<Lbl>Notifying </Lbl>

<LBody>all participating service providers and identity providers of SSO and global logouts. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_757.jpg"/>
</Figure>

<Lbl>Notifying </Lbl>

<LBody>all participating service providers and identity providers of identity registration, revocation, and termination. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_758.jpg"/>
</Figure>

<Lbl>Dynamically </Lbl>

<LBody>applying message transformation and canonicalization algorithms to meet recipient endpoint requirements or standards compliance. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_759.jpg"/>
</Figure>

<Lbl>Reconfiguring </Lbl>

<LBody>incoming messages to destination-specific message formats and supporting XML schemas that guarantee interoperability with the target service endpoint. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_760.jpg"/>
</Figure>

<Lbl>Centralizing </Lbl>

<LBody>logging of messages and recording of auditable trails for incoming messages, faults, and their ultimate endpoints. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_761.jpg"/>
</Figure>

<Lbl>Supporting </Lbl>

<LBody>use of a Liberty-compliant identity provider and agents for identity federation and establishing a circle of trust among participating service providers. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2718">

<ImageData src="images/4-Security Pattern Catalog_img_762.jpg"/>
Structure</Figure>

<P>Figure 1: Class layout of the Secure Message Router. </P>

<P>See Figure 1 </P>
<Figure id="LinkTarget_2719">

<ImageData src="images/4-Security Pattern Catalog_img_763.jpg"/>
Dynamics</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_764.jpg"/>
</Figure>

<P>Figure 2: Event sequence for the Secure Message Router. </P>

<P>See Figure 2 </P>
<Figure id="LinkTarget_2720">

<ImageData src="images/4-Security Pattern Catalog_img_765.jpg"/>
Participants</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_766.jpg"/>
</Figure>
Client. The client of the Secure Message Router pattern can be any application that initiates a service request to access a single endpoint or multiple service endpoints. Typically, it can be any application component or a Message Interceptor Gateway that sends requests or responds to a Web-services transaction. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_767.jpg"/>
</Figure>

<Lbl>Secure </Lbl>

<LBody>Message Router. The Secure Message Router allows configuring message-level security mechanisms and provides support for Liberty-enabled services such as Federated SSO, global logout, identity registration, and termination services by interacting with a Liberty-enabled identity provider. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_768.jpg"/>
</Figure>

<Lbl>Message </Lbl>

<LBody>Configurator. The Message Configurator plays a secondary role as the Secure Message Router pattern. It implements all the methods intended for configuring message-level security intended for a specified endpoint. It makes use of configuration tables that identify the message, service endpoint and intermediaries, message-level access privileges, validating XML schemas, transformations, and compliance requirements. It signs and encrypts messages in their entirety or selected portions, as specified in the configuration table. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_769.jpg"/>
</Figure>

<Lbl>Identity </Lbl>

<LBody>Provider. The identity provider represents a Liberty-compliant service provider that delivers federated-identity services such as federated single sign-on, global logout, identity registration, termination, authentication, authorization, and auditing. </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_770.jpg"/>
</Figure>
Request. The Request message represents an XML document that is verified by all the required security-processing tasks carried out by the Secure Message Router. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_771.jpg"/>
</Figure>
ServiceEndpoint. The ServiceEndpoint represents the target object and the ultimate consumer of the message that the client uses to do message processing. In the case of the Secure Message Router pattern, the ServiceEndpoint can be a single provider or multiple service providers or applications that implement the business logic and processing of the client request. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_772.jpg"/>
</Figure>
WorkflowRecipient. The WorkflowRecipient represents an endpoint that participates in a workflow or in collaboration. It is an intermediary endpoint representing an identity or business logic designated for processing the entire document or selected portions of an incoming message and then forwarding it to the next recipient in the workflow chain. </P>
<Figure id="LinkTarget_2721">

<ImageData src="images/4-Security Pattern Catalog_img_773.jpg"/>
Collaborations</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_774.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>client creates an XML message and sends it to the Secure Message Router. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_775.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Secure Message Router hands over the message to the Message Configurator, to identify the endpoints and configure the message. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_776.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Message Configurator applies message-level security to the message, according to its configuration tables. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_777.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Secure Message Router then constructs the message that has to be sent to the recipients. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_778.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>message is sent to the various recipients (which may be service endpoints or workflow recipients). </LBody>
</LI>
</L>
<Figure id="LinkTarget_2722">

<ImageData src="images/4-Security Pattern Catalog_img_779.jpg"/>
Implementation</Figure>

<P>XML Messaging Provider Strategy In this strategy, the Secure Message Router pattern adopts an XML-based messaging provider or message-broker infrastructure that facilitates sending and receiving of XML messages (such as SOAP or ebXML)using synchronous and asynchronous delivery mechanisms. The XML messaging provider acts as a SOAP intermediary providing message-level security-mechanism support for RPC and document-style Web-services interactions among multiple service endpoints involved in a workflow or collaboration. Figure 3 represents the sequence diagram illustrating the Secure Message Router pattern using the XML Messaging Provider Strategy. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_780.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_780.jpg"/>
</Figure>

<P>Figure 3: XML Messaging Provider sequence diagram </P>

<P>The Client initiates XML message requests intended for processing at multiple service endpoints in a Workflow. These messages are forwarded to the messaging provider, which acts as a SOAP security intermediary that allows configuring and applying security-header mechanisms before sending the messages to its workflow participants. Upon receipt of a request message from the client, the messaging provider processes the message and then identifies and determines its intended recipients and their message-level security requirements. It makes use of a Message configurator that provides the required methods and information for applying the required message-level security mechanisms and defining endpoint-specific requirements. The Message configurator follows a security configuration table that specifies the message identifier, endpoints, and message-level security requirements related to representing the identity, signature, encryption, timestamps, correlation ID, and other endpoint-specific attributes. After configuring the message, the messaging provider initiates the workflow by dispatching configured message to its first intended endpoint (that is, a workflow participant). The dispatched message ensures that only the privileged portions of the message are allowed to be viewed or modified by workflow participants, based on their identities and other information; all other portions of the message remain integral and confidential throughout the workflow process. </P>

<P>Liberty SSO Strategy The Liberty SSO Strategy adopts a federated network identity architecture based on the Liberty Alliance specifications. Using a Liberty-enabled identity provider, this strategy allows establishing circle-of-trust (CoT)relationships via identity federation to enable secure data communication among the service providers over the Internet. The service providers rely on a Liberty-enabled identity provider, which acts as a trust provider that defines and establishes identity federation-based trust relationships and also plays the role of an authority for issuing security assertions that represents authentication, authorization, and other attribute information. In this strategy, the Secure Message Router pattern makes use of a Liberty-enabled identity provider to link service endpoints, and issue XML-based security assertions. Using the security assertions provided by the service provider, it initiates SSO with partner service endpoints and also uses authorization and other attribute assertions to support message-level security mechanisms for sending XML messages. Figure 4 represents the sequence diagram illustrating the Secure Message Router using the Liberty SSO strategy. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_781.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_781.jpg"/>
</Figure>

<P>Figure 4: Liberty SSO sequence diagram </P>

<P>During operation, the client will make use of Secure Message Router to process the message, determine its intended endpoint recipients using a message Configurator, and then interact with a Liberty-enabled identity provider to establish SSO with partner endpoints. The Secure Message Router communicates with the Liberty-enabled identity provider using a Liberty-agent via a request and response protocol that works as follows: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_782.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Secure Message Router initiates a request to the service provider, which sends a SAML authentication request to an identity provider that instructs the identity provider to provide an authentication assertion. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_783.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>identity provider responds with a SAML authentication response containing SAML artifacts or an error. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_784.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Secure Message Router uses the SAML artifacts as an SSO token to interact with all partner endpoints and to initiate the transaction. The partner endpoints trust the SSO tokens issued by the Liberty-enabled identity provider that established the identity federation.In addition to the above, the Secure Message Router also facilitates other Liberty-enabled services and tasks, such as notification of identity registration, termination, and global logout to all partner endpoints. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_785.jpg"/>
</Figure>

<Lbl>High </Lbl>

<LBody>availability and reliability. The Secure Message Router infrastructure and every component that interacts with it must provide high availability and reliability. It becomes very important to ensure100percent availability so that the message router can be better than the weakest link in the Web-services architecture. Failure to provide high availability may result in monetary loss and security vulnerabilities. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_786.jpg"/>
</Figure>

<Lbl>Fault </Lbl>

<LBody>tolerance. The Secure Message Router is also expected to be fault tolerant in order to support security and to enhance reliability and performance of the infrastructure. When a failure is detected, it must be transparently replaced with a redundant infrastructure. The failure should not jeopardize any existing outbound requests or responses or their intermediate processing states. There must be a recovery mechanism that can read all outstanding service requests and paused requests with intermediate states and forward them for further processing with the Secure Message Router without skipping any existing security mechanisms. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_787.jpg"/>
</Figure>

<Lbl>Provider </Lbl>

<LBody>issues. From an implementation standpoint, there are not many messaging providers that facilitate standards-based XML message workflow, multi-hop Web-services communication, and Liberty SSO. Using nonstandard implementations affects the secure message-router-based architecture with noticeable problems related to incompatible messages, routing failures, longer latencies, and lack of guaranteed message delivery. In general, these issues directly affect security and reliability of Web services or workflow communication using multiple Web-services endpoints. The adoption of emerging Web-services standards such as BPEL4WS, WS-Reliability, WS-Reliable Messaging, WS-*, and their compliant products is expected to provide interoperable workflow collaboration, reliability, and guaranteed message delivery protocols. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_788.jpg"/>
</Figure>

<Lbl>Enabling </Lbl>

<LBody>interoperability in a workflow?The Secure Message Router must pre-verify the messages for interoperability before sending them to participants in a workflow or intended recipients. The interoperability requirements of the recipient endpoint with regard to WS-I profiles, XML schemas, transformations, canonicalizations, and other endpoint-specific attributes must be specified using the Message Configurator. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2723">

<ImageData src="images/4-Security Pattern Catalog_img_789.jpg"/>
Pitfalls</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_790.jpg"/>
</Figure>
Scalability?It is important to verify the Secure Message Router solution architecture for scalability to eliminate bottlenecks when communicating with multiple endpoints. This is critical to the success of every Message Router to perform resource-intensive tasks such as applying signatures, encryptions, and transformations without the expense of scalability and overall performance. </P>
<Figure id="LinkTarget_2724">

<ImageData src="images/4-Security Pattern Catalog_img_791.jpg"/>
Consequences</Figure>

<P>Adopting the Secure Message Router pattern facilitates applying SSO mechanisms and trusted communication when the target message is exchanged among multiple recipients or intended to be part of a workflow. It also allows selectively applying XML Encryption and XML Signature at the element level by ensuring that content is not exposed to everyone unless the recipient has privileges to access the selected fragments of the message. This helps in securely sending messages to multiple recipients and ensuring that only selected fragments of the message are revealed or modified by the privileged recipients. With the support for Liberty-enabled identity providers, it establishes a circle of trust among participation endpoints and facilitates SSO by securely sharing identity information among the participating service endpoints. The Secure Message Router also ensures seamless integration and interoperability with all participating endpoints by sending destination-specific messages. In addition, the Secure Message Router pattern provides the following benefits: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_792.jpg"/>
</Figure>
Centralized routing. The Secure Message Router delivers a centralized message intermediary solution for applying message-level security mechanisms and enabling SSO access to multiple endpoints. This allows configuring a centralized access control and processing subsystem for incorporating all security-related operations for sending messages to multiple service endpoints. It offers centralized management of related services, including authentication, authorization, faults, encryption, audit trails, metering, billing, and so on. This improves manageability. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_793.jpg"/>
</Figure>
Modularity and maintainability. Centralizing all security mechanisms and configuring access-control policies using a single intermediary keep the message-sender application interfaces separated from security operations. This enhances a service with a modular subsystem designated for security and reduces complex tasks at the service endpoint of a Web services provider. This also saves significant application processing time and resources at the message-sending application endpoint. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_794.jpg"/>
</Figure>

<Lbl>Reusability </Lbl>

<LBody>and extensibility. The Secure Message Router pattern encapsulates all direct access to participating service endpoints, facilitating a common reusable solution that is necessary for protecting multiple service endpoints. It also offers extensibility by allowing you to incorporate more message-level security mechanisms and functionalities specific to the target endpoints. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_795.jpg"/>
</Figure>

<Lbl>Improved </Lbl>

<LBody>testability. The Secure Message Router infrastructure separates the security architectural model from the underlying message-sender's service endpoint. This improves ease of testability and extensibility of the security architecture. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2725">

<ImageData src="images/4-Security Pattern Catalog_img_796.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2726">Secure Pipe </P>
<Figure id="LinkTarget_2727">

<ImageData src="images/4-Security Pattern Catalog_img_797.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: You need to provide privacy and prevent eavesdropping and tampering of client transactions caused by man-in-themiddle attacks. </P>
<Figure id="LinkTarget_2728">

<ImageData src="images/4-Security Pattern Catalog_img_798.jpg"/>
Problem</Figure>

<P>Web-based transactions are often exposed to eavesdropping, replay, and spoofing attacks. Anytime a request goes over an insecure network, the data can be intercepted or exposed by unauthorized users. Even within the confines of a VPN, data is exposed at the endpoint, such as inside of an intranet. When exposed, it is subject to disclosure, modification, or duplication. Many of these types of attacks fall into the category of man-in-the-middle attacks. Replay attacks capture legitimate transactions, duplicate them, and resend them. Sniffer attacks just capture the information in the transactions for use later. Network sniffers are widely available today and have evolved to a point where even novices can use them to capture unencrypted passwords and credit card information. Other attacks capture the original transactions, modify them, and then send the altered transactions to the destination. This is a common problem shared by all applications that do business over an untrusted network, such as the Internet. For simple Web applications that just serve up Web pages, it is not cost-effective to address these potential attacks, since there is no reason for attackers to carry out such an attack (other than for defacement of the pages)and therefore the risk is relatively low. But, if you have an application that requires sending sensitive data (such as a password)over the wire, you need to protect it from such an attack. </P>
<Figure id="LinkTarget_2729">

<ImageData src="images/4-Security Pattern Catalog_img_799.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_800.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to avoid writing application logic to provide the necessary protection; it is better to push this functionality down into the infrastructure layer to avoid complexity. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_801.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to make use of hardware devices that can speed up the cryptographic algorithms needed to prevent confidentiality-and integrity-related issues. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_802.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to adopt tested, third-party products for reliable data and communication security. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_803.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to limit the protection of data to only sensitive data due to the large processing overhead and subsequent delay due to encryption. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2730">

<ImageData src="images/4-Security Pattern Catalog_img_804.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2731">

<ImageData src="images/4-Security Pattern Catalog_img_805.jpg"/>
Solution</Figure>

<P>Use a Secure Pipe to guarantee the integrity and privacy of data sent over the wire. A Secure Pipe provides a simple and standardized way to protect data sent across a network. It does not require application-layer logic and therefore reduces the complexity of implementation. In some instances, the task of securing the pipe can actually be moved out of the application and even off of the hardware platform altogether. Because a Secure Pipe relies on encrypting and decrypting all of the data sent over it, there are performance issues to consider. A Secure Pipe allows developers to delegate processing to hardware accelerators, which are designed especially for the task. </P>
<Figure id="LinkTarget_2732">

<ImageData src="images/4-Security Pattern Catalog_img_806.jpg"/>
Structure</Figure>

<P>Figure 1: Secure Pipe class diagram. </P>

<P>Figure 1 depicts a class diagram of the Secure Pipe pattern in relation to an application. </P>
<Figure id="LinkTarget_2733">

<ImageData src="images/4-Security Pattern Catalog_img_807.jpg"/>
Dynamics</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_808.jpg"/>
</Figure>

<P>Figure 2: Secure Pipe sequence diagram. </P>

<P>The sequence diagram of the operation of a secure pipe is given in Figure 2 . </P>
<Figure id="LinkTarget_2734">

<ImageData src="images/4-Security Pattern Catalog_img_809.jpg"/>
Participants</Figure>

<P>The following participants are illustrated in the sequence diagram shown in Figure 2 . </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_810.jpg"/>
</Figure>

<Lbl>client </Lbl>

<LBody>Initiates a login with the application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_811.jpg"/>
</Figure>

<Lbl>application </Lbl>

<LBody>Creates a system level SecurePipe over which to communicate with the client. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_812.jpg"/>
</Figure>

<Lbl>securepipe </Lbl>

<LBody>A SecurePipe is an encrypted communications channel that provides data privacy and integrity between two endpoints. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2735">

<ImageData src="images/4-Security Pattern Catalog_img_813.jpg"/>
Collaborations</Figure>

<P>Figure 2 shows a sequence diagram depicting use of the Secure Pipe pattern. In the sequence shown, a client needs to connect to an application over a secure communication line. The diagram shows how the client and the application communicate using the Secure Pipe. The interaction is as follows. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_814.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>sends login request to the Application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_815.jpg"/>
</Figure>

<Lbl>Application </Lbl>

<LBody>uses System to create a SecurePipe. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_816.jpg"/>
</Figure>

<Lbl>SecurePipe </Lbl>

<LBody>negotiates parameters of the secure connection with the Client. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_817.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>sends request to the Application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_818.jpg"/>
</Figure>

<Lbl>SecurePipe </Lbl>

<LBody>processes the request and creates a secure message by encrypting the data. It sends the message over the wire to the corresponding SecurePipe components on the Application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_819.jpg"/>
</Figure>

<Lbl>SecurePipe </Lbl>

<LBody>on the Application processes the request received from the Client by decrypting it and then forwards the decrypted message to the Application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_820.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>sends a logout request. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_821.jpg"/>
</Figure>

<Lbl>Application </Lbl>

<LBody>destroys the SecurePipe.There are two components of the Secure Pipe pattern: the client-side component and </LBody>
</LI>
</L>

<P>the server-side component. These components work together to establish a secure communication. Typically, these components would be SSL or TLS libraries that the client's Web browser and the application use for secure communications. </P>
<Figure id="LinkTarget_2736">

<ImageData src="images/4-Security Pattern Catalog_img_822.jpg"/>
Implementation</Figure>

<P>There are several strategies for implementing a Secure Pipe pattern, each with its own set of benefits and drawbacks. Those strategies include: web-server-based SSL/TLS, hardware-based cryptographic accelerator cards, application-layer encryption using the Java Cryptography Extension (JCE). </P>

<P>All major Web-server vendors support SSL. All it takes to implement SSL is to obtain or create server credentials from a CA, including the server X.509certificate, and configure the Web server to use SSL with these credentials. Before enabling SSL, the Web server must be security-hardened to prevent compromise of the server's SSL credentials. Since these credentials would be stored on the Web server, if that server were compromised, an attacker could gain access to the server's credentials (including the private key associated with the certificate)and would then be able to impersonate the server. To enhance SSL performance, a specialized hardware referred to as SSL accelerators can be used to assist with cryptographic computations. When a new SSL session is established, the Web server will use the SSL accelerator hardware to accept the SSL connection and perform the necessary cryptographic calculations for verifying certificates, encrypting session keys, and so forth instead of having the server CPU perform these calculations in software. SSL acceleration improves Web application performance by relieving servers of complex public key operations, bulk encryption, and high SSL traffic volumes. A network appliance is a stand-alone piece of hardware dedicated to a particular purpose. In this strategy, we refer to network appliances that act as dedicated SSL/TLS endpoints. They make use of hardware-based encryption algorithms and optimized network ports. Network appliances move the responsibility for establishing secure connections further out into the perimeter and provide greater performance. They sit out in front of the Web servers and promote a greater degree of reusability, since they can service multiple Web servers and applications. However, the security gap between the Secure Pipe endpoint and the application has widened as the appliance is moved logically and physically further away from the application endpoint on the network. In some cases, Secure Pipe can be implemented in the application layer by making use of Java Secure Socket Extensions (JSSE)framework. JSSE allows enabling secure network communications using Secure Sockets Layer (SSL)and Transport Layer Security (TLS)protocols. It includes functionality for data encryption, server authentication, message integrity, and optional client authentication. Example9-18shows how to create secure RMI connections by implementing an RMI Secure Socket Factory that provides SSL connections for the RMI protocol, which provides a secure tunnel. </P>
<Figure id="LinkTarget_2737">

<ImageData src="images/4-Security Pattern Catalog_img_823.jpg"/>
Pitfalls</Figure>

<P>The Secure Pipe pattern is an integral part of most Web server infrastructures because we make use of SSL/TLS between the client and the Web Server. Without it, mechanisms for ensuring data privacy and integrity must be performed in the application itself, leading to increased complexity, reduced manageability, and the inability to push the responsibility down into the infrastructure. Infrastructure: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_824.jpg"/>
</Figure>

<Lbl>Infrastructure </Lbl>

<LBody>for ensuring data privacy and integrity. Any communication over the Internet or an intranet are subject to attack. Attackers can sniff the wire and steal data, alter it, or resend it. Developers need to protect this data by encrypting it and using digitally signed timestamps, sequence numbers, and checksums. Using industry standards, such as SSL and TLS, developers can secure data that is interoperable with Web browsers and other client applications. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_825.jpg"/>
</Figure>

<Lbl>Data </Lbl>

<LBody>encryption performance. Encryption is an expensive processing task. Hardware devices can increase throughput and response times by performing the necessary cryptographic functions in hardware, freeing up CPU cycles for the application.Web Tier: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_826.jpg"/>
</Figure>

<Lbl>Server </Lbl>

<LBody>certificates. One of the requirements with SSL is public key management and trust models. To solve this problem, certificate authorities were established to act as trusted third parties responsible for the authentication and validation of public keys through the use of digital certificates. Several CA's certificates are packaged in Web browsers and in the Java Runtime Environment's cacerts file. This allows developers to take advantage of client certificate chains to ensure that the requesting client was properly authenticated by a trusted third party. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_827.jpg"/>
</Figure>

<Lbl>Ensures </Lbl>

<LBody>data confidentiality and integrity during communication. The Secure Pipe pattern enforces data confidentiality and integrity using a mixture of encryption and digital signatures. Using SSL/TLS mechanisms, all point-to-point communications links can be secured from man-in-the-middle attacks. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_828.jpg"/>
</Figure>

<Lbl>Promotes </Lbl>

<LBody>interoperability. Using industry-standard infrastructure components to implement the Secure Pipe pattern allows application owners to achieve greater interoperability with clients and partners. By taking advantage of infrastructure products and standard protocols like SSL/TLS, IPSEC, application-level interoperability can be achieved between Web browser clients and Web-server-based applications. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_829.jpg"/>
</Figure>

<Lbl>Improves </Lbl>

<LBody>performance. Delegating CPU-intensive cryptographic operations into hardware infrastructure often shows performance benefits. Strategies such as SSL accelerators and network appliances often demonstrated quadruple performance over application layer processing. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_830.jpg"/>
</Figure>

<Lbl>Reduces </Lbl>

<LBody>complexity. The Secure Pipe pattern reduces complexity by separating complex cryptographic algorithms and procedures from application logic. The details associated with providing secure communications can be pushed down into the infrastructure, thus freeing up the application to focus on business logic rather than security.Will Secure Pipe impact </LBody>
</LI>
</L>
<Figure id="LinkTarget_2738">

<ImageData src="images/4-Security Pattern Catalog_img_831.jpg"/>
Consequences</Figure>

<P>performance?Using a Secure Pipe will certainly impact performance noticeably. Do not use it when it is not required. Many business cases dictate securing sensitive information and therefore a Secure Pipe must be used. If your Web application mandates the need for protecting passwords and sensitive information in transit, use a Secure Pipe (such as HTTPS)just for those operations. Otherwise, you may conduct all other transactions over standard HTTP communication. </P>

<P>Are there any compatibility issues with Secure Pipe?Implementing a Secure Pipe requires an agreement between the communicating peers. The client and the server must support the same cryptographic algorithms and key lengths as well as agree upon a common protocol for exchanges keys. SSL and TLS provide standard protocols for ensuring this compatibility by providing handshake mechanisms that allow clients and servers to negotiate algorithms and key lengths. </P>
<Figure id="LinkTarget_2739">

<ImageData src="images/4-Security Pattern Catalog_img_832.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2740">Secure Service Facade </P>
<Figure id="LinkTarget_2741">

<ImageData src="images/4-Security Pattern Catalog_img_833.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: You need a secure gateway mandating and governing security on client requests, exposing a uniform, coarse-grained service interface over fine-grained, loosely coupled business services that mediates client requests to the appropriate services. </P>
<Figure id="LinkTarget_2742">

<ImageData src="images/4-Security Pattern Catalog_img_834.jpg"/>
Problem</Figure>

<P>Having more access points in the Business tier leads to more opportunities for security holes. Every access point is then required to enforce all security requirements from authentication and authorization to data validation and auditing. This becomes exacerbated in applications that have existing Business-tier services that are not secured. </P>

<P>Retrofitting security to security-unaware services is often difficult. Clients must not be made aware of the disparities between service implementations in terms of security requirements, message specifications, and other service-specific attributes. Offering a unified interface that couples the otherwise decoupled business services makes the design more comprehensible to clients and reduces the work involved in fulfilling client requests. </P>
<Figure id="LinkTarget_2743">

<ImageData src="images/4-Security Pattern Catalog_img_835.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_836.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to off-load security implementations from individual service components and perform them in a centralized fashion so that security developers can focus on security implementation and business developers can focus on business components. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_837.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to impose and administer security rules on client requests that the service implementers are unaware of in order to ensure that authentication, authorization, validation, and auditing are properly performed on all services. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_838.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want a framework to manage the life cycle of the security context between interactive service invocations by clients and to propagate the security context to appropriate servers where the services are implemented. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_839.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to reduce the coupling between fine-grained services but expose a unified aggregation of such services to the client through a simple interface that hides the complexities of interaction between individual services while enforcing all of the overall security requirements of each service. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_840.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to minimize the message exchange between the client and the services, storing the intermittent state and context on the server on behalf of the client instead. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2744">

<ImageData src="images/4-Security Pattern Catalog_img_841.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2745">

<ImageData src="images/4-Security Pattern Catalog_img_842.jpg"/>
Solution</Figure>

<P>Use a Secure Service Facade to mediate and centralize complex interactions between business components under a secure session. </P>

<P>Use a Secure Session Facade to integrate fine-grained, security-unaware service implementation and offer a unified, security-enabled interface to clients. The Secure Service Facade acts as a gateway where client requests are securely validated and routed to the appropriate service implementations, often maintaining and mediating the security and workflow context between interactive client requests and between fine-grained services that fulfill portions of the client requests. </P>
<Figure id="LinkTarget_2746">

<ImageData src="images/4-Security Pattern Catalog_img_843.jpg"/>
Structure</Figure>

<P>Figure 1 illustrates a Secure Service Facade class diagram. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_844.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_844.jpg"/>
</Figure>

<P>Figure 1: Class layout of the Secure Service Facade. </P>
<Figure id="LinkTarget_2747">

<ImageData src="images/4-Security Pattern Catalog_img_845.jpg"/>
Dynamics</Figure>

<P>Figure 2 depicts a sequence diagram for a typical Secure Service Facade implementation that corresponds to the structure description in the preceding section. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_846.jpg"/>
</Figure>

<P>Figure 2: Sequence diagram for the Secure Service Facade. </P>

<P>The fine-grained business services are not directly exposed to the client. The services themselves maintain loose coupling between each other and the fa Ã§ ade. The fa Ã§ ade takes the responsibility of unifying the individual services in the context of the client request. The service fa Ã§ ade contains no business logic itself and therefore requires no protection. </P>
<Figure id="LinkTarget_2748">

<ImageData src="images/4-Security Pattern Catalog_img_847.jpg"/>
Participants</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_848.jpg"/>
</Figure>
Client. A client sends a request to perform a specific task with the appropriate service descriptors to the Secure Service Facade, optionally incorporating the decision-tree predicates to determine the sequence services to be invoked. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_849.jpg"/>
</Figure>
The Secure Service Facade deciphers the client request, verifies authentication, fulfills the request, and returns the results to the client. In doing so, it may use the following components: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_850.jpg"/>
</Figure>

<Lbl>Security </Lbl>

<LBody>Framework. The fa Ã§ ade uses the existing enterprise-wide security framework implemented using other security patterns discussed in this book. Such a framework can be leveraged for authentication, authorization and access control, security assertions, trust management, and so forth. If the request is missing any credentials, the client request could be terminated or the client could be asked to furnish further credentials. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_851.jpg"/>
</Figure>

<Lbl>Dynamic </Lbl>

<LBody>Service Framework/Service Locator. The fa Ã§ ade uses the Dynamic Service Framework or Service Locator to locate the services that are involved in fulfilling the request. The services could reside on the same host or be distributed throughout an enterprise. In either case, the fa Ã§ ade ensures that the security context established using the security framework is correctly propagated to any service that expects such security attributes. The fa Ã§ ade then establishes the execution logic and invokes each service in the correct order. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2749">

<ImageData src="images/4-Security Pattern Catalog_img_852.jpg"/>
Collaborations</Figure>

<P>The Facade is the endpoint exposed to the client and could be implemented as a stateful session bean or a servlet endpoint. It uses the security framework (implemented using other patterns)to perform security-related tasks applicable to the client request. The framework may request the client to present further credentials if the requested service mandates doing so and if those credentials were not found in the initial client request. The Facade then uses the Dynamic Service Management pattern to locate the appropriate service-provider implementations. The request is then forwarded to the individual services either sequentially, in parallel, or in any complex relationship order as specified in the request description. </P>

<P>If the client request represents an aggregation of fine-grained services, the return messages from previous sequential service invocations can be aggregated and delivered to the subsequent service to achieve a sequential workflow-like implementation. If those fine-grained services are independent of each other, then they can be invoked in parallel and the results can be aggregated before delivering to the client, thus achieving parallel processing of the client request. </P>
<Figure id="LinkTarget_2750">

<ImageData src="images/4-Security Pattern Catalog_img_853.jpg"/>
Implementation</Figure>

<P>The Secure Service Facade manages the complex relationships between disparate participating business services, plugs in security to request fulfillment, and provides a high-level, coarse-grained abstraction to the client. The nature of such tasks opens up multiple choices for implementation flavors, two of which are briefly discussed now. Facade with static relationships between individual service components. The relationship between participating fine-grained services is permanently static in nature. In such cases, the fa Ã§ ade can be represented by an interface that corresponds to the aggregate of the services and can be implemented by a session bean that implements the interface. The session bean life cycle method Create can preprocess the request for security validations. </P>

<P>Facade with dynamic, transient relationships between individual service components. When the sequence of service calls to be invoked by the fa Ã§ ade is dependent upon the prior invocation history in the execution sequence, the decision predicates can be specified in the request semantics and used in the fa Ã§ ade implementations to determine the next service to be invoked. Such an implementation can be highly dynamic in nature, and the decision predicates can incorporate security class and compartment information to enable multilevel security in the fa Ã§ ade implementation. A different flavor can use a simple interface in the fa Ã§ ade, such as a command pattern implementation, and can mandate that the service descriptors be specified in the request message. This allows new services to be plugged-and-played without requiring changes to the fa Ã§ ade interface and is widely used in Web services. </P>
<Figure id="LinkTarget_2751">

<ImageData src="images/4-Security Pattern Catalog_img_854.jpg"/>
Pitfalls</Figure>

<P>The Secure Service Facade pattern is susceptible to code bloating if too much interaction logic is incorporated. However, this can be minimized by appropriate design of the fa Ã§ ade using other common design patterns. As the gateway into the Business tier, the Secure Service Facade serves to limit the touch points between the Web and Web Services tiers and the Business tier. This means that there are fewer entry points that need to be secured and therefore fewer opportunities for security holes to be introduced. Does the Service Facade need to incorporate security?The Secure Service Proxy uses the existing security framework while aggregating fine-grained services. However, security context validation may not be required if other means of authentication and access control are pertinently enforced on the client request before it reaches the fa Ã§ ade. </P>

<P>Does the Secure Service Facade need to perform service aggregation?If the client requests will mostly be fulfilled by a single, fine-grained service component, there is no necessity for aggregation. In such cases, Secure Service Proxy may well suit the purpose. </P>

<P>Does the Secure Service Facade reduce security code duplication?If security context validation is performed by each service component, the validation at the fa Ã§ ade level may turn out to be redundant and wasteful. A planned design could reduce such duplication. </P>
<Figure id="LinkTarget_2752">

<ImageData src="images/4-Security Pattern Catalog_img_855.jpg"/>
Consequences</Figure>

<P>The Secure Service Facade pattern protects the Business-tier services and business objects from attacks that circumvent the Web tier or Web Services tier. The Web tier and the Web Services tier are responsible for upfront authentication and access control. An attacker who has penetrated the network perimeter could circumvent these tiers and access the Business tier directly. The Secure Service Facade is responsible for protecting the Business tier by enforcing the security mechanisms established by the Web and Web Services tiers. By employing the Secure Service Facade pattern, developers and clients can benefit in the following ways: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_856.jpg"/>
</Figure>
Exposes a simplified, unified interface to a client. The Secure Service Facade shields the client from the complex interactions between the participating services by providing a single unified interface for service invocation. This brings the advantages of loose coupling between clients and fine-grained business services, centralized mediation, easier management, and reduces the risks of change management. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_857.jpg"/>
</Figure>
Off-loads security validations from lightweight services. Participating business services in a fa Ã§ ade may be too lightweight to define security policies and incorporate security processing. Secure Service Facade off-loads such responsibility from business services and offers a centralized policy management and administration of centralized security processing tasks, thereby reducing code duplication and processing redundancies. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_858.jpg"/>
</Figure>

<Lbl>Centralizes </Lbl>

<LBody>policy administration. The centralized nature of the Secure Service Facade eases security policy administration by isolating it to a single location. Such centralization also makes it feasible to retrofit infrastructure security to otherwise security-unaware or existing services. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_859.jpg"/>
</Figure>

<Lbl>Centralizes </Lbl>

<LBody>transaction management and incorporates security attributes. As with a generic session fa Ã§ ade, a Secure Service Facade allows applying distributed transaction management over individual transactions of the participating services. Since security attributes are accessible at the same place, transaction management can incorporate such security attributes, offering multilevel, security-driven transaction management. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_860.jpg"/>
</Figure>

<Lbl>Facilitates </Lbl>

<LBody>dynamic, rule-based service integration and invocation. As explained in the preceding&quot;Strategies&quot;section, multiple flavors of fa Ã§ ade implementations offer a very dynamic and flexible integration of business services. Integration rules can incorporate security and message attributes in order to dynamically determine execution sequence. An external Business Rules Engine can also be plugged into such a dynamic fa Ã§ ade. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_861.jpg"/>
</Figure>

<Lbl>Minimize </Lbl>

<LBody>message exchange between client and services. Secure Service Facade minimizes message exchange by caching the intermittent state and context on the server rather than on the client.The following security factors are addressed by the Secure Service Facade: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_862.jpg"/>
</Figure>

<Lbl>authentication </Lbl>

<LBody>The Secure Session Facade pattern authenticates requests coming into the Business tier. This is often necessary when clients connect directly to the Business tier through a remote interface or in cases where the Web tier cannot be trusted to perform authentication appropriately for the Business tier. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_863.jpg"/>
</Figure>

<Lbl>auditing </Lbl>

<LBody>The Secure Session Facade enables developers to insert auditing at the entry and exit points of the Business tier. This enables them to put an Audit Interceptor pattern, discussed earlier in this chapter, in place and decouple auditing from business logic while ensuring that no requests can be initiated without first being audited. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2753">

<ImageData src="images/4-Security Pattern Catalog_img_864.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2754">Secure Session Object </P>
<Figure id="LinkTarget_2755">

<ImageData src="images/4-Security Pattern Catalog_img_865.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: You need to facilitate distributed access and seamless propagation of security context and client sessions in a platform-independent and location-independent manner. </P>
<Figure id="LinkTarget_2756">

<ImageData src="images/4-Security Pattern Catalog_img_866.jpg"/>
Problem</Figure>

<P>A multi-user, multi-application distributed system needs a mechanism to allow global accessibility to the security context associated with a client session and secure transmission of the context among the distributed applications, each with its own address space. While many choices are possible, the developer must design a standardized structure and interface to the security context. The security context propagation is essential within the application because it is the sole means of allowing different components within the application to verify that authentication and access control have been properly enforced. Otherwise, each component would need to enforce security and the user would wind up authenticating on each request. The Secure Session Object pattern serves this purpose. </P>
<Figure id="LinkTarget_2757">

<ImageData src="images/4-Security Pattern Catalog_img_867.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_868.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to define a data structure for the security context that comprises authentication and authorization credentials so that application components can validate those credentials. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_869.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to define a token that can uniquely identify the security context to be shared between applications to retrieve the context, thereby enabling single sign-on between applications. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_870.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to abstract vendor-specific session management and distribution implementations. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_871.jpg"/>
</Figure>

<Lbl>You </Lbl>

<LBody>want to securely transmit the security context across virtual machines and address spaces when desired in order to retain the client's credentials outside of the initial request thread. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2758">

<ImageData src="images/4-Security Pattern Catalog_img_872.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2759">

<ImageData src="images/4-Security Pattern Catalog_img_873.jpg"/>
Solution</Figure>

<P>Use a Secure Session Object to abstract encapsulation of authentication and authorization credentials that can be passed across boundaries. You often need to persist session data within a single session or between user sessions that span an indeterminate period of time. In a typical Web application, you could use cookies and URL rewriting to achieve session persistence, but there are security, performance, and network-utilization implications of doing so. Applications that store sensitive data in the session are often compelled to protect such data and prevent potential misuse by malicious code (a Trojan horse)or a user (a hacker). Malicious code could use reflection to retrieve private members of an object. Hackers could sniff the serialized session object while in transit and misuse the data. Developers could unknowingly use debug statements to print sensitive data in log files. Secure Session Object can ensure that sensitive information is not inadvertently exposed. The Secure Session Object provides a means of encapsulating authentication and authorization information such as credentials, roles, and privileges, and using them for secure transport. This allows components across tiers or asynchronous messaging systems to verify that the originator of the request is authenticated and authorized for that particular service. It is intended that this serves as an abstract mechanism to encapsulate vendor-specific implementations. A Secure Session Object is an ideal way to share and transmit global security information associated with a client. </P>
<Figure id="LinkTarget_2760">

<ImageData src="images/4-Security Pattern Catalog_img_874.jpg"/>
Structure</Figure>

<P>The class diagram of the secure session object is included in Figure 1 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_875.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_875.jpg"/>
</Figure>

<P>Figure 1: Secure session object class diagram. </P>
<Figure id="LinkTarget_2761">

<ImageData src="images/4-Security Pattern Catalog_img_876.jpg"/>
Dynamics</Figure>

<P>The dynamics of the secure session object are depicted in Figure 2 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_877.jpg"/>
</Figure>

<P>Figure 2: Secure session object dynamics. </P>
<Figure id="LinkTarget_2762">

<ImageData src="images/4-Security Pattern Catalog_img_878.jpg"/>
Participants</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_879.jpg"/>
</Figure>
Client. The Client sends a request to a Target resource. The Client receives a SecureSessionObject and stores it for submitting in subsequent requests. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_880.jpg"/>
</Figure>
SecureSessionObject. SecureSessionObject stores information regarding the client and its session, which can be validated by consumers to establish authentication and authorization of that client. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_881.jpg"/>
</Figure>
Target. The Target creates a SecureSessionObject. It then verifies the SecureSessionObject passed in on subsequent requests. </P>
<Figure id="LinkTarget_2763">

<ImageData src="images/4-Security Pattern Catalog_img_882.jpg"/>
Collaborations</Figure>

<P>The Secure Session Object is implemented through the following steps: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_883.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>accesses a Target resource. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_884.jpg"/>
</Figure>

<Lbl>Target </Lbl>

<LBody>creates a SecureSessionObject. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_885.jpg"/>
</Figure>

<Lbl>Target </Lbl>

<LBody>serializes SecureSessionObject and returns it in response. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_886.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>needs to access Target again and serialize SecureSessionObject from the last request. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_887.jpg"/>
</Figure>

<Lbl>Client </Lbl>

<LBody>accesses Target, passing the SecureSessionObject created previously in response to the request. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_888.jpg"/>
</Figure>

<Lbl>Target </Lbl>

<LBody>receives the request and verifies the SecureSessionObject before completing the request. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2764">

<ImageData src="images/4-Security Pattern Catalog_img_889.jpg"/>
Implementation</Figure>

<P>You can use a number of strategies to implement Secure Session Object. The first strategy is using a Transfer Object Member, which allows you to use Transfer Objects to exchange data across tiers. The second strategy is using an Interceptor, which is applicable when transferring data across remote endpoints, such as between tiers. In the Transfer Object Member strategy (see Figure 3 ), the Secure Session Object is passed as a member of the more generic Transfer Object. This allows the target component to validate the Secure Session Object wherever data is passed using a Transfer Object. Because the Secure Session Object is contained within the Transfer Object, the existing interfaces don't require additional instances of the Secure Session Object. This keeps the interfaces from becoming brittle or inflexible and allows easy integration of the Secure Session Object into existing applications with established interfaces. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_890.jpg"/>
</Figure>

<P>Figure 3: Secure session object---Transfer object member strategy. </P>

<P>In the Interceptor Strategy (see Figure 4 ), which is mostly applicable to a distributed client-server model, the client and the server use appropriate interceptors to negotiate and instantiate a centrally managed Secure Session Object. This session object glues the client and server interceptors to enforce session security on the client-server communication. The client and the server interceptors perform the initial handshake to agree upon the security mechanisms for the session object. The client authenticates to the server and retrieves a reference to the session object via a client interceptor. The reference could be as simple as a token or a remote object reference. After the client has authenticated itself, the server interceptor uses a session object factory to instantiate the Secure Session Object and returns the reference of the object to the client. The client and the server interceptors then exchange messages marshalled and unmarshalled according to the security context maintained in the Secure Session Object. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_891.jpg"/>
</Figure>

<P>Figure 4: Secure session object---Interceptor strategy. </P>

<P>This strategy offers the ability to update or replace the security implementations in the interceptors independently of one another. Moreover, any change in the Secure Session Object implementation causes changes only in the interceptors instead of the whole application. </P>
<Figure id="LinkTarget_2765">

<ImageData src="images/4-Security Pattern Catalog_img_892.jpg"/>
Pitfalls</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_893.jpg"/>
</Figure>
Authentication. The Secure Session Object enforces authentication of clients requesting Business-tier components. Target components or interceptors for those components can validate the Secure Session Object passed in on request and therefore assure that the invoking client was properly authenticated. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_894.jpg"/>
</Figure>
Authorization. The Secure Session Object can enforce authorization on Business-tier clients as well. While it provides a coarse-grained level of authorization, just by being in the request or not it can be extended to include and enforce fine-grained authorization.Is Secure Session Object too bloated?Abstracting all session information into a single composite object may increase the object size. Serializing and de-serializing such an object quite frequently degrades performance. In such cases, one could revisit the object design or serialization routines to alleviate the performance degradation. </P>

<P>Concurrency implications. Many components associated with the client session could be competing to update and read session data, which could lead to concurrency issues such as long wait times or deadlocks. A careful analysis of the possible scenarios is recommended. </P>
<Figure id="LinkTarget_2766">

<ImageData src="images/4-Security Pattern Catalog_img_895.jpg"/>
Consequences</Figure>

<P>The Secure Session Object prevents a form of session hijacking that could occur if session context is not propagated and therefore not checked in the Business tier. This happens when the Web tier is distributed from the Business tier. This also applies to message passing over JMS as well. The ramifications of not using a Secure Session Object are that impersonation attacks can take place from inside the perimeter. By employing the Secure Session Object pattern, developers benefit in the following ways: Controlled access and common interface to sensitive information. The Secure Session Object encapsulates all sensitive information related to session management and communication establishment. It can then restrict access to such information, encrypt with complete autonomy, or even block access to information that is inappropriate to the rest of the application. A common interface serves all components that need access to the rest of the session data and offers an aggregate view of session information. </P>

<P>Optimized security processing. Since Secure Session Object can be reused over time, it minimizes repetition of security tasks such as authentication, secure connection establishment, and encryption and decryption of shared, static data. </P>

<P>Reduced network utilization and memory consumption. Centralizing management and access to a Secure Session Object via appropriate references and tokens minimizes the amount of session information exchanged between clients and servers. Memory utilization is also optimized by sharing security context between multiple components. </P>

<P>Abstract vendor-specific session management implementations. The Secure Session Object pattern provides a generic data structure for storing and retrieving vendor-specific session management information. This reduces the dependency on a particular vendor and promotes code evolution. </P>
<Figure id="LinkTarget_2767">

<ImageData src="images/4-Security Pattern Catalog_img_896.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2768">Security Association </P>
<Figure id="LinkTarget_2769">

<ImageData src="images/4-Security Pattern Catalog_img_897.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Define a structure which provides each participant in a secure communication with the information it will use to protect messages to be transmitted to the other party, and with the information which it will use to understand and verify the protection applied to messages received from the other party. </P>
<Figure id="LinkTarget_2770">

<ImageData src="images/4-Security Pattern Catalog_img_898.jpg"/>
Problem</Figure>

<P>Instantiating thepattern to protect messages in a communications channel is expensive and often slow, because it requires cryptographic operations to authenticate partners and exchange keys, and it often requires negotiating which protection services need to be applied to the channel. When two parties want to communicate securely they often want to send more than one message, but the cost of creating an instance of thefor each message would be prohibitive. Therefore it is desirable to enable an instance ofto protect more than one message. Doing this requires storing a variety of security-related state information at each end of the communications channel. The Security Association pattern defines what state information needs to be stored, and how it is created during the establishment of an instance of thepattern. </P>
<Figure id="LinkTarget_2771">

<ImageData src="images/4-Security Pattern Catalog_img_899.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_900.jpg"/>
</Figure>

<Lbl>Thepattern </Lbl>

<LBody>is used to protect messages in a communications channel. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_901.jpg"/>
</Figure>

<Lbl>Some </Lbl>

<LBody>security parameters of thepattern are established by negotiation each time communication is initiated, rather than being pre-configured at each endpoint of the communication link out-of-band. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_902.jpg"/>
</Figure>

<Lbl>It </Lbl>

<LBody>is desirable to send multiple messages over a secure communication channel without renegotiating the security parameters of the channel for each message. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2772">

<ImageData src="images/4-Security Pattern Catalog_img_903.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2773">

<ImageData src="images/4-Security Pattern Catalog_img_904.jpg"/>
Solution</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2774">

<ImageData src="images/4-Security Pattern Catalog_img_905.jpg"/>
Structure</Figure>

<P>Figure 1: The structure of the Security Association </P>

<P>The structure of the Security Association is shown in Figure 1 . A Security Association may contain some or all of the following information: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_906.jpg"/>
</Figure>

<Lbl>Association </Lbl>

<LBody>Identifier Used to distinguish this instance of the Security Association pattern from other instances. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_907.jpg"/>
</Figure>

<Lbl>Partner </Lbl>

<LBody>Identifier Used to identify the entity with which this instance of the Security Association pattern enables communication. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_908.jpg"/>
</Figure>

<Lbl>Association </Lbl>

<LBody>Expiration The time after which the instance of the Security Association pattern is no longer valid and must not be used to protect messages. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_909.jpg"/>
</Figure>

<Lbl>Cryptographic </Lbl>

<LBody>Keys Used by the Secure Pipe pattern owning this instance of Security Association to protect messages. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_910.jpg"/>
</Figure>

<Lbl>Quality </Lbl>

<LBody>of Protection (QoP)Settings Used by the Secure Pipe pattern to determine which security services need to be applied to messages. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_911.jpg"/>
</Figure>

<Lbl>Delegation </Lbl>

<LBody>Tokens Used by the Secure Pipe pattern to implement delegation functionality. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2775">

<ImageData src="images/4-Security Pattern Catalog_img_912.jpg"/>
Dynamics</Figure>

<P>Figure 2: Event sequence for the Security Association </P>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2776">

<ImageData src="images/4-Security Pattern Catalog_img_913.jpg"/>
Participants</Figure>

<P>The relations between the participants are shown in Figure 1 . The participants and their responsabilities are: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_914.jpg"/>
</Figure>

<Lbl>Protection </Lbl>

<LBody>Proxy Creates Security Associations and protects messages using information in Security Associations. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_915.jpg"/>
</Figure>

<Lbl>Security </Lbl>

<LBody>Association Defines parameters used to protect messages. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_916.jpg"/>
</Figure>

<Lbl>Security </Lbl>

<LBody>Context Contains information used to set up Security Association. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2777">

<ImageData src="images/4-Security Pattern Catalog_img_917.jpg"/>
Collaborations</Figure>

<P>The interactions between the participants are shown in Figure 2 . </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_918.jpg"/>
</Figure>

<Lbl>Each </Lbl>

<LBody>Protection Proxy creates an instance of Security Association and assigns it a unique Association Identifier. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_919.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Protection Proxies determine the required QoP by reading configuration information or by negotiation with one another. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_920.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>necessary, the Protection Proxies authenticate partner identifiers. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_921.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>necessary, the Protection Proxies exchange session keys. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_922.jpg"/>
</Figure>

<Lbl>Each </Lbl>

<LBody>Protection Proxy determines an expiration time for its Security Association (this will typically be a pre-configured interval, though it might be limited by a variety of factors including remaining key lifetimes). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_923.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>sender's Protection Proxy transmits delegation tokens to the receiver's Protection Proxy, if appropriate. </LBody>
</LI>
</L>

<P id="LinkTarget_2778">Implementation </P>

<P>Security Association can be used to protect both session-oriented and store-and-forward message traffic, but the negotiation and key distribution mechanisms differ for the two types of messaging environments. In general, Security Association instance information can be developed via online, real-time negotiations in session-oriented protocol contexts, whereas they typically need to be derived from configuration information, target object reference information, or information in a directory or other repository in non-session-oriented protocol contexts. </P>
<Figure id="LinkTarget_2779">

<ImageData src="images/4-Security Pattern Catalog_img_924.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2780">

<ImageData src="images/4-Security Pattern Catalog_img_925.jpg"/>
Consequences</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_926.jpg"/>
</Figure>

<Lbl>Permits </Lbl>

<LBody>re-use of a single instance of Secure Pipe to protect more than one message. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_927.jpg"/>
</Figure>

<Lbl>Reduces </Lbl>

<LBody>the time required to set up a Secure Pipe by eliminating the need to renegotiate protection parameters and cryptographic keys. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_928.jpg"/>
</Figure>

<Lbl>Creates </Lbl>

<LBody>a data structure which stores cryptographic key material; this structure needs to be strongly protected against disclosure of keys and against modification of identity information associated with keys. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_929.jpg"/>
</Figure>

<Lbl>Generalized </Lbl>

<LBody>Security Service (GSS-API); the Security Association instances are called ``Security Contexts''. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_930.jpg"/>
</Figure>

<Lbl>OMG </Lbl>

<LBody>CORBASecurity; Security Association instances are called ``Security Contexts''. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2781">

<ImageData src="images/4-Security Pattern Catalog_img_931.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2782">Security Context </P>
<Figure id="LinkTarget_2783">

<ImageData src="images/4-Security Pattern Catalog_img_932.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Provide a container for security attributes and data relating to a particular execution context, process, operation, or action. </P>
<Figure id="LinkTarget_2784">

<ImageData src="images/4-Security Pattern Catalog_img_933.jpg"/>
Problem</Figure>

<P>When a single execution context, program, or process needs to act on behalf of multiple subjects, the subjects need to be differentiated from one another, and information about each subject needs to be made available for use. When an execution context, program, or process needs to act on behalf of a single subject on multiple occasions over a period of time, it needs to be able to have access to information about the subject whenever it needs to take an action. The Security Context pattern provides access to subject information in these cases. </P>
<Figure id="LinkTarget_2785">

<ImageData src="images/4-Security Pattern Catalog_img_934.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_935.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>process or execution context acts on behalf of a single subject over time but needs to establish secure communications with a variety of different partners on behalf of this single subject. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_936.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>process or execution context is able to act on behalf of different subjects and needs to manage which subject is currently active. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2786">

<ImageData src="images/4-Security Pattern Catalog_img_937.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2787">

<ImageData src="images/4-Security Pattern Catalog_img_938.jpg"/>
SolutionStructure</Figure>

<P>Figure 1: Class layout of the Security Context. </P>

<P>See Figure 1 . </P>
<Figure id="LinkTarget_2788">

<ImageData src="images/4-Security Pattern Catalog_img_939.jpg"/>
Dynamics</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_940.jpg"/>
</Figure>

<P>Figure 2: Event sequence for the Security Context. </P>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2789">

<ImageData src="images/4-Security Pattern Catalog_img_941.jpg"/>
Participants</Figure>

<P>See also Figure 1 . </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_942.jpg"/>
</Figure>

<Lbl>Communication </Lbl>

<LBody>Protection Proxy Responsible for establishing Security Associations; used by Secure Communication to apply protection described in Security Association to messages. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_943.jpg"/>
</Figure>

<Lbl>Security </Lbl>

<LBody>Context Stores information about a single subject, including secret attributes such as long-term keys to be used to establish Security Associations. A Communication Protection Proxy may create and retain several security contexts simultaneously, but it must always know which Security Context is active (that is, will be used to establish Security Associations). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_944.jpg"/>
</Figure>

<Lbl>Subject </Lbl>

<LBody>Descriptor Stores the identity-related attributes of a subject. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2790">

<ImageData src="images/4-Security Pattern Catalog_img_945.jpg"/>
Collaborations</Figure>

<P>Whenever a process becomes active in an execution context, the execution context's Communication Protection Proxy creates an instance of Security Context and populates it with the necessary information about the process. The execution context may perform some authentication challenge to verify the identity of the subject before creating a Security Context; the execution context may also set an expiration time for the Security Context to ensure that it is not re-used by a party other than the subject it refers to. </P>
<Figure id="LinkTarget_2791">

<ImageData src="images/4-Security Pattern Catalog_img_946.jpg"/>
Implementation</Figure>

<P>As noted above, the Security Context implementation will need to protect the sensitive information contained within it. </P>

<P>Access control can be implicit, if the system is architected such that only authorized callers can obtain a reference to a Security Context. If it is possible for unauthorized callers to discover references to Security Contexts, the implementation will need to provide accessors which check the authorization of the caller before returning sensitive information. </P>
<Figure id="LinkTarget_2792">

<ImageData src="images/4-Security Pattern Catalog_img_947.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2793">

<ImageData src="images/4-Security Pattern Catalog_img_948.jpg"/>
Consequences</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_949.jpg"/>
</Figure>

<Lbl>Encapsulates </Lbl>

<LBody>security attributes relating to a process and user. Use of Security Context allows a user's security attributes, cryptographic keys, and process security attributes to be handled as a single object. The encapsulation improves maintainability. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_950.jpg"/>
</Figure>

<Lbl>Provides </Lbl>

<LBody>a point of access control. The Security Context will include attributes or accessors allowing callers to retrieve extremely sensitive information (such as long-term cryptographic keys belonging to the subject). This information must be protected against disclosure or misuse. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2794">

<ImageData src="images/4-Security Pattern Catalog_img_951.jpg"/>
Knownuses</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_952.jpg"/>
</Figure>
UNIX--Per-process User Information (``u area'')The UNIX process table includes a ``u area''which stores the identity of the logged-on user as well as the identity of an ``effective user''; the real user and the effective user are the same unless the user identity has been modified by executing a setuid operation. Retention of the real user ID allows switching back to the user's original account after performing operations under the effective (setuid)identity. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_953.jpg"/>
</Figure>
Java2Standard Edition--java. security. AccessControlContext The Java2Access Control Context records the identity of the source of the executing code, together with the identity of the active user. The code source is recorded in a ProtectionDomain object, while the user identity is stored in a Principal object. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_954.jpg"/>
</Figure>
GSS-API--org. ietf. jgss. GSSContext What GSS-API calls a ``Security Context''is an instance of our Security Association pattern. The GSS-API structure which instantiates the Security Context pattern is the GSS Credential, which records the name and cryptographic key of the subject, together with an indication of whether the GSS Credential can be used to initiate outgoing GSS Security Contexts, or only to accept incoming GSS Security Contexts. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_955.jpg"/>
</Figure>
CORBA--SecurityLevel2:: Current CORBASecurity's Current object (which represents an execution context)creates and stores three CORBA Credential objects; these objects are instances of Security Context; each Credential object contains information about a subject; the InvocationCredential object always refers to the active subject, and it is used by the Communications Protection Proxy (called a Security Interceptor)of the CORBA ORB (which is an instance of the Secure Pipe pattern)to create CORBASecurity Context objects (which are instances of our Security Association pattern). </P>

<P id="LinkTarget_2795">Server Sandbox </P>
<Figure id="LinkTarget_2796">

<ImageData src="images/4-Security Pattern Catalog_img_956.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Many site defacements and major security breaches occur when a new vulnerability is discovered in the Web server software. Yet most Web servers run with far greater privileges than are necessary. The Server Sandbox pattern builds a wall around the Web server in order to contain the damage that could result from an undiscovered bug in the server software. </P>

<P>Aliases: Privilege Drop, Untrusted Server, Constrained Execution Environment, Unprivileged/Restricted User Account, Run as Nobody </P>
<Figure id="LinkTarget_2797">

<ImageData src="images/4-Security Pattern Catalog_img_957.jpg"/>
Problem</Figure>

<P>A server-based application is typically exposed to a huge number of potentially malicious users. Any application that processes user input could potentially be tricked into performing actions that it was never intended to perform. For example, many Web servers contain logic errors that can be exploited to allow private files to be served over the Internet. Other servers contain undiscovered buffer overflow errors that can allow client-provided malicious code to be executed on the server. </P>

<P>While every attempt should be made to prevent these types of errors, it is impossible to anticipate every possible attack beforehand. Therefore, it is prudent to deploy a server application in a manner that minimizes the damage that can occur if the server is compromised by a hacker. </P>

<P>Web applications generally require little in the way of privileges once they are started. But by default, many servers and applications install in a manner that gives them unnecessary and dangerous privileges, that if compromised could lead to significant security breach. </P>

<P>For instance, Web servers running on the UNIX operating system must be started with administrative privileges in order to listen on port80---the standard HTTP port---which is a privileged port. Likewise, the Microsoft IIS default installation executes the Web server using the privileged SYSTEM user. If a Web server running with administrative privileges is compromised, an attacker will have complete access to the entire system. This is widely considered the single greatest threat to Web site security. </P>
<Figure id="LinkTarget_2798">

<ImageData src="images/4-Security Pattern Catalog_img_958.jpg"/>
Forces</Figure>

<L>
<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_959.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>process needs enough privileges to perform its function correctly. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_960.jpg"/>
</Figure>
The more privileges a process has, the more privileges a compromised process has. </LI>
</L>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_961.jpg"/>
</Figure>

<Lbl>Implementing </Lbl>

<LBody>fine-grained least-privilege policies in real systems can be cumbersome. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2799">

<ImageData src="images/4-Security Pattern Catalog_img_962.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2800">

<ImageData src="images/4-Security Pattern Catalog_img_963.jpg"/>
Solution</Figure>

<P>The Server Sandbox pattern strictly limits the privileges that Web application components possess at run time. This is most often accomplished by creating a user account that is to be used only by the server. Operating system access control mechanisms are then used to limit the privileges of that account to those that are needed to execute, but not administer or otherwise alter, the server. </P>

<P>This approach accommodates systems that require administrative privileges to start the application, but do not need those privileges during normal operation. The most common example of this is a UNIX server application that must listen on a privileged port. The application can start with additional privileges, but once those privileges are no longer needed, it executes a privilege drop, from which it cannot return, into the less privileged operating mode. </P>

<P>There are a number of different operating system specific privilege drop mechanisms. Some of the more common are: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_964.jpg"/>
</Figure>

<Lbl>An </Lbl>

<LBody>application can switch the user account under which it is executing at run-time. For example, a UNIX application can switch from running with administrator privileges to a specific server account or even the nobody account. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_965.jpg"/>
</Figure>

<Lbl>An </Lbl>

<LBody>application can inform the operating system that it wishes to drop certain privileges dynamically. This is common in capability-based systems, where the operating system dynamically maintains a list of application capabilities. In Linux, an application can ask the operating system to make entire APIs invisible for the remainder of the lifetime of that process. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_966.jpg"/>
</Figure>

<Lbl>An </Lbl>

<LBody>application can instruct the operating system to no longer accept any changes that it requests. For example, once a Linux system has fully booted, it can instruct the operating system to no longer allow kernel modules to be dynamically loaded, even by the administrative account. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_967.jpg"/>
</Figure>

<Lbl>An </Lbl>

<LBody>application can be executed within a virtualized file system. The UNIX chroot option allows the application to think it can see the actual file system, when in fact it only sees a small branch set aside for that application. Any changes to the </LBody>
</LI>
</L>

<P>system files it sees will not affect the actual system files.The Server Sandbox pattern also requires that the remainder of the system hosting the server be hardened. Many operating systems allow all user accounts to access certain global resources. A server sandbox should remove any global privileges that are not essential and replace them specific user and group privileges. A compromised Web server will allow an external hacker to gain access to all global resources. Eliminating the global privileges will ensure that the hacker will not have access to useful (and potentially vulnerable)utilities and operating system features. </P>

<P>The Server Sandbox pattern partitions the privileges required by the server between those needed at server startup and those needed during normal operation. For example, UNIX systems require administrative privileges to create a server listening on port80, the standard HTTP port. However, the server should not possess administrative privileges at run-time. A server sandbox allows dangerous privileges to be used to create the server but then revoked before the server is exposed to client input. </P>

<P>While the most common implementation of the Server Sandbox pattern relies on a restricted user account, other (additional)implementations are possible, including: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_968.jpg"/>
</Figure>

<Lbl>Creating </Lbl>

<LBody>a virtual file system and restricting the server so that it cannot see files outside of this space (chroot). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_969.jpg"/>
</Figure>

<Lbl>Putting </Lbl>

<LBody>wrappers around dangerous components that limit the application's ability to access resources and operating system APIs </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_970.jpg"/>
</Figure>

<Lbl>Using </Lbl>

<LBody>operating system network filtering to prevent the server from initiating connections to other machines </LBody>
</LI>
</L>
<Figure id="LinkTarget_2801">

<ImageData src="images/4-Security Pattern Catalog_img_971.jpg"/>
Structure</Figure>

<P>See Figure 1 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_972.jpg"/>
</Figure>

<P>Figure 1: Server sandbox structure. </P>
<Figure id="LinkTarget_2802">

<ImageData src="images/4-Security Pattern Catalog_img_973.jpg"/>
Dynamics</Figure>

<P>See Figure 2 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_974.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_974.jpg"/>
</Figure>

<P>Figure 2: Server sandbox dynamics. </P>
<Figure id="LinkTarget_2803">

<ImageData src="images/4-Security Pattern Catalog_img_975.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_976.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Application needs a number of Resources to function correctly. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_977.jpg"/>
</Figure>

<Lbl>Each </Lbl>

<LBody>of the Resources are managed by the Operating System . Applications </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_978.jpg"/>
</Figure>

<Lbl>also </Lbl>

<LBody>have associated Privileges , that allow them to request certain Resources from the Operating System . </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_979.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Application requests a Resource from the Operating System. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_980.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Operating System checks if the Application is privileged to use this Resource. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_981.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Operating System assigns the Resource to the Application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_982.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Application then drops its extra privileges. As explained in the solution above, this can happen in multiple ways. We assume here that the Application is able to request of the Operating System to drop its privileged state. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2804">

<ImageData src="images/4-Security Pattern Catalog_img_983.jpg"/>
Collaborations</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_984.jpg"/>
</Figure>
Next, the application uses the assigned Resource and continues operating in an unprivileged state. </P>
<Figure id="LinkTarget_2805">

<ImageData src="images/4-Security Pattern Catalog_img_985.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2806">

<ImageData src="images/4-Security Pattern Catalog_img_986.jpg"/>
Pitfalls</Figure>

<P>It is critical that the application be developed within the envisioned constrained environment. Attempting to add the constrained environment after the fact generally breaks the application and often results in the constrained environment being unnecessarily relaxed in order to resolve the problem. For example, most IIS applications are developed using the standard, insecure configuration, in which IIS executes as SYSTEM. If an individual administrator attempts to configure his or her server more securely and run IIS using a less privileged account, many of these applications will fail to execute properly. </P>

<P>Building the application within the constrained environment also ensures that any performance or resource usage impact will be uncovered early in development. </P>

<P>It is important to document the security configuration in which the system is expected to execute. If the application requires specific privileges to specific files and services, this information must be provided to the administrator configuring the system. It is not sufficient to merely provide an installation script that sets all the appropriate options, because many administrators need to finetune the installation afterwards or install other applications that may alter the security configuration of the system. If the administrator is not aware of the minimum required privileges, he or she may give the application unneeded---and potentially dangerous---privileges. This often translates to executing the application with full administrative privilege. </P>

<P>Many operating systems install in an insecure state. Employ general hardening techniques to eliminate weaknesses. On many systems, the Operating System access control model can be bypassed. If an outsider is able gain control over a general user account, it can be fairly straightforward to exploit a weakness in a system application to gain root/administrator privileges. If possible, the restricted user account should be limited to executing only those programs that it requires. </P>

<P>There are a number of possible attacks that could be perpetrated against this pattern: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_987.jpg"/>
</Figure>

<Lbl>buffer </Lbl>

<LBody>overflow attacks buffer overflow attacks on the server are the most common approach to remote compromise of the server. The sandbox is intended to contain the damage of such an attack. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_988.jpg"/>
</Figure>

<Lbl>privilege </Lbl>

<LBody>escalation ---if an attacker is able to compromise a Web server, even one running as nobody, they will be able to execute code on the system. Attackers typically attempt to break out of the sandbox by exploiting vulnerabilities in other privileged applications, such as sendmail. If a vulnerable, privileged application is accessible to the restricted user account, a privilege escalation attack is possible. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_989.jpg"/>
</Figure>

<Lbl>breaking </Lbl>

<LBody>out of the sandbox ---if the sandbox mechanism contains bugs, an attacker may be able to exploit them to break out of the sandbox. If the attacker can somehow gain root privilege, many sandbox features (such as chroot)are reversible. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_990.jpg"/>
</Figure>

<Lbl>snooping </Lbl>

<LBody>---if an attacker is able to exploit a server vulnerability and gain a toehold on the system, they may have enough privilege to monitor further server operations. They could capture passwords or other sensitive data. If the server has privileges to access a back-end database, the attacker will have those same privileges. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_991.jpg"/>
</Figure>

<Lbl>application </Lbl>

<LBody>level exploits ---even if the server is perfectly sandboxed, it may still suffer from application-level vulnerabilities. The remote attacker may not have to compromise the server in order to misuse its services. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2807">

<ImageData src="images/4-Security Pattern Catalog_img_992.jpg"/>
Consequences</Figure>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_993.jpg"/>
</Figure>
Manageability: This pattern will affect the manageability of the software in question because constrained execution environments often incur overhead to setup and maintain. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_994.jpg"/>
</Figure>
Performance: This pattern will often have a negative effect on performance, but this will depend on the specific techniques </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_995.jpg"/>
</Figure>

<P>used. Using chroot or unprivileged user accounts do not affect performance. Other techniques that impose additional runtime validity checks will incur a performance penalty. Cost: This pattern will increase development costs somewhat. This can be minimized if the application is developed with the constraints already in place. Retrofitting an existing application is much more difficult. </P>
<Figure id="LinkTarget_2808">

<ImageData src="images/4-Security Pattern Catalog_img_996.jpg"/>
Knownuses</Figure>

<P>At the code level, Java provides the most widely known implementation of a sandbox. It prevents the user from using features and functions that are outside of the Java security policy. </P>

<P>At the system level, the canonical example of this pattern is the Apache Web server, which by default runs as user nobody. Although root privileges are required to start the server on port80, the server drops into the nobody account after initialization. The nobody account is able to read (but not write)all of the public html files on the server. But a well-configured server will disallow the nobody account from executing any commands or reading any other files. </P>

<P>Similarly, the Netscape Enterprise Server (iPlanet Web server)for UNIX uses the nobody account. If it is instructed to listen on a privileged (&lt;1024)port, it must be started as root. However, once the port is established, it switches to the nobody account before accepting client connections. </P>

<P>At the network level, it is common practice to place a Web server outside the corporate firewall, or in a Demilitarized Zone (DMZ)between the Internet and the internal network. In either case, a firewall separates the Web server from the rest of the internal network. This is an example of a network-level server sandbox: the Web server is only allowed to connect to a handful of specific ports on one or more specific trusted machines on the internal network. In some configurations, the connections must be initiated from the internal network---in this case, the DMZ represents a sandbox in the purest sense. </P>

<P id="LinkTarget_2809">Session Failover </P>

<P id="LinkTarget_2810">Pattern documentation </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_997.jpg"/>
</Figure>
<Figure id="LinkTarget_2811">

<ImageData src="images/4-Security Pattern Catalog_img_998.jpg"/>
Quickinfo</Figure>

<P>Intent: Avoid inconveniencing users that lose session data in a system restart. </P>
<Figure id="LinkTarget_2812">

<ImageData src="images/4-Security Pattern Catalog_img_999.jpg"/>
Problem</Figure>

<P>While using a system with Sessions and Keep Session Data in the Server, all requests from a user within a session needs to be handled by the server instance that holds the session data. If the server becomes unavailable, for instance due to a crash or scheduled maintenance, the user will lose all session data and have to start over. How can we avoid inconveniencing users in this way?Can we avoid it without making the system overly complicated? </P>
<Figure id="LinkTarget_2813">

<ImageData src="images/4-Security Pattern Catalog_img_1000.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1001.jpg"/>
</Figure>

<Lbl>Users </Lbl>

<LBody>don't want interruptions in their use of the system. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1002.jpg"/>
</Figure>

<Lbl>Few </Lbl>

<LBody>if any systems are free from needing to be taken off-line for maintenance and upgrades to hardware and software once in a while during their lifetime. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1003.jpg"/>
</Figure>

<Lbl>Connectivity </Lbl>

<LBody>between users and system can be lost with little or no warning due to network problems, hardware failure and software crashes and other problems outside of the control of the system or the user. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1004.jpg"/>
</Figure>

<Lbl>For </Lbl>

<LBody>most systems, it's straightforward to start several instances of the system on one or several computers. However they will run independent of each other, sharing no data, neither system state nor session data. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1005.jpg"/>
</Figure>

<Lbl>Session </Lbl>

<LBody>data from a users session is kept on one instance of the server, so no matter how many server instances are running, only one of them can handle the requests from the user. Should that server instance become unavailable to the user, the session and its associated session data becomes unavailable too, and the user will have to start over. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2814">

<ImageData src="images/4-Security Pattern Catalog_img_1006.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2815">

<ImageData src="images/4-Security Pattern Catalog_img_1007.jpg"/>
Solution</Figure>

<P>Add the requirement to Sessions that all session related data must be capable of being made persistent, so it can be transmitted over the network between server instances. </P>

<P>Keep several instances of the system running at all times, preferable on more than one computer and in more than one geographical location. Assign each session to one server instance that will handle all requests on that session. Keep a copy of all session specific data on another instance of the system. When assigning servers to keep copies of Session specific data, keep an eye to minimizing the likelihood that both the server keeping the copy and the server actively servicing the user will be affected by the same network problem. </P>

<P>When a server instance breaks down or becomes inaccessible, let all further events related to its sessions be handled by the system instance that keeps copies of the session scooped data. </P>

<P>To handle the situation where a sizable portion of the server instances becomes unavailable, you can keep more servers online than are needed for handling the load. The extra servers will hold copies of session data, but won't handle requests, until a server handling a session they are holding a copy for becomes unavailable. The smallest possible installation is two server instances running on the same computer, one handling requests, and the other holding copies of all session data. A large scale installation will have servers parked in several cities in different countries and on different continents. </P>

<P>Make sure that in case of server failure, session related transactions on other systems are automatically rolled back. Make sure that when the session is moved to a new server and some roll back back has taken place, the user is somehow made aware of this, and given the opportunity to re-do the steps needed to resubmit it. If the user is another program, this can be done in the form of throwing an exception. </P>

<P>Use a Load Balancer to control when to move a Session, and to direct accesses to a Session to the server instance currently being responsible for it. </P>
<Figure id="LinkTarget_2816">

<ImageData src="images/4-Security Pattern Catalog_img_1008.jpg"/>
Structure</Figure>

<P>The structure of a session failover is included in Figure 1 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1009.jpg"/>
</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1009.jpg"/>
</Figure>

<P>Figure 1: Session Failover structure. </P>
<Figure id="LinkTarget_2817">

<ImageData src="images/4-Security Pattern Catalog_img_1010.jpg"/>
Dynamics</Figure>

<P>The dynamics of a session failover are depicted in Figure 2 . </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1011.jpg"/>
</Figure>

<P>Figure 2: Session Failover dynamics. </P>
<Figure id="LinkTarget_2818">

<ImageData src="images/4-Security Pattern Catalog_img_1012.jpg"/>
Participants</Figure>

<P>Session </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1013.jpg"/>
</Figure>

<Lbl>implements </Lbl>

<LBody>the session pattern. In order for the state of the session to be transmitted to other systems, this session must be serializable. SynchronizationAgent </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1014.jpg"/>
</Figure>

<Lbl>is </Lbl>

<LBody>the workhorse of the session failover, in that it is responsible for collecting the serialized state of all sessions and exchanging it with neighbouring SynchronizationAgents. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1015.jpg"/>
</Figure>

<Lbl>When </Lbl>

<LBody>the SynchronizationAgent receives a message to synchronize its state (this message could be sent periodically, or because of some internal session state change), it serializes the session states by requesting the serialized state from each session it is aware of. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1016.jpg"/>
</Figure>

<Lbl>After </Lbl>

<LBody>the SynchronizationAgent has received all session states, it iterates over all other SynchronizationAgents and sends the collected serialized session states to them. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1017.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>other SynchronizationAgents receive the new session states, and update their internal states accordingly. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2819">

<ImageData src="images/4-Security Pattern Catalog_img_1018.jpg"/>
Collaborations</Figure>
<Figure id="LinkTarget_2820">

<ImageData src="images/4-Security Pattern Catalog_img_1019.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2821">

<ImageData src="images/4-Security Pattern Catalog_img_1020.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2822">

<ImageData src="images/4-Security Pattern Catalog_img_1021.jpg"/>
Consequences</Figure>

<P>Benefits: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1022.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>likelihood that users will see uninterrupted service from the system is increased. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1023.jpg"/>
</Figure>

<Lbl>Scheduling </Lbl>

<LBody>maintenance on servers becomes far less stress-full, because the impact on users is diminishes or even totally removed. As a fringe benefit this can lead to better maintained servers that runs more stable than had Session Failover not been implemented.Liabilities: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1024.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>session data replication functionality is an additional piece of nontrivial code that has to be written, tested and maintained. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1025.jpg"/>
</Figure>

<Lbl>At </Lbl>

<LBody>run time the on-going copying of session data between server instances increases the workload and memory requirement of the servers, which leads to increased costs. If server instances are placed in separate geographical locations, e. g. in two different cities, to guard against network failure, the constant copying of session data between cities takes up bandwidth on either Internet or leased lines. In both cases this comes at a price. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1026.jpg"/>
</Figure>

<Lbl>Handling </Lbl>

<LBody>the case where a session is moved to another server while it was in the middle of a transaction to another system, is at best tricky and in many cases impossible to implement correct. It might be a better choice to drop the session, rather than trying and failing at recovering it on another server instance. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1027.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>requirements for a Load Balancer to handle a system with Session Failover are the same as for a system with Keep Session Data in the Server, and then some. It needs to also be capable of handling the situation where requests within a session must be sent to a new server, after Session Failover has kicked in. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2823">

<ImageData src="images/4-Security Pattern Catalog_img_1028.jpg"/>
Knownuses</Figure>

<P>Application servers: The ATG Dynamo and the BEA WebLogic J2EE application servers and some but not all of their competitors implements Session Failover. </P>

<P>At one point Scandinavian Online ran on four servers, one in Copenhagen, one in Oslo, one in Stockholm and one in Helsinki. Each server handled the requests originating from the country it was situated within, as well as being fail over server for one of the other servers. </P>

<P id="LinkTarget_2824">Session </P>
<Figure id="LinkTarget_2825">

<ImageData src="images/4-Security Pattern Catalog_img_1029.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Many objects need access to shared values, but the values are not unique throughout the system. Aliases: User's Environment, Namespace, Threaded-based Singleton, Localized Globals </P>
<Figure id="LinkTarget_2826">

<ImageData src="images/4-Security Pattern Catalog_img_1030.jpg"/>
Problem</Figure>

<P>Military personnel's activities are tracked while they are in a high-security military installation. Their entry and exit are logged. Their badges must be worn at all times to show they are only where they are supposed to be. Guards inside of the base can assume personnel with a badge have been checked thoroughly at the base entrance. Therefore they only have to perform minimal checks before allowing them into a restricted area. Many people are working in a base at the same time. Each security badge uniquely identifies who that person is and what they can do. It also tracks what the carrier of the badge has been doing. </P>

<P>Secure applications need to keep track of global information used throughout the application such as username, roles, and their respective privileges. When an application needs to keep one copy of some information around, it often uses the Singleton pattern. The Singleton is usually stored in a single global location, such as a class variable. Unfortunately, a Singleton can be difficult to use when an application is multi-threaded, multi-user, or distributed. In these situations, each thread or each distributed process can be viewed as an independent application, each needing its own private Singleton. But when the applications share a common global address space, the single global Singleton cannot be shared. A mechanism is needed to allow multiple ``Singletons'', one for each application. </P>
<Figure id="LinkTarget_2827">

<ImageData src="images/4-Security Pattern Catalog_img_1031.jpg"/>
Forces</Figure>

<L>
<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1032.jpg"/>
</Figure>

<Lbl>Referencing </Lbl>

<LBody>global variables can keep code clean and straightforward. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1033.jpg"/>
</Figure>
Each object may only need access to some of the shared values. </LI>
</L>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1034.jpg"/>
</Figure>

<Lbl>Values </Lbl>

<LBody>that are shared could change over time. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1035.jpg"/>
</Figure>

<Lbl>Multiple </Lbl>

<LBody>applications that run simultaneously might not share the same values. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1036.jpg"/>
</Figure>

<Lbl>Passing </Lbl>

<LBody>many shared objects throughout the application make APIs more complicated. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1037.jpg"/>
</Figure>

<Lbl>While </Lbl>

<LBody>an object may not need certain values, it may later change to need those values. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2828">

<ImageData src="images/4-Security Pattern Catalog_img_1038.jpg"/>
Example</Figure>

<P>A Session can be used to store many different kinds of information in addition to security data. The Caterpillar/NCSA Financial Model Framework has a FMState class (See http://www. uiuc. edu/ph/www/j-yoder/financial\_framework). An FMState object serves as a Session. It provides a single location for application components to access a Limited View of the data, the current products that can be selected, the user's Role, and the state of the system. Most of the classes in the Financial Model keep a reference to an FMState. A true Singleton could not be used because a user can open multiple sessions with different selection criteria, each yielding a different Limited View. Figure 1 shows FMState from the Financial Model. Security info includes username and role. The security info and selection criteria define the limited views. Each ReportView and ReportModel has a reference back to the FMState so it can access other data. </P>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1039.jpg"/>
</Figure>

<P>Figure 1: FMState, a Session example. </P>
<Figure id="LinkTarget_2829">

<ImageData src="images/4-Security Pattern Catalog_img_1040.jpg"/>
Solution</Figure>

<P>Create a Session object, which holds all of the variables that need to be shared by many objects. Each Session object defines a namespace, and each variable in a single Session shares the same namespace. The Session object is passed around to objects which need any of its values. Certain user information is used throughout a system. Some of this information is security related, such as the user's role and privileges. A Session object is a good way for sharing this global information. This object can be passed around and used as needed. </P>

<P>Depending on the structure of the class hierarchy, an instance variable for the Session could be added to a superclass common to every class that needs the Session. Many times, especially when extending and building on existing frameworks, the common superclass approach will not work, unless of course you want to extend object which is usually not considered a good design. Thus, usually an instance variable needs to be added to every class that needs access to the Session. </P>

<P>All of the objects that share the same Session have a common scope. This scope is like the environments used by a compiler to perform variable lookups. The principle differences are that the Session's scope was created by the application and that lookups are performed at runtime by the application. </P>

<P>Since many objects hold a reference to the Session, it is a great place to put the current Stateof the application. The State pattern does not have to be implemented inside of the Session for general security purposes, however. Limited View data and Roles can also be cached in a Session. It is important to note that the user should not be allowed to access any security data that may be held within a Session such as passwords and privileges. It can be a good idea to structure any application with a Session object. This object holds onto any shared information that is needed while a user is interacting with the application. </P>
<Figure id="LinkTarget_2830">

<ImageData src="images/4-Security Pattern Catalog_img_1041.jpg"/>
Structure</Figure>

<P>Figure 2: Session structure. </P>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2831">

<ImageData src="images/4-Security Pattern Catalog_img_1042.jpg"/>
Dynamics</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1043.jpg"/>
</Figure>

<P>Figure 3: Session dynamics. </P>

<P>See Figure 3 . </P>
<Figure id="LinkTarget_2832">

<ImageData src="images/4-Security Pattern Catalog_img_1044.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1045.jpg"/>
</Figure>

<Lbl>User </Lbl>

<LBody>The user of the application. A session will be a representation of the relevant attributes of or related to this user. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1046.jpg"/>
</Figure>

<Lbl>Application </Lbl>

<LBody>The application which the user uses. The application defines the context of the session, and can deal with the sessions of multiple, concurrent users. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1047.jpg"/>
</Figure>

<Lbl>Session </Lbl>

<LBody>The session object encapsulates the attributes of or related to a user. A session typically has a unique ID within its context. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1048.jpg"/>
</Figure>

<Lbl>Objects </Lbl>

<LBody>The objects are objects executing operations while the user uses the application. The objects may need to retrieve or store information in the session object. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1049.jpg"/>
</Figure>

<Lbl>When </Lbl>

<LBody>a user starts using an application, a session object for this user is created. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1050.jpg"/>
</Figure>

<Lbl>For </Lbl>

<LBody>each subsequent request of the user, the session object is passed along to the object (s)which will handle the request. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1051.jpg"/>
</Figure>

<Lbl>An </Lbl>

<LBody>object can then use or update the information stored in the session object. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2833">

<ImageData src="images/4-Security Pattern Catalog_img_1052.jpg"/>
Collaborations</Figure>
<Figure id="LinkTarget_2834">

<ImageData src="images/4-Security Pattern Catalog_img_1053.jpg"/>
Implementation</Figure>

<P>Two strategies for storing the session data are possible: </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1054.jpg"/>
</Figure>
Keep Session Data in Server. Keep all session specific data on the server. Assign a unique token to each session, and create the protocols used in communication between users and system so that this token is made part of every interaction. Use this token as a key into the data structure in the server that holds the session specific data for all clients. </P>

<P>Keeping all data on the server and making sure it will never leave the server, means you have no need to write elaborate error checking code to validate data every time it reenters the system from the client. It also frees you from implementing code that converts from the form the data is stored in while in the server (eg. hierarchies of objects)to a form that can be transmitted over the wire between client and server. </P>

<P>Equip the system with mechanisms to validate that the token a user identifies himself with during an access belongs to the user performing the access. Add mechanisms commensurate with the threat and value of identity theft in the system. </P>

<P>Consider the following when choosing this strategy. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1055.jpg"/>
</Figure>

<Lbl>Delay </Lbl>

<LBody>and limited bandwidth between client and server can make it impractical to transfer session specific data from client to server as part of each request. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1056.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>session data is to be provided with each request, it has to be checked for errors that can make the server code fail. If the data is stored in the server this check can be omitted. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1057.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>client might not have enough memory to store the data for its session, even if the amount of data is small. A good example is a tiny embedded system. On the other hand the client might have ample memory (and swap space)to store its session specific data. A common example is a desktop PC running a webbrowser. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1058.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>session specific data is to be kept on the server, a system for mapping incoming requests to the correct bundle of session specific data has to be in place. If looking at other clients session specific data is of value to malicious entities, this mapping system must be capable of withstanding identity spoofing attacks. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1059.jpg"/>
</Figure>

<Lbl>Keeping </Lbl>

<LBody>session data with the client and transmitting it to the server as part of requests can be inconvenient because of the communication protocol being used. An example is data hidden in the html for a web page. The data must be formatted in a certain way that's cumbersome and not very space efficient. The data has to be duplicated for each and every link on the page that must supply session specific data to the server. This leads to slow page loads. </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1060.jpg"/>
</Figure>
Keep Session Data in Client. Keep the session specific data in the client. Transfer all or the necessary subset of it to the server along with each request. Logging out is as simple as no longer contacting the server, because the server is not keeping track of clients. If the client crashes before logging out, no session data is left orphaned anywhere, because it went away with the crashed client. </P>

<P>Consider the following when choosing this strategy. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1061.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>server is too simple to be able to hold on to session data in between requests, or it has too little memory to do so for all concurrent users. An example of the first case is cgi scripts on a webserver. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1062.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>server will be restarted, taken offline or suffer crashes during runtime. Session data will be lost when this happens. Enhancing the server with the ability to let session data live on across system restarts is not feasible for practical or economical reasons. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1063.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>server is really several servers behind a load balancer that directs requests to the least loaded server, so the requests from a client can go to different servers at each request. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1064.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>client making requests on the server must be reliably identified if the request is to be mapped to client specific data in the server. This can very well be hard, unreliable or even impossible, for instance because of the the protocol used for communication (eg. HTTP). </LBody>
</LI>
</L>
<Figure id="LinkTarget_2835">

<ImageData src="images/4-Security Pattern Catalog_img_1065.jpg"/>
Pitfalls</Figure>

<P>If the session specific data is kept in the client, the client can modify this data. Make sure that no critical data can be modified without detection. </P>
<Figure id="LinkTarget_2836">

<ImageData src="images/4-Security Pattern Catalog_img_1066.jpg"/>
Consequences</Figure>

<P>A Session offers the following advantages: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1067.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Session object provides a common interface for all components to access important variables. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1068.jpg"/>
</Figure>

<Lbl>Instead </Lbl>

<LBody>of passing many values around the application separately, a single Session object can be passed around. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1069.jpg"/>
</Figure>

<Lbl>Whenever </Lbl>

<LBody>a new shared variable or object is needed, it can be put in the Session object and then all components that have access to the object will have access to it. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1070.jpg"/>
</Figure>

<Lbl>Change </Lbl>

<LBody>propagation is simplified because each object in a thread or process is dependent on only a single, shared Session object.A Session offers the following disadvantages: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1071.jpg"/>
</Figure>

<Lbl>While </Lbl>

<LBody>an object may not need a Session, it may later create an object that needs the Session. When this is the case, the first object must still keep a reference to the Session so it can pass it to the new object. Sometimes, it may seem as if every object has a Session. The proliferation of Session instance variables throughout the design is an unfortunate, but necessary, consequence of the Session pattern. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1072.jpg"/>
</Figure>

<Lbl>Adding </Lbl>

<LBody>Session late in the development process can be difficult. Every reference to a Singleton must be changed. The authors have experience retrofitting Session in place of Singleton and can attest that this can very tedious when Singletons are spread among several classes. This is also true when trying to consolidate many global variables that were being passed around as parameters into a Session. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1073.jpg"/>
</Figure>

<Lbl>When </Lbl>

<LBody>many values are stored in the Session, it will need some organizational structure. While some organization may make it possible to breakdown a Session to reduce coupling, splitting the session requires a detailed analysis of which components need which subsets of values. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1074.jpg"/>
</Figure>

<Lbl>For </Lbl>

<LBody>VisualWorks, the Lens framework for Oracle and GemBuilder for GemStone have OracleSession and GbsSession classes respectively. Each keeps information such as the transaction state and the database connection. The Sessions are then referenced by any object within the same database context. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1075.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Caterpillar/NCSA Financial Model Framework has a FMState class. An FMState object serves as a Session, while keeping a Limited View of the data, the current product/family selection, and the state of the system. Most of the classes in the Financial Model keep a reference to an FMState. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1076.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>PLoP'98registration program has a Session object that keeps track of the user's global information as they are accessing the application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1077.jpg"/>
</Figure>

<Lbl>Most </Lbl>

<LBody>databases use a Session for keeping track of user information. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1078.jpg"/>
</Figure>

<Lbl>VisualWave </Lbl>

<LBody>has a Session for its httpd services, which keeps track of any web requests made to it. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1079.jpg"/>
</Figure>

<Lbl>UNIX </Lbl>

<LBody>ftp and telnet services use a Session for keeping track of requests and restricting user actions. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2837">

<ImageData src="images/4-Security Pattern Catalog_img_1080.jpg"/>
Knownuses</Figure>

<P id="LinkTarget_2838">Session Timeout </P>
<Figure id="LinkTarget_2839">

<ImageData src="images/4-Security Pattern Catalog_img_1081.jpg"/>
Patterndocumentation</Figure>
<Figure id="LinkTarget_2840">

<ImageData src="images/4-Security Pattern Catalog_img_1082.jpg"/>
Quickinfo</Figure>

<P>Intent: Prevent the system from running out of resources because abandoned sessions are not cleaned up. </P>
<Figure id="LinkTarget_2841">

<ImageData src="images/4-Security Pattern Catalog_img_1083.jpg"/>
Problem</Figure>

<P>You have a system with Sessions where users might abandon their sessions without the system being notified. </P>

<P>After a session has been created, its user will access it zero or more times. At the time of each access the session, and the data stored in the related session scope must be available. However the user might not signal to the system, when he no longer intends to access the session (log out), since the system can be long lived, data related to sessions abandoned in this way, can slowly fill up all available memory on the system. </P>
<Figure id="LinkTarget_2842">

<ImageData src="images/4-Security Pattern Catalog_img_1084.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1085.jpg"/>
</Figure>

<Lbl>Each </Lbl>

<LBody>session in the server takes up some memory and/or permanent storage. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1086.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>system doesn't have an infinite amount of memory and permanent storage in which to store session specific data. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1087.jpg"/>
</Figure>

<Lbl>Session </Lbl>

<LBody>data must be available when a request is made within its session. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1088.jpg"/>
</Figure>

<Lbl>Some </Lbl>

<LBody>sessions will see only infrequent requests. An example is an e-commerce system that polls an inventory tracking system for updates to the inventory once an hour, within a session in the inventory tracking system. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1089.jpg"/>
</Figure>

<Lbl>For </Lbl>

<LBody>some sessions frequent use is the norm, so such a session that has not been used for significantly longer than the typical delay between uses, can be considered abandoned with a high probability. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1090.jpg"/>
</Figure>

<Lbl>Looking </Lbl>

<LBody>at the data in another user's session specific data, or even performing requests on the server using another user's session, can be of some value to malicious entities. If the session being ``hijacked''is abandoned, the likelihood of being caught in the act is lowered. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2843">

<ImageData src="images/4-Security Pattern Catalog_img_1091.jpg"/>
Example</Figure>

<P>Non software example. At a cafeteria where you pay when you order and therefore can leave without notifying a waiter, there is one or more persons whose job it is to periodically go from table to table and clean up leftover service and food from tables whose occupants appears to have left. </P>

<P>If the clean up work is not getting performed fast enough, the cafeteria will run out of free and clean tables, which will turn customers away. If too much cleaning staff is assigned, they will often sit idle, which is a waste of the cafeterias money. </P>
<Figure id="LinkTarget_2844">

<ImageData src="images/4-Security Pattern Catalog_img_1092.jpg"/>
Solution</Figure>

<P>Make a session manager, that runs in the system as a long lived process. Periodically it will iterate over all sessions in the system looking for sessions that has not been accessed for more than a set amount of time. When such a session is found, it's immediately flagged as invalid, so it won't be used any more. Asynchronously another process can delete its session specific data. This can be implemented both for sessions kept entirely in memory, as well as for session stored on permanent media. </P>

<P>A pre-requirement for this solution is that a well defined method for invalidating a session and for deleting its data is implemented in all sessions. These methods can also be used when the client explicitly logs out. </P>

<P>If a user tries to access a session that has been flagged as invalid, or is not known to the system, the user can be informed that his session has expired and all related data removed. The user can be given easy means to get a new session created. In many cases it will be practical to automatically create a new session for the user, and inform him that this has been done, by means of a status flag for machine users, and by means of a textual message in a dialog box for human users. </P>

<P>In the common application servers the time out value is the same for all sessions. However it would be straigtforward to add a property to the session class, so the time out could be set individually for each session. </P>
<Figure id="LinkTarget_2845">

<ImageData src="images/4-Security Pattern Catalog_img_1093.jpg"/>
Structure</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1094.jpg"/>
</Figure>

<P>Figure 1: Class layout of the Session Timeout pattern </P>

<P>See Figure 1 . </P>
<Figure id="LinkTarget_2846">

<ImageData src="images/4-Security Pattern Catalog_img_1095.jpg"/>
Dynamics</Figure>

<P>Figure 2: Event sequence for the Session Timeout pattern </P>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2847">

<ImageData src="images/4-Security Pattern Catalog_img_1096.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1097.jpg"/>
</Figure>

<Lbl>SessionManager </Lbl>

<LBody>The session manager holds a reference to every session in the system. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1098.jpg"/>
</Figure>

<Lbl>Session </Lbl>

<LBody>The session represents a user session. It has the possibility to be invalidated, and can delete its data when needed. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1099.jpg"/>
</Figure>

<Lbl>Timer </Lbl>

<LBody>The timer periodically calls the operation to invalidate inactive sessions. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1100.jpg"/>
</Figure>

<Lbl>CleanupProcess </Lbl>

<LBody>The cleanup process deletes invalidated sessions. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1101.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Timer triggers the SessionManager's flagInvalidSessions method. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1102.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>SessionManager iterates over all sessions, comparing the session's last access time to the current time. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1103.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>the difference is larger than the session timeout. value, it invalidates the session. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1104.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>CleanupProcess looks for invalidated sessions, and deletes their data. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2848">

<ImageData src="images/4-Security Pattern Catalog_img_1105.jpg"/>
Collaborations</Figure>
<Figure id="LinkTarget_2849">

<ImageData src="images/4-Security Pattern Catalog_img_1106.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2850">

<ImageData src="images/4-Security Pattern Catalog_img_1107.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>

<P id="LinkTarget_2851">Consequences </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1108.jpg"/>
</Figure>

<Lbl>Automatically </Lbl>

<LBody>expiring a user's session might lead to confusion or frustration at the end of the user. This decreases the usability. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1109.jpg"/>
</Figure>

<Lbl>On </Lbl>

<LBody>the other hand, automatically closing a user's session improves the the user's privacy. Imagine a user performing an operation using a public computer. If this user herself does not log out and the session would not expire, other people can continue using the original user's session. This might compromise the user's privacy. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1110.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>session timeout is simple to implement, and thus does not lead to high implementation costs. Moreover, by using the pattern other costs (for example for memory or data storage)might be avoided or at least limited. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2852">

<ImageData src="images/4-Security Pattern Catalog_img_1111.jpg"/>
Knownuses</Figure>

<P>Session Timeout is a standard feature of J2EE application servers servers such as ATG Dynamo, Tomcat and BEA WebLogic J2EE.Unix has automatic session expiration capability, not on process level but with regard to user logins. It is mostly activated for the users of systems like public terminals at universities and the like where users might get up and leave, forgetting to log out, and in high security environments where the cost and risk of an abandoned login session being misused are too high to ignore. Unix will expire the login session after a relatively short period of time, such as15minutes. In UNIX the process does the job of Sessions and much more. Code running within a process can not allocate memory itself, it has to obtain it from the system. This is often done by calling the malloc library call, which will obtain memory from the UNIX kernel. Memory is freed up in a similar fashion, calling free, which gives the memory back to the UNIX kernel. This way all memory allocations and deallocations are tracked by the OS, so whenever a process is terminated, all memory that's allocated to code running within it, can be freed. </P>

<P id="LinkTarget_2853">Single Access Point </P>
<Figure id="LinkTarget_2854">

<ImageData src="images/4-Security Pattern Catalog_img_1112.jpg"/>
Patterndocumentation</Figure>
<Figure id="LinkTarget_2855">

<ImageData src="images/4-Security Pattern Catalog_img_1113.jpg"/>
Quickinfo</Figure>

<P>Intent: Reduce the ``attack surface''by imposing a single access point on the system, providing an ideal place to do access control and policy enforcement. </P>

<P>Aliases: Login Window, One Way In, Guard Door, Validation Screen </P>
<Figure id="LinkTarget_2856">

<ImageData src="images/4-Security Pattern Catalog_img_1114.jpg"/>
Problem</Figure>

<P>A military base provides a prime example of a secure location. Military personnel must be allowed in while spies, saboteurs, and reporters must be kept out. If the base has many entrances, it will be much more difficult and expensive to guard each of them. Security is easier to guarantee when everyone must pass through a single guard station. It is hard to provide security for an application that communicates with networking, operating systems, databases, and other infrastructure systems. The application will need a way to log a user into the system, to set up what the user can and can not do, and to integrate with other security modules from systems that it will be interacting with. Sometimes a user may need to be authenticated on several systems. Additionally, some of the user-supplied information may need to be kept for later processing. Single Access Point solves this by providing a secure place to validate users and collect global information needed about users who need to start using an application. </P>

<P>A security model is difficult to validate when it has multiple ``front doors,''``back doors,''and ``side doors''for entering the application. </P>
<Figure id="LinkTarget_2857">

<ImageData src="images/4-Security Pattern Catalog_img_1115.jpg"/>
Forces</Figure>

<P>Having multiple ways to open an application makes it easier for it to be used in different environments. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1116.jpg"/>
</Figure>

<Lbl>An </Lbl>

<LBody>application may be a composite of several applications that all need to be secure. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1117.jpg"/>
</Figure>

<Lbl>Different </Lbl>

<LBody>login windows or procedures could have duplicate code. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1118.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>single entry point may need to collect all of the user information that is needed for the entire application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1119.jpg"/>
</Figure>

<Lbl>Multiple </Lbl>

<LBody>entry points to an application can be customized to collect only the information needed at that entry point. This way, a user does not have to enter unnecessary information. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2858">

<ImageData src="images/4-Security Pattern Catalog_img_1120.jpg"/>
Example</Figure>

<P>There are many examples of Single Access Point. In order to access an NT workstation, there is a single login screen which all users must go through to access the system. This Single Access Point validates the user and insures that only valid users access the system and also provides Roles for only allowing users to see and do what they have permissions to do. Most UNIX systems also have a Single Access Point for getting a console shell. Oracle applications also have many applications such as SQLPlus and the like that provide a Single Access Point as the only means for running those applications. </P>
<Figure id="LinkTarget_2859">

<ImageData src="images/4-Security Pattern Catalog_img_1121.jpg"/>
Solution</Figure>

<P>Set up only one way to get into the system, and if necessary, create a mechanism for deciding which sub-applications to launch. </P>
<Figure id="LinkTarget_2860">

<ImageData src="images/4-Security Pattern Catalog_img_1122.jpg"/>
Structure</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1123.jpg"/>
</Figure>

<P>Figure 1: Single Access Point structure. </P>

<P>See Figure 1 . </P>
<Figure id="LinkTarget_2861">

<ImageData src="images/4-Security Pattern Catalog_img_1124.jpg"/>
Dynamics</Figure>

<P>Figure 2: Event sequence for the Single Access Point. </P>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2862">

<ImageData src="images/4-Security Pattern Catalog_img_1125.jpg"/>
Participants</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1126.jpg"/>
</Figure>

<Lbl>User </Lbl>

<LBody>The user which will use the system. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1127.jpg"/>
</Figure>

<Lbl>Single </Lbl>

<LBody>Access Point The only entrance point to the application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1128.jpg"/>
</Figure>

<Lbl>Decision </Lbl>

<LBody>Point The decision point can decide both about whether a user is allowed into the system or not, and if needed about which sub-applications to launch for te request. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1129.jpg"/>
</Figure>

<Lbl>System </Lbl>

<LBody>The system (possibly composed of sub-systems)which is protected by the single access point. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1130.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>user sends a request through the Single Access Point. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1131.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Single Access Point contacts the decision point to decide whether or not the request is allowed. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1132.jpg"/>
</Figure>

<Lbl>If </Lbl>

<LBody>the request is allowed, it is sent through to the system. Otherwise, an error is returned to the user. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2863">

<ImageData src="images/4-Security Pattern Catalog_img_1133.jpg"/>
Collaborations</Figure>
<Figure id="LinkTarget_2864">

<ImageData src="images/4-Security Pattern Catalog_img_1134.jpg"/>
Implementation</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2865">

<ImageData src="images/4-Security Pattern Catalog_img_1135.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2866">

<ImageData src="images/4-Security Pattern Catalog_img_1136.jpg"/>
Consequences</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1137.jpg"/>
</Figure>

<Lbl>+ </Lbl>

<LBody>A Single Access Point provides a place where everything within the application can be setup properly. This single location can help ensure all values are initialized correctly, application setup is performed correctly, and the application does not reach an invalid state. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1138.jpg"/>
</Figure>

<Lbl>+ </Lbl>

<LBody>Control flow is simpler since everything must go through a single point of responsibility in order for access to be allowed. Note, Single Access Point is only as secure as the steps leading up to it. </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1139.jpg"/>
</Figure>
-The application cannot have multiple entry points to make entering an application easier and more flexible. </P>
<Figure id="LinkTarget_2867">

<ImageData src="images/4-Security Pattern Catalog_img_1140.jpg"/>
Knownuses</Figure>

<P>The following are security-related known uses: </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1141.jpg"/>
</Figure>

<Lbl>UNIX </Lbl>

<LBody>telnet and Windows NT login applications use Single Access Point for logging into the system. These systems also create the necessary Roles for the current Session. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1142.jpg"/>
</Figure>

<Lbl>Most </Lbl>

<LBody>application login screens are a Single Access Point into programs because they are the only way to startup and run the given application. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1143.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>Caterpillar/NCSA Financial Model Frameworkhas a FMLogin class, which provides both Single Access Point and Check Point. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1144.jpg"/>
</Figure>

<Lbl>The </Lbl>

<LBody>PLoP'98registration programprovides a Single Access Point for logging into the system and entering in credit card information when users registered for PLoPÂ¿98. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1145.jpg"/>
</Figure>

<Lbl>Secure </Lbl>

<LBody>web servers, such as Java DeveloperÂ¿s Connection appear to have multiple access points for each URL. However, the web server forces each user through a login window before letting them download early access software.Other, non-security related uses are: </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1146.jpg"/>
</Figure>

<Lbl>Any </Lbl>

<LBody>application that launches only one way, ensuring a correct initial state. </LBody>
</LI>
</L>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1147.jpg"/>
</Figure>
Windows95, also uses a login window which is a Single Access Point, but it is not secure because it allows any user to override the login screen. </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1148.jpg"/>
</Figure>

<Lbl>Single </Lbl>

<LBody>creational methods provide for only one way to create a class. For example, Points in VisualWorks Smalltalkguides you to creating valid points by providing a couple of creational methods that ensure the Object is initialized correctly. Kent BeckÂ¿s describes Constructor Methods as a single way to create well-formed instances of objects. These are put into a single ``instance creation''protocol. This becomes the Single Access Point to create new objects. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1149.jpg"/>
</Figure>

<Lbl>Constructor </Lbl>

<LBody>Parameter Methodinitializes all instance variables through a single method, which is really a Single Access Point for that class to initialize its instance variables. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1150.jpg"/>
</Figure>

<Lbl>Concurrent </Lbl>

<LBody>programs can encapsulate non-concurrent objects inside an object designed for concurrency. Synchronization is enforced through this Single Access Point. Pass-Through Host designdeals with synchronization by forwarding all appropriate methods to the Helper using unsynchronized methods. This works because the methods are stateless with respect to the Host class. </LBody>
</LI>
</L>

<P id="LinkTarget_2868">Subject Descriptor </P>
<Figure id="LinkTarget_2869">

<ImageData src="images/4-Security Pattern Catalog_img_1151.jpg"/>
PatterndocumentationQuickinfo</Figure>

<P>Intent: Provide access to security-relevant attributes of an entity on whose behalf operations are to be performed. Aliases: Subject Attributes. The entity described may be referred to as a subject or principal. </P>
<Figure id="LinkTarget_2870">

<ImageData src="images/4-Security Pattern Catalog_img_1152.jpg"/>
Problem</Figure>

<P>There are many security-relevant attributes which may be associated with a subject; that is, an entity (human or program). Attributes may include properties of, and assertions about, the subject, as well as security-related possessions such as encryption keys. Control of access by the subject to different resources may depend on various attributes of the subject. Some attributes may themselves embody sensitive information requiring controlled access. </P>

<P>Subject Descriptor provides access to subject attributes and facilitates management and protection of those attributes, as well as providing a convenient abstraction for conveying attributes between subsystems. For example, an authentication subsystem could establish subject attributes including an assertion of a user's identity which could then be consumed and used by a separate authorization subsystem. </P>
<Figure id="LinkTarget_2871">

<ImageData src="images/4-Security Pattern Catalog_img_1153.jpg"/>
Forces</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1154.jpg"/>
</Figure>

<Lbl>A </Lbl>

<LBody>subsystem responsible for checking subject attributes (for example, rights or credentials)is independent of the subsystem which establishes those attributes. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1155.jpg"/>
</Figure>

<Lbl>Several </Lbl>

<LBody>subsystems establish attributes applying to the same subject. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1156.jpg"/>
</Figure>

<Lbl>Different </Lbl>

<LBody>types or sets of subject attributes may be used in different contexts. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1157.jpg"/>
</Figure>

<Lbl>Selective </Lbl>

<LBody>control of access to particular subject attributes is required. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1158.jpg"/>
</Figure>

<Lbl>Multiple </Lbl>

<LBody>subject identities need to be manipulated in a single operation. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2872">

<ImageData src="images/4-Security Pattern Catalog_img_1159.jpg"/>
Example</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2873">

<ImageData src="images/4-Security Pattern Catalog_img_1160.jpg"/>
Solution</Figure>

<P>Encapsulate the attributes for a subject in a Subject Descriptor, and support operations to provide access to the complete current set of attributes, or a filtered subset of those attributes. </P>
<Figure id="LinkTarget_2874">

<ImageData src="images/4-Security Pattern Catalog_img_1161.jpg"/>
Structure</Figure>

<P>Figure 1: Class layout of the Subject Descriptor </P>

<P>See Figure 1 . </P>
<Figure id="LinkTarget_2875">

<ImageData src="images/4-Security Pattern Catalog_img_1162.jpg"/>
Dynamics</Figure>
<Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1163.jpg"/>
</Figure>

<P>Figure 2: Retrieving a filtered set of attributes </P>

<P>See Figure 2 . </P>
<Figure id="LinkTarget_2876">

<ImageData src="images/4-Security Pattern Catalog_img_1164.jpg"/>
Participants</Figure>

<P>See also Figure 1 . </P>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1165.jpg"/>
</Figure>

<Lbl>Subject </Lbl>

<LBody>Descriptor Encapsulates a current set of attributes for a particular subject. Supports operations to provide access to the complete current set of attributes, or a filtered subset of those attributes. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1166.jpg"/>
</Figure>

<Lbl>Attribute </Lbl>

<LBody>List Controls access to and enables management of a list of attributes for a subject. A new Attribute List can be created to reference a filtered subset of an existing set of attributes. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1167.jpg"/>
</Figure>

<Lbl>Attribute </Lbl>

<LBody>Represents a single security attribute. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1168.jpg"/>
</Figure>

<Lbl>Attribute </Lbl>

<LBody>Type Allows related attributes to be classified according to a common type. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2877">

<ImageData src="images/4-Security Pattern Catalog_img_1169.jpg"/>
Collaborations</Figure>

<P>Attribute List returns an Iteratorallowing the caller to operate on the individual Attributes referenced in the list. </P>

<P>Attribute List may be a a guarded type, consulting a policy in order to determine whether the caller is permitted to access attributes within the list. A filtered Attribute List can be a way for a caller to pre-select only those attributes which it is permitted to access. </P>
<Figure id="LinkTarget_2878">

<ImageData src="images/4-Security Pattern Catalog_img_1170.jpg"/>
Implementation</Figure>

<P>When implementing Subject Descriptor, it may be helpful to choose a hierarchical representation for the attribute type. This helps extensibility in that you can have broad categories of attributes (for example, ``identity''for all attributes which are some type of name)which can be subdivided into more specific categories (for example, ``group identity'', or even more specific ``UNIX group ID number''). Callers can then select attributes at varying levels of abstraction choosing which is most suitable for their specific purpose. </P>

<P>Class names are a ready-made hierarchy which may be suitable. </P>
<Figure id="LinkTarget_2879">

<ImageData src="images/4-Security Pattern Catalog_img_1171.jpg"/>
Pitfalls</Figure>

<P>(Nothing given) </P>
<Figure id="LinkTarget_2880">

<ImageData src="images/4-Security Pattern Catalog_img_1172.jpg"/>
Consequences</Figure>

<L>
<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1173.jpg"/>
</Figure>

<Lbl>Encapsulates </Lbl>

<LBody>subject attributes Subject Descriptor allows a collection of attributes to be handled as a single object. New types of attributes can be added without modifying the Subject Descriptor or code which uses it. </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1174.jpg"/>
</Figure>

<Lbl>Provides </Lbl>

<LBody>a point of access control Subject Descriptor allows construction of Attribute Lists including access control functionality to ensure that unauthorized callers will not have access to confidential attributes (such as authentication tokens). </LBody>
</LI>

<LI><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1175.jpg"/>
</Figure>

<Lbl>JAAS </Lbl>

<LBody>(Java Authentication and Authorization Service)javax. security. auth. Subject JAAS divides the subject attributes into three collections: principals, public credentials, and private credentials. Principals (which might be better called identities, but the class name ``Identity''was already taken)are used to represent user identities and also groups and roles. There is a defined interface to Principal objects, allowing a name to be retrieved without requiring the specific implementing class to be known. Public and private credentials, on the other hand, are arbitrary Java objects and have no defined interface. </LBody>
</LI>
</L>
<Figure id="LinkTarget_2881">

<ImageData src="images/4-Security Pattern Catalog_img_1176.jpg"/>
Knownuses</Figure>

<P>Principals and public credentials may be retrieved by any caller which has a reference to the Subject object. Private credentials require a permission to be granted in order to access them, which may be specified down to the granularity of a particular credential object class within Subjects having a particular Principal class with a particular name. The JAAS Subject class includes a method to set a read-only flag which specifies that the Sets of Principals returned will be read-only (that is, the add ()and remove ()methods will fail). This is useful where a privileged caller gets a reference to a Subject object which it then wishes to pass on to an untrusted recipient. </P>

<P><Figure>

<ImageData src="images/4-Security Pattern Catalog_img_1177.jpg"/>
</Figure>
CORBASecurity SecurityLevel2:: Credentials CORBASecurity credentials lists encapsulate subject attributes. CORBASecurity associates a set of credentials with each execution context; OwnCredentials represent the security attributes associated with the process itself; ReceivedCredentials represent the security attributes associated with a communications session within which the process is the receiver; and TargetCredentials represent the security attributes which will be used to represent the process to a partner in a communications session within which the process is the sender. </P>

</Part>
</TaggedPDF-doc>
